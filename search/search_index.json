{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NH3-SOFC Simulation Package","text":"<p>Automated DFT and ML force field calculations for ammonia solid oxide fuel cell research</p>"},{"location":"#overview","title":"Overview","text":"<p>nh3sofc is a Python package that automates computational materials science workflows for studying ammonia (NH3) decomposition catalysis on solid oxide fuel cell (SOFC) electrode materials. The package integrates with VASP for DFT calculations and MACE for machine learning force fields.</p> <ul> <li> <p> Structure Building</p> <p>Build surfaces from bulk crystals, create oxynitride defects, and place adsorbate molecules with multiple methods.</p> <p> Structure Module</p> </li> <li> <p> VASP &amp; MACE</p> <p>Generate VASP input files with proper settings for relaxation, NEB, and frequency calculations. Use MACE for fast ML predictions.</p> <p> Calculators</p> </li> <li> <p> Analysis Tools</p> <p>Calculate adsorption energies, Gibbs free energies, identify rate-determining steps, and compare catalyst surfaces.</p> <p> Analysis</p> </li> <li> <p> Data Management</p> <p>Standardized naming conventions and ASE database integration for organizing calculations.</p> <p> Database</p> </li> <li> <p> Exsolution Simulation</p> <p>Model metal nanoparticle exsolution from perovskites, including defect formation, segregation, and catalysis on exsolved particles.</p> <p> Exsolution Tutorial</p> </li> <li> <p> Theoretical Framework</p> <p>Complete catalysis theory toolkit: d-band analysis, BEP relations, energy span model, microkinetic modeling, and volcano plots.</p> <p> Theory Guide</p> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#target-materials","title":"Target Materials","text":"Material Class Examples Focus Perovskite Oxynitrides LaVON\u2082\u208b\u2093, LaVO\u2083 Primary research target Doped Ceria GDC, SDC, PDC (Ce\u2081\u208b\u2093M\u2093O\u2082\u208b\u03b4) Ionic conductors with O vacancies Exsolution Perovskites La\u2080.\u2084Sr\u2080.\u2084Ti\u2080.\u2089Ni\u2080.\u2081O\u2083, Ni/GDC Metal nanoparticle catalysis Mixed Ion Conductors LSGM, BCZY Proton/oxide conductors Cermet Anodes Ni/YSZ, Ni/GDC Benchmark materials"},{"location":"#nh3-decomposition-pathway","title":"NH3 Decomposition Pathway","text":"<p>The package implements automated workflows for studying the complete NH3 decomposition mechanism:</p> <pre><code>NH3(g) \u2192 NH3* \u2192 NH2* + H* \u2192 NH* + 2H* \u2192 N* + 3H* \u2192 \u00bdN2(g) + 3/2H2(g)\n</code></pre>"},{"location":"#exsolution-simulation","title":"Exsolution Simulation","text":"<p>Model the complete exsolution pathway for perovskite materials:</p> <pre><code>Pristine \u2192 Defective \u2192 Segregated \u2192 Exsolved (with nanoparticle)\n</code></pre> <ul> <li>Support for Ni, Co, Fe exsolution from B-site</li> <li>Socketed nanoparticle modeling (realistic anchoring)</li> <li>Oxygen vacancy coupling with metal reduction</li> <li>Multiple adsorption sites: metal top, interface edge, vacancy sites</li> </ul>"},{"location":"#computational-methods","title":"Computational Methods","text":"<ul> <li>DFT: VASP with Hubbard U corrections, vdW-D3/D3BJ</li> <li>ML Force Fields: MACE foundation models and custom training</li> <li>NEB Workflows: Automated transition state searches with IDPP/climbing image</li> </ul>"},{"location":"#theoretical-framework","title":"Theoretical Framework","text":"<p>NH3SOFC implements a complete theoretical toolkit for computational catalysis:</p> Component Description Electronic Descriptors D-band center, width, and filling from DOSCAR Thermochemistry ZPE, entropy, Gibbs free energy (harmonic &amp; ideal gas) BEP Relations Built-in parameters for N-H, C-H, O-H dissociation Energy Span Model Kozuch-Shaik TDTS/TDI identification Microkinetics Steady-state solver, coverage-dependent rates, TOF Volcano Plots Descriptor-activity relationships, catalyst ranking Exsolution Energetics Vacancy formation, segregation, particle binding"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from nh3sofc.structure import BulkStructure, SurfaceBuilder, DefectBuilder\nfrom nh3sofc.calculators.vasp import VASPInputGenerator\n\n# Build oxynitride surface\nbulk = BulkStructure.from_cif(\"LaVO3.cif\")\nsurface = SurfaceBuilder(bulk).create_surface((0,0,1), layers=6, vacuum=15)\noxynitride = DefectBuilder(surface).create_oxynitride(\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.1\n)\n\n# Generate VASP inputs\nvasp = VASPInputGenerator(oxynitride, calc_type=\"relax\", work_dir=\"./calc\")\nvasp.generate_all(encut=520, hubbard_u={\"V\": 3.25}, vdw=\"D3BJ\")\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/lizhenzhupearl/nh3sofc.git\ncd nh3sofc\n\n# Install in development mode\npip install -e .\n</code></pre> <p>See Installation Guide for detailed instructions.</p>"},{"location":"#documentation","title":"Documentation","text":"<p> Tutorials</p> <p>Step-by-step guides for common workflows</p> <p> API Reference</p> <p>Complete API documentation</p> <p> Quick Start</p> <p>Code examples and use cases</p>"},{"location":"#package-structure","title":"Package Structure","text":"<pre><code>nh3sofc/\n\u251c\u2500\u2500 core/           # Constants, base classes\n\u251c\u2500\u2500 structure/      # Bulk, surface, defects, adsorbates\n\u251c\u2500\u2500 calculators/\n\u2502   \u251c\u2500\u2500 vasp/       # VASP input/output handling\n\u2502   \u2514\u2500\u2500 mace/       # MACE ML force field interface\n\u251c\u2500\u2500 jobs/           # PBS/HPC job management\n\u251c\u2500\u2500 workflows/      # Automated calculation workflows\n\u251c\u2500\u2500 analysis/       # Energetics, thermochemistry, kinetics\n\u2514\u2500\u2500 database/       # Naming conventions, ASE DB integration\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use this package, please cite:</p> <pre><code>@software{nh3sofc,\n  title = {NH3-SOFC: Automated Simulations for Ammonia Fuel Cell Research},\n  author = {Li, Zhenzhu},\n  year = {2026},\n  url = {https://github.com/lizhenzhupearl/nh3sofc}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to NH3-SOFC will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial release of NH3-SOFC package</li> <li>Structure building modules:</li> <li><code>BulkStructure</code> for CIF loading</li> <li><code>SurfaceBuilder</code> for slab generation</li> <li><code>DefectBuilder</code> for oxynitride creation</li> <li><code>AdsorbatePlacer</code> with 6 placement methods</li> <li><code>DecompositionBuilder</code> for NH3 intermediates</li> <li>VASP calculator interface:</li> <li><code>VASPInputGenerator</code> for INCAR/KPOINTS/POSCAR/POTCAR</li> <li><code>VASPOutputParser</code> for parsing results</li> <li><code>FrequencyCalculation</code> for vibrational analysis</li> <li>MACE ML force field interface:</li> <li><code>MACECalculatorWrapper</code> for foundation models</li> <li><code>MACEEnsemble</code> for uncertainty estimation</li> <li><code>TrainingDataExtractor</code> for active learning</li> <li>Workflow automation:</li> <li><code>RelaxationWorkflow</code></li> <li><code>DecompositionWorkflow</code></li> <li><code>NEBWorkflow</code></li> <li><code>FrequencyWorkflow</code></li> <li><code>ScreeningWorkflow</code></li> <li>Analysis tools:</li> <li><code>AdsorptionEnergyCalculator</code></li> <li><code>HarmonicThermo</code> and <code>IdealGasThermo</code></li> <li><code>RDSAnalyzer</code> for rate-determining steps</li> <li><code>SurfaceComparator</code> for catalyst ranking</li> <li><code>MicroKineticModel</code> for TOF prediction</li> <li>Database integration:</li> <li><code>NamingConvention</code> for standardized naming</li> <li><code>NH3SOFCDatabase</code> ASE database wrapper</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>N/A</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>N/A</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>N/A</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>N/A</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>N/A</li> </ul>"},{"location":"changelog/#010-2024-xx-xx","title":"[0.1.0] - 2024-XX-XX","text":"<ul> <li>Initial development version</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to NH3-SOFC!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/yourusername/NH3SOFC.git\ncd NH3SOFC\n</code></pre> <ol> <li>Create a development environment:</li> </ol> <pre><code>conda create -n nh3sofc-dev python=3.10\nconda activate nh3sofc-dev\npip install -e \".[dev]\"\n</code></pre> <ol> <li>Install pre-commit hooks:</li> </ol> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>We use Black for code formatting</li> <li>We use isort for import sorting</li> <li>We use flake8 for linting</li> </ul> <p>Run formatting:</p> <pre><code>black nh3sofc/\nisort nh3sofc/\nflake8 nh3sofc/\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Run tests with pytest:</p> <pre><code>pytest tests/\npytest tests/ -v --cov=nh3sofc\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Make your changes</li> <li>Run tests and ensure they pass</li> <li>Commit your changes (<code>git commit -m 'Add amazing feature'</code>)</li> <li>Push to the branch (<code>git push origin feature/amazing-feature</code>)</li> <li>Open a Pull Request</li> </ol>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Please use the GitHub Issues page to report bugs or request features.</p> <p>When reporting bugs, please include:</p> <ul> <li>Python version</li> <li>ASE version</li> <li>Operating system</li> <li>Complete error traceback</li> <li>Minimal code to reproduce the issue</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is built with MkDocs:</p> <pre><code>pip install mkdocs mkdocs-material mkdocstrings[python]\nmkdocs serve  # Local preview at http://127.0.0.1:8000\nmkdocs build  # Build static site\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":""},{"location":"installation/#python-version","title":"Python Version","text":"<ul> <li>Python 3.9 or higher</li> </ul>"},{"location":"installation/#core-dependencies","title":"Core Dependencies","text":"Package Version Purpose <code>ase</code> \u22653.22.0 Atomic Simulation Environment <code>numpy</code> \u22651.21.0 Numerical computing <code>scipy</code> \u22651.7.0 Scientific computing <code>torch</code> \u22652.0.0 PyTorch for ML models <code>mace-torch</code> \u22650.3.0 MACE ML force field <code>spglib</code> \u22652.0.0 Space group analysis <code>matplotlib</code> \u22653.5.0 Plotting and visualization"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"Package Version Purpose <code>pymatgen</code> \u22652022.0.0 Advanced materials analysis"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-development-install-recommended","title":"Method 1: Development Install (Recommended)","text":"<p>For active development or to get the latest features:</p> <pre><code># Clone the repository\ngit clone https://github.com/lizhenzhupearl/nh3sofc.git\ncd nh3sofc\n\n# Create a virtual environment (recommended)\npython -m venv venv\nsource venv/bin/activate  # Linux/Mac\n# or: venv\\Scripts\\activate  # Windows\n\n# Install PyTorch first (choose one based on your system)\n# CPU version:\npip install torch --index-url https://download.pytorch.org/whl/cpu\n\n# Or GPU version (CUDA 11.8):\n# pip install torch --index-url https://download.pytorch.org/whl/cu118\npip install mace-torch\npip install spglib\n# Install nh3sofc with all dependencies\npip install -e .\n</code></pre>"},{"location":"installation/#method-2-direct-install-from-github","title":"Method 2: Direct Install from GitHub","text":"<pre><code># Install PyTorch first (see above for CPU/GPU options)\npip install torch --index-url https://download.pytorch.org/whl/cpu\n\n# Install nh3sofc\npip install git+https://github.com/lizhenzhupearl/nh3sofc.git\n</code></pre>"},{"location":"installation/#method-3-install-from-pypi-future","title":"Method 3: Install from PyPI (Future)","text":"<pre><code>pip install nh3sofc  # Not yet available\n</code></pre>"},{"location":"installation/#installing-optional-dependencies","title":"Installing Optional Dependencies","text":"<p>For advanced materials analysis with pymatgen:</p> <pre><code>pip install pymatgen\n</code></pre>"},{"location":"installation/#vasp-configuration","title":"VASP Configuration","text":"<p>The package requires VASP pseudopotential files. Set the environment variable:</p> <pre><code># Add to your ~/.bashrc or ~/.zshrc\nexport VASP_PP_PATH=\"/path/to/vasp/potentials\"\n</code></pre> <p>The directory structure should be:</p> <pre><code>$VASP_PP_PATH/\n\u251c\u2500\u2500 potpaw_PBE/\n\u2502   \u251c\u2500\u2500 La/POTCAR\n\u2502   \u251c\u2500\u2500 V/POTCAR\n\u2502   \u251c\u2500\u2500 O/POTCAR\n\u2502   \u251c\u2500\u2500 N/POTCAR\n\u2502   \u251c\u2500\u2500 H/POTCAR\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 potpaw_LDA/  # Optional\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"installation/#pbshpc-configuration","title":"PBS/HPC Configuration","text":"<p>For cluster job submission, configure your PBS settings:</p> <pre><code>from nh3sofc.jobs import VASPJobScript\n\n# Default settings can be customized\njob = VASPJobScript(\n    work_dir=\"./calc\",\n    nodes=2,\n    ppn=24,\n    walltime=\"24:00:00\",\n    queue=\"normal\",\n)\n</code></pre>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>Run the following to verify your installation:</p> <pre><code># Test core dependencies\nimport numpy as np\nprint(f\"NumPy version: {np.__version__}\")\n\nimport scipy\nprint(f\"SciPy version: {scipy.__version__}\")\n\nimport ase\nprint(f\"ASE version: {ase.__version__}\")\n\nimport torch\nprint(f\"PyTorch version: {torch.__version__}\")\nprint(f\"CUDA available: {torch.cuda.is_available()}\")\n\nimport mace\nprint(f\"MACE-torch: OK\")\n\nimport spglib\nprint(f\"spglib version: {spglib.__version__}\")\n\nimport matplotlib\nprint(f\"Matplotlib version: {matplotlib.__version__}\")\n\n# Test nh3sofc package\nimport nh3sofc\nprint(f\"nh3sofc version: {nh3sofc.__version__ if hasattr(nh3sofc, '__version__') else 'dev'}\")\n\n# Test structure module\nfrom nh3sofc.structure import BulkStructure, SurfaceBuilder, AdsorbatePlacer\nprint(\"Structure module: OK\")\n\n# Test calculators\nfrom nh3sofc.calculators.vasp import VASPInputGenerator, VASPOutputParser\nprint(\"VASP calculators: OK\")\n\nfrom nh3sofc.calculators.mace import MACECalculatorWrapper\nprint(\"MACE calculator: OK\")\n\n# Test workflows\nfrom nh3sofc.workflows import RelaxationWorkflow, DecompositionWorkflow\nprint(\"Workflows: OK\")\n\n# Test analysis\nfrom nh3sofc.analysis import AdsorptionEnergyCalculator, SurfaceComparator\nprint(\"Analysis: OK\")\n\nprint(\"\\n\u2713 Installation successful!\")\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#1-import-error-no-module-named-ase","title":"1. Import Error: No module named 'ase'","text":"<pre><code>pip install ase\n</code></pre>"},{"location":"installation/#2-vasp-potcar-not-found","title":"2. VASP POTCAR not found","text":"<p>Ensure <code>VASP_PP_PATH</code> is set correctly:</p> <pre><code>echo $VASP_PP_PATH\nls $VASP_PP_PATH/potpaw_PBE/\n</code></pre>"},{"location":"installation/#3-mace-or-pytorch-installation-fails","title":"3. MACE or PyTorch installation fails","text":"<p>Ensure PyTorch is installed first with the correct version for your system:</p> <pre><code># CPU version\npip install torch --index-url https://download.pytorch.org/whl/cpu\n\n# Or GPU version (CUDA 11.8)\npip install torch --index-url https://download.pytorch.org/whl/cu118\n\n# Then install MACE\npip install mace-torch\n</code></pre>"},{"location":"installation/#4-spglib-import-error","title":"4. spglib import error","text":"<pre><code>pip install spglib\n</code></pre>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<ul> <li>Open an issue on GitHub</li> <li>Check the Tutorials for common workflows</li> </ul>"},{"location":"installation/#updating","title":"Updating","text":"<p>To update to the latest version:</p> <pre><code>cd nh3sofc\ngit pull\npip install -e .\n</code></pre>"},{"location":"installation/#uninstalling","title":"Uninstalling","text":"<pre><code>pip uninstall nh3sofc\n</code></pre>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 NH3-SOFC Authors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide will walk you through the basic workflow for studying NH3 decomposition on a perovskite oxynitride surface.</p>"},{"location":"quickstart/#overview","title":"Overview","text":"<p>A typical calculation workflow consists of:</p> <ol> <li>Build Structure - Create surface from bulk, add defects</li> <li>Place Adsorbate - Add NH3 or decomposition intermediates</li> <li>Set Up Calculation - Generate VASP inputs</li> <li>Run &amp; Analyze - Parse results, calculate properties</li> </ol>"},{"location":"quickstart/#step-1-build-an-oxynitride-surface","title":"Step 1: Build an Oxynitride Surface","text":""},{"location":"quickstart/#load-bulk-structure","title":"Load Bulk Structure","text":"<pre><code>from nh3sofc.structure import BulkStructure\n\n# From CIF file\nbulk = BulkStructure.from_cif(\"LaVO3.cif\")\n\n# Or from ASE/pymatgen\nfrom ase.build import bulk as ase_bulk\nbulk_atoms = ase_bulk('Ni', 'fcc', a=3.52)\nbulk = BulkStructure(bulk_atoms)\n\n# Check structure\nprint(f\"Formula: {bulk.atoms.get_chemical_formula()}\")\nprint(f\"Space group: {bulk.get_spacegroup()}\")\n</code></pre>"},{"location":"quickstart/#create-surface-slab","title":"Create Surface Slab","text":"<pre><code>from nh3sofc.structure import SurfaceBuilder\n\nbuilder = SurfaceBuilder(bulk)\n\n# Create (001) surface with 6 layers and 15 \u00c5 vacuum\nsurface = builder.create_surface(\n    miller_index=(0, 0, 1),\n    layers=6,\n    vacuum=15.0,\n    fix_bottom=2  # Fix bottom 2 layers\n)\n\nprint(f\"Slab atoms: {len(surface.atoms)}\")\nprint(f\"Cell: {surface.atoms.cell.lengths()}\")\n</code></pre>"},{"location":"quickstart/#create-oxynitride-defects","title":"Create Oxynitride Defects","text":"<pre><code>from nh3sofc.structure import DefectBuilder\n\ndefect_builder = DefectBuilder(surface.atoms)\n\n# Create LaVON2-x with 10% vacancies\noxynitride = defect_builder.create_oxynitride(\n    nitrogen_fraction=0.67,      # Replace 2/3 of O with N\n    vacancy_concentration=0.10   # 10% O/N vacancies\n)\n\nprint(f\"Composition: {oxynitride.get_chemical_formula()}\")\n</code></pre>"},{"location":"quickstart/#step-2-place-nh3-adsorbate","title":"Step 2: Place NH3 Adsorbate","text":"<pre><code>from nh3sofc.structure import AdsorbatePlacer\n\nplacer = AdsorbatePlacer(oxynitride)\n\n# Method 1: On-top of specific atom types\nconfigs = placer.add_on_site(\n    adsorbate=\"NH3\",\n    site_type=\"ontop\",        # Site type: \"ontop\", \"bridge\", or \"hollow\"\n    atom_types=[\"La\", \"V\"],   # Only on La or V atoms\n    height=2.0\n)\nprint(f\"Generated {len(configs)} configurations\")\n\n# Method 2: Random placement with collision detection\nrandom_configs = placer.add_with_collision(\n    adsorbate=\"NH3\",\n    n_configs=10,             # Number of configurations to generate\n    min_distance=2.0,\n    height=2.0\n)\n\n# Method 3: All unique sites (using CatKit if available)\ntry:\n    all_sites = placer.add_catkit(\"NH3\", site_type=\"ontop\")\nexcept ImportError:\n    print(\"CatKit not installed, using collision-aware placement\")\n    all_sites = random_configs if random_configs else []\n</code></pre>"},{"location":"quickstart/#step-3-set-up-vasp-calculation","title":"Step 3: Set Up VASP Calculation","text":""},{"location":"quickstart/#generate-input-files","title":"Generate Input Files","text":"<pre><code>from nh3sofc.calculators.vasp import VASPInputGenerator\n\n# Select first configuration\natoms = configs[0]\n\n# Create generator\nvasp = VASPInputGenerator(\n    atoms,\n    calc_type=\"relax\",  # Options: relax, static, neb, frequency, md\n    work_dir=\"./calc/LaVON_001_NH3\"\n)\n\n# Generate all input files\nfiles = vasp.generate_all(\n    encut=520,              # Plane-wave cutoff\n    kspacing=0.03,          # K-point spacing\n    hubbard_u={\"V\": 3.25},  # DFT+U for V\n    vdw=\"D3BJ\",             # vdW correction\n    is_surface=True         # Surface-specific settings\n)\n\nprint(\"Generated files:\")\nfor name, path in files.items():\n    print(f\"  {name}: {path}\")\n</code></pre>"},{"location":"quickstart/#generate-pbs-script","title":"Generate PBS Script","text":"<pre><code>from nh3sofc.jobs import create_vasp_job\n\npbs_file = create_vasp_job(\n    work_dir=\"./calc/LaVON_001_NH3\",\n    nodes=2,\n    ppn=24,\n    walltime=\"24:00:00\",\n    queue=\"normal\"\n)\n\nprint(f\"Submit with: qsub {pbs_file}\")\n</code></pre>"},{"location":"quickstart/#step-4-parse-results","title":"Step 4: Parse Results","text":"<p>After the VASP job completes:</p> <pre><code>from nh3sofc.calculators.vasp import VASPOutputParser\n\nparser = VASPOutputParser(\"./calc/LaVON_001_NH3\")\n\n# Check convergence\nif parser.is_converged():\n    energy = parser.get_energy()\n    forces = parser.get_forces()\n    final_structure = parser.get_final_structure()\n\n    print(f\"Energy: {energy:.4f} eV\")\n    print(f\"Max force: {parser.get_max_force():.4f} eV/\u00c5\")\nelse:\n    print(\"Calculation did not converge!\")\n</code></pre>"},{"location":"quickstart/#step-5-calculate-adsorption-energy","title":"Step 5: Calculate Adsorption Energy","text":"<pre><code>from nh3sofc.analysis import AdsorptionEnergyCalculator\n\ncalc = AdsorptionEnergyCalculator()\n\n# Set reference energies (from your calculations)\ncalc.set_surface_energy(-250.0)  # Clean surface energy\ncalc.set_gas_reference(\"NH3\", -19.54)  # Gas phase NH3\n\n# Calculate adsorption energy\nE_ads = calc.calculate(\n    e_total=-270.5,  # NH3/surface energy\n    adsorbate=\"NH3\"\n)\n\nprint(f\"Adsorption energy: {E_ads:.3f} eV\")\n</code></pre>"},{"location":"quickstart/#complete-workflow-example","title":"Complete Workflow Example","text":"<p>Here's a complete script for studying NH3 decomposition:</p> <pre><code>from nh3sofc.structure import BulkStructure, SurfaceBuilder, DefectBuilder\nfrom nh3sofc.structure import DecompositionBuilder\nfrom nh3sofc.workflows import DecompositionWorkflow\n\n# 1. Build oxynitride surface\nbulk = BulkStructure.from_cif(\"LaVO3.cif\")\nsurface = SurfaceBuilder(bulk).create_surface((0,0,1), layers=6, vacuum=15)\noxynitride = DefectBuilder(surface.atoms).create_oxynitride(\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.1\n)\n\n# 2. Add NH3 and optimize (assuming you have the relaxed structure)\n# nh3_on_surface = ... (load from previous calculation)\n\n# 3. Set up decomposition workflow\nworkflow = DecompositionWorkflow(\n    nh3_on_slab=nh3_on_surface,\n    work_dir=\"./decomposition\",\n    n_configs_per_step=5,\n    calculator=\"vasp\",\n    encut=520,\n    hubbard_u={\"V\": 3.25},\n)\n\n# 4. Generate all configurations and set up calculations\nworkflow.setup()\n\n# 5. After calculations complete, analyze results\nresults = workflow.parse_results()\nenergy_profile = workflow.get_energy_profile()\nworkflow.print_summary()\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial: Surface Building</li> <li>Tutorial: NH3 Decomposition</li> <li>Tutorial: NEB Calculations</li> <li>API Reference</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for the nh3sofc package.</p>"},{"location":"api/#package-structure","title":"Package Structure","text":"<pre><code>nh3sofc/\n\u251c\u2500\u2500 core/           # Base classes and constants\n\u251c\u2500\u2500 structure/      # Structure building\n\u251c\u2500\u2500 calculators/    # VASP and MACE interfaces\n\u251c\u2500\u2500 jobs/           # HPC job management\n\u251c\u2500\u2500 workflows/      # Automated workflows\n\u251c\u2500\u2500 analysis/       # Post-processing tools\n\u2514\u2500\u2500 database/       # Data management\n</code></pre>"},{"location":"api/#modules","title":"Modules","text":""},{"location":"api/#core","title":"Core","text":"Module Description <code>nh3sofc.core.constants</code> Physical constants, default parameters <code>nh3sofc.core.base</code> Base classes for structures and workflows"},{"location":"api/#structure-building","title":"Structure Building","text":"Class Description <code>BulkStructure</code> Load and manipulate bulk crystals <code>SurfaceBuilder</code> Create surface slabs <code>DefectBuilder</code> Create oxynitride defects <code>AdsorbatePlacer</code> Place adsorbate molecules <code>DecompositionBuilder</code> Generate decomposition intermediates"},{"location":"api/#calculators","title":"Calculators","text":"Class Description <code>VASPInputGenerator</code> Generate VASP input files <code>VASPOutputParser</code> Parse VASP results <code>FrequencyCalculation</code> Vibrational analysis <code>MACECalculatorWrapper</code> MACE ML force field"},{"location":"api/#workflows","title":"Workflows","text":"Class Description <code>RelaxationWorkflow</code> Geometry optimization <code>DecompositionWorkflow</code> NH3 decomposition pathway <code>NEBWorkflow</code> Transition state search <code>FrequencyWorkflow</code> Thermochemistry <code>ScreeningWorkflow</code> High-throughput screening"},{"location":"api/#analysis","title":"Analysis","text":"Class Description <code>AdsorptionEnergyCalculator</code> Adsorption energies <code>HarmonicThermo</code> Adsorbate thermodynamics <code>RDSAnalyzer</code> Rate-determining step <code>SurfaceComparator</code> Compare catalyst surfaces <code>MicroKineticModel</code> Microkinetic modeling"},{"location":"api/#database","title":"Database","text":"Class Description <code>NamingConvention</code> Standardized naming <code>NH3SOFCDatabase</code> ASE database wrapper"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#common-imports","title":"Common Imports","text":"<pre><code># Structure\nfrom nh3sofc.structure import (\n    BulkStructure,\n    SurfaceBuilder,\n    DefectBuilder,\n    AdsorbatePlacer,\n    DecompositionBuilder,\n)\n\n# Calculators\nfrom nh3sofc.calculators.vasp import (\n    VASPInputGenerator,\n    VASPOutputParser,\n    FrequencyCalculation,\n)\nfrom nh3sofc.calculators.mace import (\n    MACECalculatorWrapper,\n    TrainingDataExtractor,\n)\n\n# Workflows\nfrom nh3sofc.workflows import (\n    RelaxationWorkflow,\n    DecompositionWorkflow,\n    NEBWorkflow,\n    FrequencyWorkflow,\n    ScreeningWorkflow,\n)\n\n# Analysis\nfrom nh3sofc.analysis import (\n    AdsorptionEnergyCalculator,\n    HarmonicThermo,\n    IdealGasThermo,\n    RDSAnalyzer,\n    SurfaceComparator,\n    MicroKineticModel,\n)\n\n# Database\nfrom nh3sofc.database import (\n    NamingConvention,\n    NH3SOFCDatabase,\n)\n</code></pre>"},{"location":"api/#physical-constants","title":"Physical Constants","text":"<pre><code>from nh3sofc.core.constants import (\n    KB_EV,          # 8.617e-5 eV/K - Boltzmann constant\n    H_EV_S,         # 4.136e-15 eV\u00b7s - Planck constant\n    C_CMS,          # 2.998e10 cm/s - Speed of light\n    EV_TO_J,        # 1.602e-19 J/eV - Energy conversion\n    HUBBARD_U,      # Default Hubbard U values\n    GAS_PHASE_ENERGIES,  # Reference gas energies\n)\n</code></pre>"},{"location":"api/#default-vasp-parameters","title":"Default VASP Parameters","text":"<pre><code>from nh3sofc.core.constants import DEFAULT_VASP_PARAMS\n\n# Defaults:\n# encut=520, ediff=1e-6, ediffg=-0.02\n# ismear=0, sigma=0.05, kspacing=0.03\n# ispin=2, lorbit=11, ncore=4\n</code></pre>"},{"location":"api/analysis/","title":"Analysis Module","text":"<p>The <code>nh3sofc.analysis</code> module provides comprehensive tools for analyzing calculation results, including electronic structure descriptors, energetics, thermochemistry, and kinetics.</p>"},{"location":"api/analysis/#electronic-structure-analysis","title":"Electronic Structure Analysis","text":""},{"location":"api/analysis/#dbandanalyzer","title":"DBandAnalyzer","text":"<p>Analyze d-band electronic structure from VASP DOSCAR files.</p> <pre><code>from nh3sofc.analysis import DBandAnalyzer\n</code></pre>"},{"location":"api/analysis/#constructor","title":"Constructor","text":"<pre><code>DBandAnalyzer(\n    energy: np.ndarray,\n    dos_total: np.ndarray,\n    dos_projected: Dict[int, Dict[str, np.ndarray]] = None,\n    e_fermi: float = 0.0,\n    is_spin_polarized: bool = False\n)\n</code></pre>"},{"location":"api/analysis/#class-methods","title":"Class Methods","text":""},{"location":"api/analysis/#from_doscar","title":"from_doscar","text":"<pre><code>@classmethod\nfrom_doscar(\n    filepath: str,\n    atoms_to_parse: List[int] = None\n) -&gt; DBandAnalyzer\n</code></pre> <p>Create analyzer from VASP DOSCAR file.</p>"},{"location":"api/analysis/#methods","title":"Methods","text":"Method Description <code>get_d_band_center(atom_index)</code> D-band center (1st moment) in eV <code>get_d_band_width(atom_index)</code> D-band width (2nd moment) in eV <code>get_d_band_filling(atom_index)</code> Fraction of occupied d-states (0-1) <code>get_d_band_properties(atom_indices)</code> Dict with center, width, filling <code>get_surface_average_d_band_center(indices)</code> Weighted average for surface <p>Example:</p> <pre><code># Parse DOSCAR and analyze d-band\nanalyzer = DBandAnalyzer.from_doscar(\"DOSCAR\")\n\n# D-band center for atom 0\nd_center = analyzer.get_d_band_center(atom_index=0)\nprint(f\"D-band center: {d_center:.3f} eV\")\n\n# Properties for surface atoms\nprops = analyzer.get_d_band_properties([0, 1, 2, 3])\nfor atom, data in props.items():\n    print(f\"Atom {atom}: \u03b5_d = {data['center']:.2f} eV\")\n\n# Average for all surface atoms\navg = analyzer.get_surface_average_d_band_center([0, 1, 2, 3])\n</code></pre>"},{"location":"api/analysis/#convenience-functions","title":"Convenience Functions","text":""},{"location":"api/analysis/#calculate_d_band_center","title":"calculate_d_band_center","text":"<pre><code>calculate_d_band_center(\n    doscar_path: str,\n    atom_indices: List[int],\n    energy_range: Tuple[float, float] = None\n) -&gt; Dict[int, float]\n</code></pre> <p>Quick calculation of d-band centers.</p>"},{"location":"api/analysis/#get_surface_d_band_center","title":"get_surface_d_band_center","text":"<pre><code>get_surface_d_band_center(\n    doscar_path: str,\n    surface_atom_indices: List[int]\n) -&gt; Tuple[float, Dict[int, float]]\n</code></pre> <p>Returns <code>(average_center, per_atom_dict)</code>.</p> <p>Example:</p> <pre><code>from nh3sofc.analysis import calculate_d_band_center, get_surface_d_band_center\n\n# Quick calculation\ncenters = calculate_d_band_center(\"DOSCAR\", [0, 1, 2])\n\n# Surface average\navg, per_atom = get_surface_d_band_center(\"DOSCAR\", [0, 1, 2, 3])\nprint(f\"Surface \u03b5_d = {avg:.3f} eV\")\n</code></pre>"},{"location":"api/analysis/#adsorptionenergycalculator","title":"AdsorptionEnergyCalculator","text":"<p>Calculate adsorption energies.</p> <pre><code>from nh3sofc.analysis import AdsorptionEnergyCalculator\n</code></pre>"},{"location":"api/analysis/#constructor_1","title":"Constructor","text":"<pre><code>AdsorptionEnergyCalculator(\n    e_surface: float = None,\n    gas_references: dict = None\n)\n</code></pre>"},{"location":"api/analysis/#methods_1","title":"Methods","text":""},{"location":"api/analysis/#calculate","title":"calculate","text":"<pre><code>calculate(\n    e_total: float,\n    adsorbate: str = \"NH3\",\n    n_adsorbates: int = 1\n) -&gt; float\n</code></pre> <p>Calculate adsorption energy: <code>E_ads = E(ads/surf) - E(surf) - n*E(gas)</code></p> <p>Example:</p> <pre><code>calc = AdsorptionEnergyCalculator()\ncalc.set_surface_energy(-150.0)\ncalc.set_gas_reference(\"NH3\", -19.54)\n\nE_ads = calc.calculate(-170.0, \"NH3\")\nprint(f\"Adsorption energy: {E_ads:.3f} eV\")\n</code></pre>"},{"location":"api/analysis/#harmonicthermo","title":"HarmonicThermo","text":"<p>Harmonic thermodynamics for adsorbates.</p> <pre><code>from nh3sofc.analysis import HarmonicThermo\n</code></pre>"},{"location":"api/analysis/#constructor_2","title":"Constructor","text":"<pre><code>HarmonicThermo(\n    frequencies: List[float],   # cm^-1\n    electronic_energy: float = 0.0\n)\n</code></pre>"},{"location":"api/analysis/#methods_2","title":"Methods","text":"Method Description <code>get_zpe()</code> Zero-point energy (eV) <code>get_vibrational_energy(T)</code> U_vib at temperature T (eV) <code>get_vibrational_entropy(T)</code> S_vib at temperature T (eV/K) <code>get_gibbs_energy(T)</code> Gibbs free energy (eV) <code>get_heat_capacity(T)</code> Cv at temperature T (eV/K) <p>Example:</p> <pre><code># Frequencies from VASP frequency calculation\nfrequencies = [3400, 3300, 1600, 1100, 500, 400]  # cm^-1\n\nthermo = HarmonicThermo(frequencies, electronic_energy=-170.0)\n\nprint(f\"ZPE: {thermo.get_zpe():.4f} eV\")\nprint(f\"G(673K): {thermo.get_gibbs_energy(673):.4f} eV\")\n</code></pre>"},{"location":"api/analysis/#idealgasthermo","title":"IdealGasThermo","text":"<p>Ideal gas thermodynamics including translational, rotational, and vibrational contributions.</p> <pre><code>from nh3sofc.analysis import IdealGasThermo\n</code></pre>"},{"location":"api/analysis/#constructor_3","title":"Constructor","text":"<pre><code>IdealGasThermo(\n    frequencies: List[float],\n    electronic_energy: float,\n    mass: float,              # amu\n    geometry: str = \"nonlinear\",\n    symmetry_number: int = 1,\n    spin: int = 0\n)\n</code></pre>"},{"location":"api/analysis/#methods_3","title":"Methods","text":"Method Description <code>get_translational_entropy(T, p)</code> S_trans (eV/K) <code>get_rotational_entropy(T)</code> S_rot (eV/K) <code>get_total_entropy(T, p)</code> Total entropy (eV/K) <code>get_enthalpy_correction(T)</code> H(T) - H(0) (eV) <code>get_gibbs_energy(T, p)</code> Gibbs free energy (eV) <p>Example:</p> <pre><code># H2 gas at 673 K, 1 bar\nh2_thermo = IdealGasThermo(\n    frequencies=[4400],  # H-H stretch\n    electronic_energy=-6.77,\n    mass=2.016,\n    geometry=\"linear\",\n    symmetry_number=2\n)\n\nG_H2 = h2_thermo.get_gibbs_energy(T=673, p=1.0)\n</code></pre>"},{"location":"api/analysis/#rdsanalyzer","title":"RDSAnalyzer","text":"<p>Identify the rate-determining step.</p> <pre><code>from nh3sofc.analysis import RDSAnalyzer\n</code></pre>"},{"location":"api/analysis/#constructor_4","title":"Constructor","text":"<pre><code>RDSAnalyzer()\n</code></pre>"},{"location":"api/analysis/#methods_4","title":"Methods","text":""},{"location":"api/analysis/#set_pathway","title":"set_pathway","text":"<pre><code>set_pathway(pathway: Dict[str, float])\n</code></pre> <p>Set reaction pathway energies.</p>"},{"location":"api/analysis/#find_rds_thermodynamic","title":"find_rds_thermodynamic","text":"<pre><code>find_rds_thermodynamic() -&gt; Tuple[str, float]\n</code></pre> <p>Find RDS using thermodynamic approximation (highest \u0394E step).</p>"},{"location":"api/analysis/#find_rds_bep","title":"find_rds_bep","text":"<pre><code>find_rds_bep() -&gt; Tuple[str, float]\n</code></pre> <p>Find RDS using BEP-estimated barriers.</p>"},{"location":"api/analysis/#find_rds_energy_span","title":"find_rds_energy_span","text":"<pre><code>find_rds_energy_span() -&gt; Tuple[float, str, str]\n</code></pre> <p>Find RDS using energy span model.</p> <p>Returns: <code>(energy_span, TDTS, TDI)</code></p> <p>Example:</p> <pre><code>analyzer = RDSAnalyzer()\nanalyzer.set_pathway({\n    'NH3*': 0.0,\n    'NH2*+H*': 0.8,\n    'NH*+2H*': 1.5,\n    'N*+3H*': 1.2\n})\n\n# Thermodynamic RDS\nrds, dE = analyzer.find_rds_thermodynamic()\nprint(f\"RDS: {rds}, \u0394E = {dE:.3f} eV\")\n\n# Energy span\nspan, tdts, tdi = analyzer.find_rds_energy_span()\nprint(f\"Energy span: {span:.3f} eV\")\n</code></pre>"},{"location":"api/analysis/#beprelation","title":"BEPRelation","text":"<p>Br\u00f8nsted-Evans-Polanyi relations for barrier estimation.</p> <pre><code>from nh3sofc.analysis import BEPRelation\n</code></pre>"},{"location":"api/analysis/#constructor_5","title":"Constructor","text":"<pre><code>BEPRelation(\n    alpha: float = None,\n    beta: float = None,\n    reaction_type: str = \"default\"\n)\n</code></pre>"},{"location":"api/analysis/#pre-defined-reaction-types","title":"Pre-defined Reaction Types","text":"Type \u03b1 \u03b2 Description <code>\"N-H_dissociation\"</code> 0.87 0.95 NH3 \u2192 NH2 + H <code>\"C-H_dissociation\"</code> 0.75 0.90 C-H breaking <code>\"O-H_dissociation\"</code> 0.65 0.85 O-H breaking <code>\"N-N_formation\"</code> 0.50 1.20 N2 formation <code>\"H-H_formation\"</code> 0.60 0.80 H2 formation <code>\"default\"</code> 0.80 1.00 General"},{"location":"api/analysis/#methods_5","title":"Methods","text":""},{"location":"api/analysis/#estimate_barrier","title":"estimate_barrier","text":"<pre><code>estimate_barrier(reaction_energy: float) -&gt; float\n</code></pre> <p>Estimate activation barrier: <code>E_a = \u03b1*\u0394E + \u03b2</code></p> <p>Example:</p> <pre><code>bep = BEPRelation(reaction_type=\"N-H_dissociation\")\nbarrier = bep.estimate_barrier(0.5)  # \u0394E = 0.5 eV\nprint(f\"Estimated barrier: {barrier:.3f} eV\")\n</code></pre>"},{"location":"api/analysis/#surfacecomparator","title":"SurfaceComparator","text":"<p>Compare and rank catalyst surfaces.</p> <pre><code>from nh3sofc.analysis import SurfaceComparator\n</code></pre>"},{"location":"api/analysis/#constructor_6","title":"Constructor","text":"<pre><code>SurfaceComparator(\n    surfaces: Dict[str, Dict[str, float]],\n    barriers: Dict[str, Dict[str, float]] = None\n)\n</code></pre>"},{"location":"api/analysis/#methods_6","title":"Methods","text":""},{"location":"api/analysis/#rank_by_energy_span","title":"rank_by_energy_span","text":"<pre><code>rank_by_energy_span() -&gt; List[Tuple[str, float]]\n</code></pre> <p>Rank surfaces by energy span (lower is better).</p>"},{"location":"api/analysis/#rank_by_max_barrier","title":"rank_by_max_barrier","text":"<pre><code>rank_by_max_barrier() -&gt; List[Tuple[str, float]]\n</code></pre> <p>Rank surfaces by maximum barrier.</p>"},{"location":"api/analysis/#get_best_surface","title":"get_best_surface","text":"<pre><code>get_best_surface(method: str = \"energy_span\") -&gt; str\n</code></pre> <p>Get the best performing surface.</p>"},{"location":"api/analysis/#plot_energy_profiles","title":"plot_energy_profiles","text":"<pre><code>plot_energy_profiles(filename: str = None)\n</code></pre> <p>Plot comparison of energy profiles.</p> <p>Example:</p> <pre><code>surfaces = {\n    'LaO-term': {'NH3*': 0.0, 'NH2*+H*': 0.8, 'NH*+2H*': 1.5, 'N*+3H*': 1.2},\n    'VO2-term': {'NH3*': 0.0, 'NH2*+H*': 0.6, 'NH*+2H*': 1.2, 'N*+3H*': 0.9},\n}\n\ncomparator = SurfaceComparator(surfaces)\n\n# Ranking\nranking = comparator.rank_by_energy_span()\nfor i, (name, span) in enumerate(ranking, 1):\n    print(f\"{i}. {name}: {span:.3f} eV\")\n\n# Best surface\nbest = comparator.get_best_surface()\nprint(f\"Best: {best}\")\n\n# Plot\ncomparator.plot_energy_profiles(\"comparison.png\")\n</code></pre>"},{"location":"api/analysis/#microkineticmodel","title":"MicroKineticModel","text":"<p>Microkinetic modeling for steady-state analysis.</p> <pre><code>from nh3sofc.analysis import MicroKineticModel\n</code></pre>"},{"location":"api/analysis/#constructor_7","title":"Constructor","text":"<pre><code>MicroKineticModel(\n    temperature: float = 673.0,\n    total_sites: float = 1.0\n)\n</code></pre>"},{"location":"api/analysis/#methods_7","title":"Methods","text":""},{"location":"api/analysis/#add_species","title":"add_species","text":"<pre><code>add_species(\n    name: str,\n    is_site: bool = False,\n    initial_coverage: float = 0.0\n)\n</code></pre> <p>Add a surface species.</p>"},{"location":"api/analysis/#add_gas","title":"add_gas","text":"<pre><code>add_gas(name: str, pressure: float = 1.0)\n</code></pre> <p>Add a gas phase species with partial pressure.</p>"},{"location":"api/analysis/#add_reaction","title":"add_reaction","text":"<pre><code>add_reaction(\n    name: str,\n    reactants: Dict[str, int],\n    products: Dict[str, int],\n    Ea_fwd: float,\n    Ea_rev: float = None,\n    dG: float = None\n)\n</code></pre> <p>Add an elementary reaction.</p>"},{"location":"api/analysis/#solve_steady_state","title":"solve_steady_state","text":"<pre><code>solve_steady_state() -&gt; Dict[str, float]\n</code></pre> <p>Solve for steady-state coverages.</p>"},{"location":"api/analysis/#get_tof","title":"get_tof","text":"<pre><code>get_tof(\n    product_reaction: str = None,\n    coverages: Dict[str, float] = None\n) -&gt; float\n</code></pre> <p>Calculate turnover frequency.</p> <p>Example:</p> <pre><code>model = MicroKineticModel(temperature=673)\n\n# Add species\nmodel.add_species(\"*\", is_site=True)\nmodel.add_species(\"NH3*\")\nmodel.add_species(\"NH2*\")\nmodel.add_species(\"H*\")\n\n# Add gas\nmodel.add_gas(\"NH3(g)\", pressure=0.1)\nmodel.add_gas(\"H2(g)\", pressure=0.01)\n\n# Add reactions\nmodel.add_reaction(\n    \"NH3_ads\",\n    reactants={\"NH3(g)\": 1, \"*\": 1},\n    products={\"NH3*\": 1},\n    Ea_fwd=0.0,\n    dG=-0.5\n)\n\n# Solve\ncoverages = model.solve_steady_state()\ntof = model.get_tof()\n\nprint(f\"TOF: {tof:.4e} s^-1\")\n</code></pre>"},{"location":"api/analysis/#nh3decompositionmodel","title":"NH3DecompositionModel","text":"<p>Pre-built microkinetic model for NH3 decomposition.</p> <pre><code>from nh3sofc.analysis import NH3DecompositionModel\n</code></pre>"},{"location":"api/analysis/#constructor_8","title":"Constructor","text":"<pre><code>NH3DecompositionModel(\n    temperature: float = 673.0,\n    barriers: Dict[str, float] = None,\n    reaction_energies: Dict[str, float] = None\n)\n</code></pre> <p>Default barriers: NH3_ads=0.0, NH3_NH2=1.2, NH2_NH=1.0, NH_N=0.8, N_N2=1.5, H_H2=0.6 eV</p> <p>Example:</p> <pre><code># With custom barriers from DFT\nbarriers = {\n    \"NH3_ads\": 0.0,\n    \"NH3_NH2\": 1.0,  # From NEB\n    \"NH2_NH\": 0.9,\n    \"NH_N\": 0.7,\n    \"N_N2\": 1.3,\n    \"H_H2\": 0.5\n}\n\nmodel = NH3DecompositionModel(temperature=673, barriers=barriers)\ntof = model.get_tof()\nprint(f\"TOF: {tof:.4e} s^-1\")\n</code></pre>"},{"location":"api/analysis/#convenience-functions_1","title":"Convenience Functions","text":""},{"location":"api/analysis/#calculate_adsorption_energy","title":"calculate_adsorption_energy","text":"<pre><code>calculate_adsorption_energy(\n    e_adsorbate_surface: float,\n    e_surface: float,\n    e_adsorbate_gas: float\n) -&gt; float\n</code></pre>"},{"location":"api/analysis/#calculate_zpe","title":"calculate_zpe","text":"<pre><code>calculate_zpe(frequencies: List[float]) -&gt; float\n</code></pre>"},{"location":"api/analysis/#find_thermodynamic_rds","title":"find_thermodynamic_rds","text":"<pre><code>find_thermodynamic_rds(pathway: Dict[str, float]) -&gt; Tuple[str, float]\n</code></pre>"},{"location":"api/analysis/#estimate_barrier_bep","title":"estimate_barrier_bep","text":"<pre><code>estimate_barrier_bep(\n    reaction_energy: float,\n    reaction_type: str = \"default\"\n) -&gt; float\n</code></pre>"},{"location":"api/analysis/#calculate_rate_constant","title":"calculate_rate_constant","text":"<pre><code>calculate_rate_constant(\n    barrier: float,\n    temperature: float,\n    prefactor: float = 1e13\n) -&gt; float\n</code></pre>"},{"location":"api/analysis/#calculate_tof","title":"calculate_tof","text":"<pre><code>calculate_tof(\n    barriers: Dict[str, float],\n    reaction_energies: Dict[str, float],\n    temperature: float = 673.0\n) -&gt; float\n</code></pre>"},{"location":"api/analysis/#exsolutionenergetics","title":"ExsolutionEnergetics","text":"<p>Analyze energetics of exsolution processes.</p> <pre><code>from nh3sofc.analysis import ExsolutionEnergetics\n</code></pre>"},{"location":"api/analysis/#constructor_9","title":"Constructor","text":"<pre><code>ExsolutionEnergetics(\n    metal: str = \"Ni\",\n    temperature: float = 873.0,\n    p_o2: float = 1e-20\n)\n</code></pre> <p>Parameters:</p> Name Type Default Description <code>metal</code> <code>str</code> <code>\"Ni\"</code> Exsolution metal <code>temperature</code> <code>float</code> <code>873.0</code> Temperature (K) <code>p_o2</code> <code>float</code> <code>1e-20</code> O2 partial pressure (atm)"},{"location":"api/analysis/#methods_8","title":"Methods","text":""},{"location":"api/analysis/#set_reference_energies","title":"set_reference_energies","text":"<pre><code>set_reference_energies(\n    e_pristine: float = None,\n    e_bulk_metal_per_atom: float = None,\n    e_o2: float = None\n)\n</code></pre> <p>Set reference energies for calculations.</p>"},{"location":"api/analysis/#add_stage","title":"add_stage","text":"<pre><code>add_stage(\n    stage: str,\n    energy: float,\n    n_particle_atoms: int = 0,\n    n_o_vacancies: int = 0\n)\n</code></pre> <p>Add energy for a calculation stage.</p>"},{"location":"api/analysis/#get_oxygen_chemical_potential","title":"get_oxygen_chemical_potential","text":"<pre><code>get_oxygen_chemical_potential(\n    temperature: float = None,\n    p_o2: float = None\n) -&gt; float\n</code></pre> <p>Calculate \u03bc_O(T, p) = 0.5 * [E(O\u2082) + \u03bc\u00b0(T) + kT*ln(p/p\u00b0)]</p>"},{"location":"api/analysis/#calculate_vacancy_formation_energy","title":"calculate_vacancy_formation_energy","text":"<pre><code>calculate_vacancy_formation_energy(\n    e_defective: float = None,\n    e_pristine: float = None,\n    n_vacancies: int = 1,\n    include_chemical_potential: bool = True\n) -&gt; float\n</code></pre> <p>E_vac = [E(defective) - E(pristine) + n * \u03bc_O] / n</p>"},{"location":"api/analysis/#calculate_segregation_energy","title":"calculate_segregation_energy","text":"<pre><code>calculate_segregation_energy(\n    e_segregated: float = None,\n    e_bulk_distributed: float = None\n) -&gt; float\n</code></pre> <p>E_seg = E(surface_segregated) - E(bulk_distributed)</p>"},{"location":"api/analysis/#calculate_exsolution_energy","title":"calculate_exsolution_energy","text":"<pre><code>calculate_exsolution_energy(\n    e_exsolved: float = None,\n    e_substrate: float = None,\n    n_atoms: int = None,\n    e_bulk_metal: float = None,\n    include_vacancy_correction: bool = True\n) -&gt; float\n</code></pre> <p>Calculate exsolution driving force.</p>"},{"location":"api/analysis/#calculate_particle_binding_energy","title":"calculate_particle_binding_energy","text":"<pre><code>calculate_particle_binding_energy(\n    e_system: float,\n    e_surface: float,\n    e_isolated_particle: float\n) -&gt; float\n</code></pre> <p>E_bind = E(particle/surface) - E(surface) - E(isolated_particle)</p>"},{"location":"api/analysis/#get_exsolution_driving_force","title":"get_exsolution_driving_force","text":"<pre><code>get_exsolution_driving_force(\n    temperature: float = None,\n    p_o2: float = None\n) -&gt; Dict[str, float]\n</code></pre> <p>Calculate T and p dependent driving force.</p> <p>Returns:</p> <pre><code>{\n    \"delta_G\": float,\n    \"delta_E\": float,\n    \"vacancy_term\": float,\n    \"entropy_term\": float,\n    \"mu_O\": float,\n    \"favorable\": bool\n}\n</code></pre>"},{"location":"api/analysis/#compare_with_clean_surface","title":"compare_with_clean_surface","text":"<pre><code>compare_with_clean_surface(\n    exsolved_energies: Dict[str, float],\n    clean_surface_energies: Dict[str, float]\n) -&gt; Dict[str, Any]\n</code></pre> <p>Compare catalytic activity of exsolved vs clean surface.</p>"},{"location":"api/analysis/#print_summary","title":"print_summary","text":"<pre><code>print_summary()\n</code></pre> <p>Print formatted energetics summary.</p> <p>Example:</p> <pre><code>energetics = ExsolutionEnergetics(metal=\"Ni\", temperature=873)\n\n# Set references\nenergetics.set_reference_energies(e_pristine=-250.0)\n\n# Add calculation results\nenergetics.add_stage(\"pristine\", -250.0)\nenergetics.add_stage(\"defective\", -235.0, n_o_vacancies=4)\nenergetics.add_stage(\"exsolved\", -265.0, n_particle_atoms=13, n_o_vacancies=4)\n\n# Calculate\nresult = energetics.get_exsolution_driving_force()\nprint(f\"\u0394G_exsolution = {result['delta_G']:.2f} eV\")\nprint(f\"Favorable: {result['favorable']}\")\n\nenergetics.print_summary()\n</code></pre>"},{"location":"api/analysis/#calculate_exsolution_driving_force","title":"calculate_exsolution_driving_force","text":"<p>Convenience function for quick calculation.</p> <pre><code>from nh3sofc.analysis import calculate_exsolution_driving_force\n\nresult = calculate_exsolution_driving_force(\n    e_pristine=-250.0,\n    e_exsolved=-265.0,\n    n_particle_atoms=13,\n    metal=\"Ni\",\n    n_o_vacancies=4,\n    temperature=873.0,\n    p_o2=1e-20\n)\nprint(f\"\u0394G = {result['delta_G']:.2f} eV\")\n</code></pre>"},{"location":"api/calculators/","title":"Calculators Module","text":"<p>The <code>nh3sofc.calculators</code> module provides interfaces for VASP DFT and MACE ML force field calculations.</p>"},{"location":"api/calculators/#vasp-calculators","title":"VASP Calculators","text":""},{"location":"api/calculators/#vaspinputgenerator","title":"VASPInputGenerator","text":"<p>Generate VASP input files (INCAR, KPOINTS, POSCAR, POTCAR).</p> <pre><code>from nh3sofc.calculators.vasp import VASPInputGenerator\n</code></pre>"},{"location":"api/calculators/#constructor","title":"Constructor","text":"<pre><code>VASPInputGenerator(\n    atoms: Atoms,\n    calc_type: str = \"relax\",\n    work_dir: str = \".\",\n    potcar_dir: str = None\n)\n</code></pre> <p>Parameters:</p> Name Type Default Description <code>atoms</code> <code>Atoms</code> - ASE Atoms object <code>calc_type</code> <code>str</code> <code>\"relax\"</code> Calculation type <code>work_dir</code> <code>str</code> <code>\".\"</code> Working directory <code>potcar_dir</code> <code>str</code> <code>None</code> POTCAR directory (uses VASP_PP_PATH env) <p>Calculation Types:</p> Type Description Key Settings <code>\"relax\"</code> Geometry optimization IBRION=2, NSW=300 <code>\"static\"</code> Single-point energy NSW=0 <code>\"frequency\"</code> Vibrational analysis IBRION=5, NFREE=2 <code>\"neb\"</code> NEB transition state IMAGES, LCLIMB <code>\"md\"</code> Molecular dynamics IBRION=0, SMASS"},{"location":"api/calculators/#methods","title":"Methods","text":""},{"location":"api/calculators/#generate_all","title":"generate_all","text":"<pre><code>generate_all(\n    encut: float = 520,\n    ediff: float = 1e-6,\n    ediffg: float = -0.02,\n    kspacing: float = 0.03,\n    hubbard_u: dict = None,\n    vdw: str = None,\n    **kwargs\n) -&gt; dict\n</code></pre> <p>Generate all VASP input files.</p> <p>Parameters:</p> Name Type Default Description <code>encut</code> <code>float</code> <code>520</code> Plane-wave cutoff (eV) <code>ediff</code> <code>float</code> <code>1e-6</code> Electronic convergence <code>ediffg</code> <code>float</code> <code>-0.02</code> Ionic convergence (eV/\u00c5) <code>kspacing</code> <code>float</code> <code>0.03</code> K-point spacing (1/\u00c5) <code>hubbard_u</code> <code>dict</code> <code>None</code> Hubbard U values, e.g., <code>{\"V\": 3.25}</code> <code>vdw</code> <code>str</code> <code>None</code> vdW correction: \"D3\", \"D3BJ\", \"dDsC\" <p>Returns: Dictionary with paths to generated files.</p> <p>Example:</p> <pre><code>from ase.io import read\nfrom nh3sofc.calculators.vasp import VASPInputGenerator\n\natoms = read(\"structure.xyz\")\n\nvasp = VASPInputGenerator(atoms, calc_type=\"relax\", work_dir=\"./calc\")\nfiles = vasp.generate_all(\n    encut=520,\n    kspacing=0.03,\n    hubbard_u={\"V\": 3.25, \"Ti\": 3.0},\n    vdw=\"D3BJ\",\n    ispin=2,\n    lorbit=11,\n)\n\nprint(f\"Generated: {list(files.keys())}\")\n</code></pre>"},{"location":"api/calculators/#generate_incar","title":"generate_incar","text":"<pre><code>generate_incar(**kwargs) -&gt; str\n</code></pre> <p>Generate INCAR file content.</p>"},{"location":"api/calculators/#generate_kpoints","title":"generate_kpoints","text":"<pre><code>generate_kpoints(kspacing: float = 0.03) -&gt; str\n</code></pre> <p>Generate KPOINTS file content.</p>"},{"location":"api/calculators/#generate_potcar","title":"generate_potcar","text":"<pre><code>generate_potcar() -&gt; str\n</code></pre> <p>Generate POTCAR by concatenating pseudopotentials.</p>"},{"location":"api/calculators/#vaspoutputparser","title":"VASPOutputParser","text":"<p>Parse VASP output files.</p> <pre><code>from nh3sofc.calculators.vasp import VASPOutputParser\n</code></pre>"},{"location":"api/calculators/#constructor_1","title":"Constructor","text":"<pre><code>VASPOutputParser(work_dir: str = \".\")\n</code></pre>"},{"location":"api/calculators/#methods_1","title":"Methods","text":""},{"location":"api/calculators/#parse_outcar","title":"parse_outcar","text":"<pre><code>parse_outcar() -&gt; dict\n</code></pre> <p>Parse OUTCAR for energy, forces, stress.</p> <p>Returns:</p> <pre><code>{\n    \"energy\": float,           # Total energy (eV)\n    \"forces\": np.ndarray,      # Forces (eV/\u00c5)\n    \"stress\": np.ndarray,      # Stress tensor (kBar)\n    \"converged\": bool,         # Electronic convergence\n    \"ionic_steps\": int,        # Number of ionic steps\n    \"magmom\": float,           # Total magnetic moment\n}\n</code></pre>"},{"location":"api/calculators/#parse_vasprun","title":"parse_vasprun","text":"<pre><code>parse_vasprun() -&gt; dict\n</code></pre> <p>Parse vasprun.xml for detailed results.</p>"},{"location":"api/calculators/#get_trajectory","title":"get_trajectory","text":"<pre><code>get_trajectory() -&gt; List[Atoms]\n</code></pre> <p>Extract trajectory from OUTCAR.</p>"},{"location":"api/calculators/#check_convergence","title":"check_convergence","text":"<pre><code>check_convergence() -&gt; dict\n</code></pre> <p>Check electronic and ionic convergence.</p> <p>Example:</p> <pre><code>parser = VASPOutputParser(\"./calc\")\n\nresults = parser.parse_outcar()\nprint(f\"Energy: {results['energy']:.4f} eV\")\nprint(f\"Converged: {results['converged']}\")\n\n# Get relaxation trajectory\ntraj = parser.get_trajectory()\nprint(f\"Ionic steps: {len(traj)}\")\n</code></pre>"},{"location":"api/calculators/#frequencycalculation","title":"FrequencyCalculation","text":"<p>Set up and parse vibrational frequency calculations.</p> <pre><code>from nh3sofc.calculators.vasp import FrequencyCalculation\n</code></pre>"},{"location":"api/calculators/#constructor_2","title":"Constructor","text":"<pre><code>FrequencyCalculation(\n    atoms: Atoms,\n    work_dir: str = \".\",\n    selective_dynamics: List[int] = None\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>atoms</code> <code>Atoms</code> Optimized structure <code>work_dir</code> <code>str</code> Working directory <code>selective_dynamics</code> <code>List[int]</code> Indices of atoms to vibrate"},{"location":"api/calculators/#methods_2","title":"Methods","text":""},{"location":"api/calculators/#setup","title":"setup","text":"<pre><code>setup(\n    nfree: int = 2,\n    potim: float = 0.015,\n    **vasp_kwargs\n) -&gt; dict\n</code></pre> <p>Set up frequency calculation.</p>"},{"location":"api/calculators/#parse_frequencies","title":"parse_frequencies","text":"<pre><code>parse_frequencies() -&gt; dict\n</code></pre> <p>Parse frequencies from OUTCAR.</p> <p>Returns:</p> <pre><code>{\n    \"frequencies\": List[float],      # All frequencies (cm^-1)\n    \"real_frequencies\": List[float], # Real frequencies\n    \"imaginary\": List[float],        # Imaginary frequencies\n    \"zpe\": float,                    # Zero-point energy (eV)\n}\n</code></pre> <p>Example:</p> <pre><code># After geometry optimization\nfreq = FrequencyCalculation(\n    optimized_atoms,\n    work_dir=\"./freq\",\n    selective_dynamics=adsorbate_indices  # Only adsorbate atoms\n)\n\nfreq.setup(nfree=2, encut=520)\n\n# After VASP calculation completes...\nresults = freq.parse_frequencies()\nprint(f\"ZPE: {results['zpe']:.4f} eV\")\nprint(f\"Frequencies: {results['real_frequencies']}\")\n\nif results['imaginary']:\n    print(f\"WARNING: Imaginary frequencies found: {results['imaginary']}\")\n</code></pre>"},{"location":"api/calculators/#mace-calculators","title":"MACE Calculators","text":""},{"location":"api/calculators/#macecalculatorwrapper","title":"MACECalculatorWrapper","text":"<p>Wrapper for MACE ML force field calculator.</p> <pre><code>from nh3sofc.calculators.mace import MACECalculatorWrapper\n</code></pre>"},{"location":"api/calculators/#constructor_3","title":"Constructor","text":"<pre><code>MACECalculatorWrapper(\n    model_path: str = None,\n    foundation_model: str = \"medium\",\n    device: str = \"auto\",\n    default_dtype: str = \"float64\"\n)\n</code></pre> <p>Parameters:</p> Name Type Default Description <code>model_path</code> <code>str</code> <code>None</code> Path to custom MACE model <code>foundation_model</code> <code>str</code> <code>\"medium\"</code> Foundation model: \"small\", \"medium\", \"large\" <code>device</code> <code>str</code> <code>\"auto\"</code> Device: \"cpu\", \"cuda\", \"auto\" <code>default_dtype</code> <code>str</code> <code>\"float64\"</code> Numerical precision"},{"location":"api/calculators/#methods_3","title":"Methods","text":""},{"location":"api/calculators/#get_calculator","title":"get_calculator","text":"<pre><code>get_calculator() -&gt; Calculator\n</code></pre> <p>Get ASE calculator instance.</p>"},{"location":"api/calculators/#calculate","title":"calculate","text":"<pre><code>calculate(atoms: Atoms) -&gt; dict\n</code></pre> <p>Calculate energy, forces, stress.</p> <p>Example:</p> <pre><code>from nh3sofc.calculators.mace import MACECalculatorWrapper\n\n# Using foundation model\nmace = MACECalculatorWrapper(foundation_model=\"medium\")\n\n# Or custom trained model\nmace = MACECalculatorWrapper(model_path=\"./my_model.model\")\n\n# Attach to atoms\ncalc = mace.get_calculator()\natoms.calc = calc\n\nenergy = atoms.get_potential_energy()\nforces = atoms.get_forces()\n</code></pre>"},{"location":"api/calculators/#maceensemble","title":"MACEEnsemble","text":"<p>Ensemble of MACE models for uncertainty estimation.</p> <pre><code>from nh3sofc.calculators.mace import MACEEnsemble\n</code></pre>"},{"location":"api/calculators/#constructor_4","title":"Constructor","text":"<pre><code>MACEEnsemble(\n    model_paths: List[str],\n    device: str = \"auto\"\n)\n</code></pre>"},{"location":"api/calculators/#methods_4","title":"Methods","text":""},{"location":"api/calculators/#calculate_with_uncertainty","title":"calculate_with_uncertainty","text":"<pre><code>calculate_with_uncertainty(atoms: Atoms) -&gt; dict\n</code></pre> <p>Calculate with uncertainty estimates.</p> <p>Returns:</p> <pre><code>{\n    \"energy\": float,\n    \"energy_std\": float,\n    \"forces\": np.ndarray,\n    \"forces_std\": np.ndarray,\n    \"max_force_std\": float,\n}\n</code></pre> <p>Example:</p> <pre><code>ensemble = MACEEnsemble([\n    \"./model_1.model\",\n    \"./model_2.model\",\n    \"./model_3.model\",\n])\n\nresults = ensemble.calculate_with_uncertainty(atoms)\nprint(f\"Energy: {results['energy']:.4f} \u00b1 {results['energy_std']:.4f} eV\")\n\nif results['max_force_std'] &gt; 0.1:\n    print(\"High uncertainty - consider adding to training data\")\n</code></pre>"},{"location":"api/calculators/#trainingdataextractor","title":"TrainingDataExtractor","text":"<p>Extract training data from VASP calculations.</p> <pre><code>from nh3sofc.calculators.mace import TrainingDataExtractor\n</code></pre>"},{"location":"api/calculators/#constructor_5","title":"Constructor","text":"<pre><code>TrainingDataExtractor(vasp_dirs: List[str] = None)\n</code></pre>"},{"location":"api/calculators/#methods_5","title":"Methods","text":""},{"location":"api/calculators/#extract_from_directory","title":"extract_from_directory","text":"<pre><code>extract_from_directory(\n    vasp_dir: str,\n    include_trajectory: bool = True\n) -&gt; List[Atoms]\n</code></pre> <p>Extract structures with energies and forces.</p>"},{"location":"api/calculators/#extract_all","title":"extract_all","text":"<pre><code>extract_all() -&gt; List[Atoms]\n</code></pre> <p>Extract from all directories.</p>"},{"location":"api/calculators/#write_xyz","title":"write_xyz","text":"<pre><code>write_xyz(\n    filename: str,\n    atoms_list: List[Atoms] = None\n)\n</code></pre> <p>Write training data to extended XYZ format.</p>"},{"location":"api/calculators/#filter_by_energy","title":"filter_by_energy","text":"<pre><code>filter_by_energy(\n    atoms_list: List[Atoms],\n    max_energy_per_atom: float = 0.0\n) -&gt; List[Atoms]\n</code></pre> <p>Filter high-energy configurations.</p> <p>Example:</p> <pre><code>extractor = TrainingDataExtractor()\n\n# Extract from multiple calculations\nfor calc_dir in glob(\"./calculations/*/\"):\n    extractor.extract_from_directory(calc_dir)\n\n# Get all training data\ntraining_data = extractor.extract_all()\nprint(f\"Extracted {len(training_data)} configurations\")\n\n# Filter and save\nfiltered = extractor.filter_by_energy(training_data, max_energy_per_atom=-2.0)\nextractor.write_xyz(\"training_data.xyz\", filtered)\n</code></pre>"},{"location":"api/calculators/#macetrainingconfig","title":"MACETrainingConfig","text":"<p>Generate MACE training configuration.</p> <pre><code>from nh3sofc.calculators.mace import MACETrainingConfig\n</code></pre>"},{"location":"api/calculators/#constructor_6","title":"Constructor","text":"<pre><code>MACETrainingConfig(\n    train_file: str,\n    valid_file: str = None,\n    model_name: str = \"MACE_model\"\n)\n</code></pre>"},{"location":"api/calculators/#methods_6","title":"Methods","text":""},{"location":"api/calculators/#generate_config","title":"generate_config","text":"<pre><code>generate_config(\n    r_max: float = 5.0,\n    num_radial_basis: int = 8,\n    num_cutoff_basis: int = 5,\n    max_L: int = 2,\n    num_channels: int = 128,\n    max_epochs: int = 1000,\n    batch_size: int = 10,\n    **kwargs\n) -&gt; dict\n</code></pre> <p>Generate training configuration dictionary.</p>"},{"location":"api/calculators/#write_config","title":"write_config","text":"<pre><code>write_config(filename: str)\n</code></pre> <p>Write configuration to YAML file.</p>"},{"location":"api/calculators/#generate_training_script","title":"generate_training_script","text":"<pre><code>generate_training_script(filename: str = \"train.sh\")\n</code></pre> <p>Generate shell script for training.</p> <p>Example:</p> <pre><code>config = MACETrainingConfig(\n    train_file=\"train.xyz\",\n    valid_file=\"valid.xyz\",\n    model_name=\"LaVON_MACE\"\n)\n\nconfig.generate_config(\n    r_max=6.0,\n    max_epochs=500,\n    batch_size=5,\n)\n\nconfig.write_config(\"mace_config.yaml\")\nconfig.generate_training_script(\"train_mace.sh\")\n</code></pre>"},{"location":"api/calculators/#preset-parameters","title":"Preset Parameters","text":""},{"location":"api/calculators/#vasp-presets","title":"VASP Presets","text":"<pre><code>from nh3sofc.calculators.vasp import get_preset\n\n# Available presets\npreset = get_preset(\"relax\")      # Geometry optimization\npreset = get_preset(\"static\")     # Single-point\npreset = get_preset(\"frequency\")  # Vibrational analysis\npreset = get_preset(\"neb\")        # NEB calculation\npreset = get_preset(\"md\")         # Molecular dynamics\n</code></pre>"},{"location":"api/calculators/#default-hubbard-u-values","title":"Default Hubbard U Values","text":"<pre><code>from nh3sofc.core.constants import HUBBARD_U\n\n# Default values (eV)\nHUBBARD_U = {\n    \"V\": 3.25,\n    \"Ti\": 3.0,\n    \"Mn\": 3.9,\n    \"Fe\": 4.0,\n    \"Co\": 3.3,\n    \"Ni\": 6.4,\n}\n</code></pre>"},{"location":"api/core/","title":"Core Module","text":"<p>The <code>nh3sofc.core</code> module provides fundamental constants, parameters, and base classes.</p>"},{"location":"api/core/#constants","title":"Constants","text":"<p>Physical and chemical constants used throughout the package.</p> <pre><code>from nh3sofc.core.constants import *\n</code></pre>"},{"location":"api/core/#physical-constants","title":"Physical Constants","text":"Constant Value Unit Description <code>KB_EV</code> 8.617333262e-5 eV/K Boltzmann constant <code>H_EV_S</code> 4.135667696e-15 eV\u00b7s Planck constant <code>C_CMS</code> 2.99792458e10 cm/s Speed of light <code>EV_TO_J</code> 1.602176634e-19 J/eV Energy conversion <code>EV_TO_KJ_MOL</code> 96.485 kJ/mol/eV Energy conversion <code>AMU_TO_KG</code> 1.66054e-27 kg/amu Mass conversion <p>Example:</p> <pre><code>from nh3sofc.core.constants import KB_EV, H_EV_S\n\n# Calculate rate constant at 673 K\nT = 673  # K\nbarrier = 1.0  # eV\nprefactor = KB_EV * T / H_EV_S\nk = prefactor * np.exp(-barrier / (KB_EV * T))\n</code></pre>"},{"location":"api/core/#default-vasp-parameters","title":"Default VASP Parameters","text":"<pre><code>from nh3sofc.core.constants import DEFAULT_VASP_PARAMS\n\n# Default settings\nDEFAULT_VASP_PARAMS = {\n    \"encut\": 520,\n    \"ediff\": 1e-6,\n    \"ediffg\": -0.02,\n    \"ismear\": 0,\n    \"sigma\": 0.05,\n    \"kspacing\": 0.03,\n    \"ispin\": 2,\n    \"lorbit\": 11,\n    \"ncore\": 4,\n    \"lreal\": \"Auto\",\n    \"algo\": \"Normal\",\n    \"prec\": \"Accurate\",\n}\n</code></pre>"},{"location":"api/core/#hubbard-u-values","title":"Hubbard U Values","text":"<pre><code>from nh3sofc.core.constants import HUBBARD_U\n\n# Default Hubbard U values (eV)\nHUBBARD_U = {\n    \"V\": 3.25,\n    \"Ti\": 3.0,\n    \"Mn\": 3.9,\n    \"Fe\": 4.0,\n    \"Co\": 3.3,\n    \"Ni\": 6.4,\n    \"Cr\": 3.5,\n    \"Cu\": 4.0,\n}\n</code></pre>"},{"location":"api/core/#gas-phase-reference-energies","title":"Gas Phase Reference Energies","text":"<pre><code>from nh3sofc.core.constants import GAS_PHASE_ENERGIES\n\n# Reference energies (eV) - update with your calculated values\nGAS_PHASE_ENERGIES = {\n    \"NH3\": -19.54,\n    \"N2\": -16.64,\n    \"H2\": -6.77,\n    \"H2O\": -14.22,\n    \"O2\": -9.86,\n}\n</code></pre>"},{"location":"api/core/#element-properties","title":"Element Properties","text":"<pre><code>from nh3sofc.core.constants import ELEMENT_MASSES, ATOMIC_RADII\n\n# Masses in amu\nELEMENT_MASSES = {\n    \"H\": 1.008,\n    \"N\": 14.007,\n    \"O\": 15.999,\n    \"La\": 138.905,\n    \"V\": 50.942,\n    # ... more elements\n}\n\n# Covalent radii in \u00c5\nATOMIC_RADII = {\n    \"H\": 0.31,\n    \"N\": 0.71,\n    \"O\": 0.66,\n    # ... more elements\n}\n</code></pre>"},{"location":"api/core/#base-classes","title":"Base Classes","text":"<p>Abstract base classes for structures and workflows.</p>"},{"location":"api/core/#basestructure","title":"BaseStructure","text":"<p>Base class for structure objects.</p> <pre><code>from nh3sofc.core.base import BaseStructure\n</code></pre> <pre><code>class BaseStructure:\n    \"\"\"Base class for structure manipulation.\"\"\"\n\n    def __init__(self, atoms: Atoms):\n        self.atoms = atoms\n\n    def copy(self) -&gt; 'BaseStructure':\n        \"\"\"Return a deep copy.\"\"\"\n        ...\n\n    def write(self, filename: str, format: str = None):\n        \"\"\"Write structure to file.\"\"\"\n        ...\n\n    def get_composition(self) -&gt; Dict[str, int]:\n        \"\"\"Get element counts.\"\"\"\n        ...\n\n    def get_center_of_mass(self) -&gt; np.ndarray:\n        \"\"\"Get center of mass.\"\"\"\n        ...\n</code></pre>"},{"location":"api/core/#baseworkflow","title":"BaseWorkflow","text":"<p>Base class for workflow objects.</p> <pre><code>from nh3sofc.core.base import BaseWorkflow\n</code></pre> <pre><code>class BaseWorkflow:\n    \"\"\"Base class for calculation workflows.\"\"\"\n\n    def __init__(self, work_dir: str = \".\"):\n        self.work_dir = Path(work_dir)\n        self.work_dir.mkdir(parents=True, exist_ok=True)\n\n    def setup(self) -&gt; dict:\n        \"\"\"Set up calculation. Override in subclass.\"\"\"\n        raise NotImplementedError\n\n    def run(self) -&gt; Any:\n        \"\"\"Run calculation. Override in subclass.\"\"\"\n        raise NotImplementedError\n\n    def parse_results(self) -&gt; dict:\n        \"\"\"Parse results. Override in subclass.\"\"\"\n        raise NotImplementedError\n\n    def get_status(self) -&gt; str:\n        \"\"\"Check calculation status.\"\"\"\n        ...\n</code></pre>"},{"location":"api/core/#baseanalyzer","title":"BaseAnalyzer","text":"<p>Base class for analysis objects.</p> <pre><code>from nh3sofc.core.base import BaseAnalyzer\n</code></pre> <pre><code>class BaseAnalyzer:\n    \"\"\"Base class for result analysis.\"\"\"\n\n    def __init__(self):\n        self.results = {}\n\n    def analyze(self, data: Any) -&gt; dict:\n        \"\"\"Perform analysis. Override in subclass.\"\"\"\n        raise NotImplementedError\n\n    def plot(self, filename: str = None):\n        \"\"\"Generate plot. Override in subclass.\"\"\"\n        raise NotImplementedError\n\n    def to_dataframe(self) -&gt; pd.DataFrame:\n        \"\"\"Convert results to DataFrame.\"\"\"\n        ...\n</code></pre>"},{"location":"api/core/#utility-functions","title":"Utility Functions","text":""},{"location":"api/core/#energy-conversions","title":"Energy Conversions","text":"<pre><code>from nh3sofc.core.utils import ev_to_kj_mol, kj_mol_to_ev, ev_to_kcal_mol\n\nenergy_ev = 1.0\nenergy_kj = ev_to_kj_mol(energy_ev)   # 96.485 kJ/mol\nenergy_kcal = ev_to_kcal_mol(energy_ev)  # 23.06 kcal/mol\n</code></pre>"},{"location":"api/core/#temperaturefrequency-conversions","title":"Temperature/Frequency Conversions","text":"<pre><code>from nh3sofc.core.utils import cm_to_ev, ev_to_cm, kelvin_to_ev\n\nfreq_cm = 3400  # cm^-1\nfreq_ev = cm_to_ev(freq_cm)  # ~0.42 eV\n\nT = 673  # K\nkT = kelvin_to_ev(T)  # ~0.058 eV\n</code></pre>"},{"location":"api/core/#structure-utilities","title":"Structure Utilities","text":"<pre><code>from nh3sofc.core.utils import (\n    get_surface_atoms,\n    get_subsurface_atoms,\n    get_adsorbate_indices,\n    calculate_rmsd,\n)\n\n# Find surface atoms (top layer)\nsurface_indices = get_surface_atoms(slab, tolerance=0.5)\n\n# Get adsorbate atom indices\nads_indices = get_adsorbate_indices(slab_with_adsorbate, slab)\n\n# Calculate RMSD between structures\nrmsd = calculate_rmsd(atoms1, atoms2)\n</code></pre>"},{"location":"api/core/#configuration","title":"Configuration","text":""},{"location":"api/core/#package-configuration","title":"Package Configuration","text":"<pre><code>from nh3sofc.core.config import Config\n\n# Get configuration\nconfig = Config()\n\n# Access settings\nvasp_pp_path = config.get(\"vasp_pp_path\")\ndefault_calculator = config.get(\"default_calculator\", \"vasp\")\n\n# Set configuration\nconfig.set(\"vasp_pp_path\", \"/path/to/potentials\")\nconfig.save()\n</code></pre>"},{"location":"api/core/#configuration-file","title":"Configuration File","text":"<p>Create <code>~/.nh3sofc/config.yaml</code>:</p> <pre><code># VASP settings\nvasp_pp_path: /path/to/vasp/potentials\nvasp_command: mpirun vasp_std\n\n# MACE settings\nmace_model_path: /path/to/models\ndefault_foundation_model: medium\n\n# Job submission\njob_system: pbs\ndefault_nodes: 1\ndefault_ppn: 24\ndefault_walltime: \"24:00:00\"\n\n# Calculation defaults\ndefault_encut: 520\ndefault_kspacing: 0.03\nuse_vdw: true\nvdw_type: D3BJ\n</code></pre>"},{"location":"api/core/#environment-variables","title":"Environment Variables","text":"Variable Description <code>VASP_PP_PATH</code> Path to VASP pseudopotentials <code>NH3SOFC_CONFIG</code> Path to config file <code>NH3SOFC_DB</code> Default database path"},{"location":"api/core/#logging","title":"Logging","text":"<pre><code>from nh3sofc.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\nlogger.info(\"Starting calculation\")\nlogger.debug(\"Debug information\")\nlogger.warning(\"Warning message\")\nlogger.error(\"Error occurred\")\n</code></pre> <p>Configure logging level:</p> <pre><code>from nh3sofc.core.logging import set_log_level\n\nset_log_level(\"DEBUG\")  # or \"INFO\", \"WARNING\", \"ERROR\"\n</code></pre>"},{"location":"api/database/","title":"Database Module","text":"<p>The <code>nh3sofc.database</code> module provides tools for organizing calculations and storing results.</p>"},{"location":"api/database/#namingconvention","title":"NamingConvention","text":"<p>Standardized naming for files and directories.</p> <pre><code>from nh3sofc.database import NamingConvention\n</code></pre>"},{"location":"api/database/#constructor","title":"Constructor","text":"<pre><code>NamingConvention(\n    material: str,\n    miller: tuple = None,\n    termination: str = None,\n    calc_type: str = None,\n    suffix: str = None\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>material</code> <code>str</code> Material name (e.g., \"LaVO3\", \"LaVON2\") <code>miller</code> <code>tuple</code> Miller indices (h, k, l) <code>termination</code> <code>str</code> Surface termination (e.g., \"LaO\", \"VO2\") <code>calc_type</code> <code>str</code> Calculation type <code>suffix</code> <code>str</code> Additional suffix"},{"location":"api/database/#methods","title":"Methods","text":""},{"location":"api/database/#get_directory_name","title":"get_directory_name","text":"<pre><code>get_directory_name() -&gt; str\n</code></pre> <p>Generate standardized directory name.</p> <p>Format: <code>{material}_{miller}_{termination}_{calc_type}_{suffix}</code></p>"},{"location":"api/database/#get_filename","title":"get_filename","text":"<pre><code>get_filename(extension: str = \"\") -&gt; str\n</code></pre> <p>Generate standardized filename.</p>"},{"location":"api/database/#from_atoms","title":"from_atoms","text":"<pre><code>@classmethod\nfrom_atoms(atoms: Atoms, calc_type: str = None) -&gt; NamingConvention\n</code></pre> <p>Create from ASE Atoms object.</p> <p>Example:</p> <pre><code>from nh3sofc.database import NamingConvention\n\n# Manual creation\nnaming = NamingConvention(\n    material=\"LaVON2\",\n    miller=(0, 0, 1),\n    termination=\"LaO\",\n    calc_type=\"relax\",\n    suffix=\"vac0.10\"\n)\n\ndir_name = naming.get_directory_name()\n# \"LaVON2_001_LaO_relax_vac0.10\"\n\nfilename = naming.get_filename(\".traj\")\n# \"LaVON2_001_LaO_relax_vac0.10.traj\"\n\n# From atoms\nfrom ase.io import read\natoms = read(\"structure.xyz\")\nnaming = NamingConvention.from_atoms(atoms, calc_type=\"static\")\n</code></pre>"},{"location":"api/database/#naming-conventions","title":"Naming Conventions","text":"Component Format Examples Material Chemical formula LaVO3, LaVON2, SrTiO3 Miller 3-digit 001, 110, 111 Termination Element+O LaO, VO2, TiO2 Calc Type lowercase relax, static, neb, freq Suffix descriptive vac0.10, NH3, config001"},{"location":"api/database/#nh3sofcdatabase","title":"NH3SOFCDatabase","text":"<p>ASE database wrapper with NH3-SOFC-specific functionality.</p> <pre><code>from nh3sofc.database import NH3SOFCDatabase\n</code></pre>"},{"location":"api/database/#constructor_1","title":"Constructor","text":"<pre><code>NH3SOFCDatabase(\n    db_path: str = \"nh3sofc.db\",\n    create: bool = True\n)\n</code></pre> <p>Parameters:</p> Name Type Default Description <code>db_path</code> <code>str</code> <code>\"nh3sofc.db\"</code> Path to SQLite database <code>create</code> <code>bool</code> <code>True</code> Create if doesn't exist"},{"location":"api/database/#methods_1","title":"Methods","text":""},{"location":"api/database/#add_structure","title":"add_structure","text":"<pre><code>add_structure(\n    atoms: Atoms,\n    material: str = None,\n    miller: tuple = None,\n    termination: str = None,\n    calc_type: str = None,\n    energy: float = None,\n    adsorbate: str = None,\n    **kwargs\n) -&gt; int\n</code></pre> <p>Add structure to database.</p> <p>Returns: Row ID of added structure.</p> <p>Example:</p> <pre><code>db = NH3SOFCDatabase(\"my_calculations.db\")\n\nrow_id = db.add_structure(\n    atoms=optimized_atoms,\n    material=\"LaVON2\",\n    miller=(0, 0, 1),\n    termination=\"LaO\",\n    calc_type=\"relax\",\n    energy=-245.678,\n    adsorbate=\"NH3\",\n    vacancy_concentration=0.10,\n    nitrogen_fraction=0.67,\n)\nprint(f\"Added structure with ID: {row_id}\")\n</code></pre>"},{"location":"api/database/#get_structure","title":"get_structure","text":"<pre><code>get_structure(row_id: int) -&gt; Atoms\n</code></pre> <p>Retrieve structure by ID.</p>"},{"location":"api/database/#query","title":"query","text":"<pre><code>query(\n    material: str = None,\n    miller: tuple = None,\n    calc_type: str = None,\n    adsorbate: str = None,\n    **kwargs\n) -&gt; List[Atoms]\n</code></pre> <p>Query structures matching criteria.</p> <p>Example:</p> <pre><code># Find all NH3 adsorption calculations on LaVON2\nstructures = db.query(\n    material=\"LaVON2\",\n    adsorbate=\"NH3\",\n    calc_type=\"relax\"\n)\n\nprint(f\"Found {len(structures)} matching structures\")\n</code></pre>"},{"location":"api/database/#get_energies","title":"get_energies","text":"<pre><code>get_energies(\n    material: str = None,\n    miller: tuple = None,\n    **kwargs\n) -&gt; Dict[str, float]\n</code></pre> <p>Get energies for matching structures.</p>"},{"location":"api/database/#get_lowest_energy","title":"get_lowest_energy","text":"<pre><code>get_lowest_energy(\n    material: str = None,\n    adsorbate: str = None,\n    **kwargs\n) -&gt; Tuple[Atoms, float]\n</code></pre> <p>Get structure with lowest energy.</p> <p>Example:</p> <pre><code># Find most stable NH3 adsorption configuration\natoms, energy = db.get_lowest_energy(\n    material=\"LaVON2\",\n    adsorbate=\"NH3\"\n)\nprint(f\"Lowest energy: {energy:.4f} eV\")\n</code></pre>"},{"location":"api/database/#add_trajectory","title":"add_trajectory","text":"<pre><code>add_trajectory(\n    trajectory: List[Atoms],\n    base_name: str,\n    **common_kwargs\n) -&gt; List[int]\n</code></pre> <p>Add multiple structures from trajectory.</p>"},{"location":"api/database/#export_to_xyz","title":"export_to_xyz","text":"<pre><code>export_to_xyz(\n    filename: str,\n    query_kwargs: dict = None\n)\n</code></pre> <p>Export matching structures to XYZ file.</p>"},{"location":"api/database/#get_statistics","title":"get_statistics","text":"<pre><code>get_statistics() -&gt; dict\n</code></pre> <p>Get database statistics.</p> <p>Returns:</p> <pre><code>{\n    \"total_structures\": int,\n    \"by_material\": Dict[str, int],\n    \"by_calc_type\": Dict[str, int],\n    \"by_adsorbate\": Dict[str, int],\n}\n</code></pre> <p>Example:</p> <pre><code>stats = db.get_statistics()\nprint(f\"Total structures: {stats['total_structures']}\")\nprint(\"By material:\")\nfor mat, count in stats['by_material'].items():\n    print(f\"  {mat}: {count}\")\n</code></pre>"},{"location":"api/database/#database-schema","title":"Database Schema","text":"<p>The database stores structures with the following key-value pairs:</p> Key Type Description <code>material</code> <code>str</code> Material formula <code>miller</code> <code>str</code> Miller indices (e.g., \"m001\") <code>termination</code> <code>str</code> Surface termination <code>calc_type</code> <code>str</code> Calculation type <code>adsorbate</code> <code>str</code> Adsorbate molecule <code>vacancy_concentration</code> <code>float</code> Oxygen vacancy fraction <code>nitrogen_fraction</code> <code>float</code> N/(N+O) ratio <code>converged</code> <code>bool</code> Calculation converged <p>Additional custom keys can be stored as needed.</p>"},{"location":"api/database/#usage-examples","title":"Usage Examples","text":""},{"location":"api/database/#building-a-calculation-database","title":"Building a Calculation Database","text":"<pre><code>from nh3sofc.database import NH3SOFCDatabase, NamingConvention\nfrom nh3sofc.calculators.vasp import VASPOutputParser\nfrom glob import glob\n\ndb = NH3SOFCDatabase(\"project.db\")\n\n# Add results from completed calculations\nfor calc_dir in glob(\"./calculations/*/\"):\n    parser = VASPOutputParser(calc_dir)\n\n    if parser.check_convergence()[\"converged\"]:\n        results = parser.parse_outcar()\n        atoms = parser.get_final_structure()\n\n        # Extract metadata from directory name\n        naming = NamingConvention.from_directory(calc_dir)\n\n        db.add_structure(\n            atoms=atoms,\n            material=naming.material,\n            miller=naming.miller,\n            calc_type=naming.calc_type,\n            energy=results[\"energy\"],\n        )\n\nprint(f\"Database now contains {db.get_statistics()['total_structures']} structures\")\n</code></pre>"},{"location":"api/database/#comparing-surfaces","title":"Comparing Surfaces","text":"<pre><code>from nh3sofc.database import NH3SOFCDatabase\nfrom nh3sofc.analysis import SurfaceComparator\n\ndb = NH3SOFCDatabase(\"project.db\")\n\n# Get decomposition energies for different terminations\nsurfaces = {}\n\nfor term in [\"LaO\", \"VO2\"]:\n    energies = db.get_energies(\n        material=\"LaVON2\",\n        termination=term,\n    )\n\n    surfaces[term] = {\n        step: energies.get(f\"{term}_{step}\", 0.0)\n        for step in [\"NH3\", \"NH2_H\", \"NH_2H\", \"N_3H\"]\n    }\n\ncomparator = SurfaceComparator(surfaces)\nranking = comparator.rank_by_energy_span()\n</code></pre>"},{"location":"api/database/#exporting-for-machine-learning","title":"Exporting for Machine Learning","text":"<pre><code>db = NH3SOFCDatabase(\"project.db\")\n\n# Export all relaxed structures for ML training\ndb.export_to_xyz(\n    \"training_data.xyz\",\n    query_kwargs={\"calc_type\": \"relax\", \"converged\": True}\n)\n</code></pre>"},{"location":"api/database/#command-line-interface","title":"Command-Line Interface","text":"<pre><code># List database contents\nnh3sofc-db list project.db\n\n# Query specific structures\nnh3sofc-db query project.db --material LaVON2 --adsorbate NH3\n\n# Export to XYZ\nnh3sofc-db export project.db output.xyz --calc-type relax\n\n# Show statistics\nnh3sofc-db stats project.db\n</code></pre>"},{"location":"api/structure/","title":"Structure Module","text":"<p>The <code>nh3sofc.structure</code> module provides tools for building and manipulating atomic structures.</p>"},{"location":"api/structure/#bulkstructure","title":"BulkStructure","text":"<p>Load and manipulate bulk crystal structures.</p> <pre><code>from nh3sofc.structure import BulkStructure\n</code></pre>"},{"location":"api/structure/#constructor","title":"Constructor","text":"<pre><code>BulkStructure(atoms: Atoms)\n</code></pre> <p>Parameters:</p> Name Type Description <code>atoms</code> <code>Atoms</code> ASE Atoms object"},{"location":"api/structure/#class-methods","title":"Class Methods","text":""},{"location":"api/structure/#from_cif","title":"from_cif","text":"<pre><code>@classmethod\nBulkStructure.from_cif(\n    filepath: str,\n    primitive: bool = False\n) -&gt; BulkStructure\n</code></pre> <p>Load structure from CIF file.</p> <p>Parameters:</p> Name Type Default Description <code>filepath</code> <code>str</code> - Path to CIF file <code>primitive</code> <code>bool</code> <code>False</code> Convert to primitive cell <p>Example:</p> <pre><code>bulk = BulkStructure.from_cif(\"LaVO3.cif\")\nprint(f\"Formula: {bulk.atoms.get_chemical_formula()}\")\n</code></pre>"},{"location":"api/structure/#methods","title":"Methods","text":""},{"location":"api/structure/#make_supercell","title":"make_supercell","text":"<pre><code>make_supercell(size: tuple) -&gt; BulkStructure\n</code></pre> <p>Create supercell.</p> <p>Parameters:</p> Name Type Description <code>size</code> <code>tuple</code> Supercell size (nx, ny, nz) <p>Example:</p> <pre><code>supercell = bulk.make_supercell((2, 2, 2))\n</code></pre>"},{"location":"api/structure/#get_spacegroup","title":"get_spacegroup","text":"<pre><code>get_spacegroup(symprec: float = 1e-5) -&gt; str\n</code></pre> <p>Get space group symbol.</p>"},{"location":"api/structure/#surfacebuilder","title":"SurfaceBuilder","text":"<p>Create surface slabs from bulk structures.</p> <pre><code>from nh3sofc.structure import SurfaceBuilder\n</code></pre>"},{"location":"api/structure/#constructor_1","title":"Constructor","text":"<pre><code>SurfaceBuilder(bulk_structure: Union[BulkStructure, Atoms])\n</code></pre>"},{"location":"api/structure/#methods_1","title":"Methods","text":""},{"location":"api/structure/#create_surface","title":"create_surface","text":"<pre><code>create_surface(\n    miller_index: tuple,\n    layers: int = 6,\n    vacuum: float = 15.0,\n    fix_bottom: int = 0\n) -&gt; SlabStructure\n</code></pre> <p>Create surface slab.</p> <p>Parameters:</p> Name Type Default Description <code>miller_index</code> <code>tuple</code> - Miller indices (h, k, l) <code>layers</code> <code>int</code> <code>6</code> Number of atomic layers <code>vacuum</code> <code>float</code> <code>15.0</code> Vacuum thickness (\u00c5) <code>fix_bottom</code> <code>int</code> <code>0</code> Layers to fix at bottom <p>Example:</p> <pre><code>builder = SurfaceBuilder(bulk)\nsurface = builder.create_surface(\n    miller_index=(0, 0, 1),\n    layers=6,\n    vacuum=15.0,\n    fix_bottom=2\n)\n</code></pre>"},{"location":"api/structure/#get_all_terminations","title":"get_all_terminations","text":"<pre><code>get_all_terminations(miller_index: tuple) -&gt; List[Atoms]\n</code></pre> <p>Get all possible terminations for a surface.</p>"},{"location":"api/structure/#create_symmetric_slab","title":"create_symmetric_slab","text":"<pre><code>create_symmetric_slab(\n    miller_index: tuple,\n    layers: int = 7,\n    vacuum: float = 15.0,\n    fix_bottom: int = 2\n) -&gt; SlabStructure\n</code></pre> <p>Create symmetric slab with same termination on both surfaces (helps cancel dipole).</p>"},{"location":"api/structure/#slabstructure","title":"SlabStructure","text":"<p>Surface slab structure with polarity and layer analysis methods.</p> <pre><code>from nh3sofc.structure import SlabStructure\n</code></pre>"},{"location":"api/structure/#polarity-methods","title":"Polarity Methods","text":""},{"location":"api/structure/#check_polarity","title":"check_polarity","text":"<pre><code>check_polarity(\n    formal_charges: dict = None,\n    tolerance: float = 0.5\n) -&gt; dict\n</code></pre> <p>Check if surface is polar.</p> <p>Returns:</p> <pre><code>{\n    \"is_polar\": bool,\n    \"dipole_moment\": float,  # e\u00b7\u00c5\n    \"dipole_z\": float,       # z-component\n    \"top_layer_charge\": float,\n    \"bottom_layer_charge\": float,\n    \"layer_charges\": list,\n    \"recommendation\": str\n}\n</code></pre>"},{"location":"api/structure/#calculate_dipole_moment","title":"calculate_dipole_moment","text":"<pre><code>calculate_dipole_moment(formal_charges: dict = None) -&gt; tuple\n</code></pre> <p>Calculate electric dipole moment. Returns <code>(magnitude, direction_vector)</code>.</p>"},{"location":"api/structure/#layer-analysis-methods","title":"Layer Analysis Methods","text":""},{"location":"api/structure/#identify_layers","title":"identify_layers","text":"<pre><code>identify_layers(tolerance: float = 0.5) -&gt; List[dict]\n</code></pre> <p>Identify atomic layers. Returns list of layer info dicts.</p>"},{"location":"api/structure/#get_layer_spacing","title":"get_layer_spacing","text":"<pre><code>get_layer_spacing() -&gt; List[float]\n</code></pre> <p>Get interlayer distances in Angstrom.</p>"},{"location":"api/structure/#stoichiometry-methods","title":"Stoichiometry Methods","text":""},{"location":"api/structure/#check_stoichiometry","title":"check_stoichiometry","text":"<pre><code>check_stoichiometry(\n    expected: dict = None,\n    tolerance: float = 0.1\n) -&gt; dict\n</code></pre> <p>Check if stoichiometry matches expected.</p>"},{"location":"api/structure/#defectbuilder","title":"DefectBuilder","text":"<p>Create point defects and oxynitride structures.</p> <pre><code>from nh3sofc.structure import DefectBuilder\n</code></pre>"},{"location":"api/structure/#constructor_2","title":"Constructor","text":"<pre><code>DefectBuilder(structure: Union[SlabStructure, Atoms])\n</code></pre>"},{"location":"api/structure/#methods_2","title":"Methods","text":""},{"location":"api/structure/#create_oxynitride","title":"create_oxynitride","text":"<pre><code>create_oxynitride(\n    nitrogen_fraction: float = 0.67,\n    vacancy_concentration: float = 0.0,\n    vacancy_element: str = \"N\",\n    placement: str = \"random\",\n    random_seed: int = None\n) -&gt; Atoms\n</code></pre> <p>Create oxynitride by substituting O with N and creating vacancies.</p> <p>Parameters:</p> Name Type Default Description <code>nitrogen_fraction</code> <code>float</code> <code>0.67</code> Fraction of O to replace with N <code>vacancy_concentration</code> <code>float</code> <code>0.0</code> Fraction of anion sites to leave vacant <code>vacancy_element</code> <code>str</code> <code>\"N\"</code> Element to create vacancies in (\"N\" or \"O\") <code>placement</code> <code>str</code> <code>\"random\"</code> Defect placement strategy (see below) <code>random_seed</code> <code>int</code> <code>None</code> Random seed for reproducibility <p>Placement strategies:</p> Strategy Description <code>\"random\"</code> Random placement throughout structure <code>\"surface\"</code> Preferentially place defects near surface (high z) <code>\"near_N\"</code> Place vacancies near existing N atoms <p>Example:</p> <pre><code>defect = DefectBuilder(surface)\n\n# Random placement (default)\noxynitride = defect.create_oxynitride(\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.10\n)\n\n# Surface-populated defects\noxynitride_surface = defect.create_oxynitride(\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.10,\n    placement=\"surface\"\n)\n</code></pre>"},{"location":"api/structure/#create_oxynitride_pool","title":"create_oxynitride_pool","text":"<pre><code>create_oxynitride_pool(\n    nitrogen_fraction: float = 0.67,\n    vacancy_concentration: float = 0.0,\n    vacancy_element: str = \"N\",\n    n_configs_per_strategy: int = 3,\n    strategies: List[str] = None,\n    random_seed: int = None\n) -&gt; List[Dict]\n</code></pre> <p>Generate a pool of oxynitride configurations with different placement strategies.</p> <p>Parameters:</p> Name Type Default Description <code>nitrogen_fraction</code> <code>float</code> <code>0.67</code> Fraction of O to replace with N <code>vacancy_concentration</code> <code>float</code> <code>0.0</code> Fraction of anion sites to leave vacant <code>vacancy_element</code> <code>str</code> <code>\"N\"</code> Element to create vacancies in <code>n_configs_per_strategy</code> <code>int</code> <code>3</code> Configurations per strategy <code>strategies</code> <code>List[str]</code> <code>[\"random\", \"surface\", \"near_N\"]</code> Strategies to use <code>random_seed</code> <code>int</code> <code>None</code> Base random seed <p>Returns:</p> <pre><code>[{\n    \"atoms\": Atoms,\n    \"placement\": str,\n    \"nitrogen_fraction\": float,\n    \"vacancy_concentration\": float,\n    \"config_id\": int,\n}, ...]\n</code></pre> <p>Example:</p> <pre><code>defect = DefectBuilder(surface)\npool = defect.create_oxynitride_pool(\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.1,\n    n_configs_per_strategy=5\n)\nprint(f\"Generated {len(pool)} configurations\")  # 15 configs (5 x 3 strategies)\n</code></pre>"},{"location":"api/structure/#create_vacancy","title":"create_vacancy","text":"<pre><code>create_vacancy(\n    element: str,\n    concentration: float,\n    indices: List[int] = None,\n    random_seed: int = None\n) -&gt; Atoms\n</code></pre> <p>Create vacancies by removing atoms.</p> <p>Parameters:</p> Name Type Default Description <code>element</code> <code>str</code> - Element to remove (e.g., \"O\") <code>concentration</code> <code>float</code> - Fraction of atoms to remove (0.0 to 1.0) <code>indices</code> <code>List[int]</code> <code>None</code> Specific indices to remove (if None, random selection) <code>random_seed</code> <code>int</code> <code>None</code> Random seed for reproducibility"},{"location":"api/structure/#adsorbateplacer","title":"AdsorbatePlacer","text":"<p>Place adsorbate molecules on surfaces using 6 methods.</p> <pre><code>from nh3sofc.structure import AdsorbatePlacer\n</code></pre>"},{"location":"api/structure/#constructor_3","title":"Constructor","text":"<pre><code>AdsorbatePlacer(\n    slab: Atoms,\n    adsorbate_info: dict = None\n)\n</code></pre>"},{"location":"api/structure/#methods_3","title":"Methods","text":""},{"location":"api/structure/#add_simple","title":"add_simple","text":"<pre><code>add_simple(\n    adsorbate: str,\n    position: tuple,\n    height: float = 2.0,\n    orientation: tuple = None\n) -&gt; Atoms\n</code></pre> <p>Manual placement at specific (x, y) position.</p> <p>Example:</p> <pre><code>placer = AdsorbatePlacer(slab)\nresult = placer.add_simple(\"NH3\", position=(2.5, 2.5), height=2.0)\n</code></pre>"},{"location":"api/structure/#add_random","title":"add_random","text":"<pre><code>add_random(\n    adsorbate: str,\n    n_configs: int = 10,\n    height: float = 2.0,\n    seed: int = None\n) -&gt; List[Atoms]\n</code></pre> <p>Random placement with rotation.</p>"},{"location":"api/structure/#add_grid","title":"add_grid","text":"<pre><code>add_grid(\n    adsorbate: str,\n    nx: int = 3,\n    ny: int = 3,\n    height: float = 2.0\n) -&gt; List[Atoms]\n</code></pre> <p>Grid-based systematic placement.</p>"},{"location":"api/structure/#add_on_site","title":"add_on_site","text":"<pre><code>add_on_site(\n    adsorbate: str,\n    site_type: str = \"ontop\",\n    atom_types: List[str] = None,\n    height: float = 2.0\n) -&gt; List[Atoms]\n</code></pre> <p>Place on specific atomic sites.</p> <p>Parameters:</p> Name Type Default Description <code>adsorbate</code> <code>str</code> - Molecule name (\"NH3\", \"H2O\", etc.) <code>site_type</code> <code>str</code> <code>\"ontop\"</code> Site type: \"ontop\", \"bridge\", \"hollow\" <code>atom_types</code> <code>List[str]</code> <code>None</code> Filter by atom types <code>height</code> <code>float</code> <code>2.0</code> Height above surface (\u00c5) <p>Example:</p> <pre><code># Place NH3 on top of La and V atoms only\nconfigs = placer.add_on_site(\n    \"NH3\",\n    site_type=\"ontop\",\n    atom_types=[\"La\", \"V\"]\n)\n</code></pre>"},{"location":"api/structure/#add_with_collision","title":"add_with_collision","text":"<pre><code>add_with_collision(\n    adsorbate: str,\n    n_configs: int = 10,\n    min_distance: float = 2.0,\n    height: float = 2.0\n) -&gt; List[Atoms]\n</code></pre> <p>Random placement with collision detection.</p>"},{"location":"api/structure/#add_catkit","title":"add_catkit","text":"<pre><code>add_catkit(\n    adsorbate: str,\n    site_type: str = \"ontop\"\n) -&gt; List[Atoms]\n</code></pre> <p>Use CatKit for automated site detection.</p>"},{"location":"api/structure/#decompositionbuilder","title":"DecompositionBuilder","text":"<p>Generate NH3 decomposition intermediate configurations.</p> <pre><code>from nh3sofc.structure import DecompositionBuilder\n</code></pre>"},{"location":"api/structure/#constructor_4","title":"Constructor","text":"<pre><code>DecompositionBuilder(\n    nh3_on_slab: Atoms,\n    random_seed: int = None\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>nh3_on_slab</code> <code>Atoms</code> Optimized NH3 on surface structure <code>random_seed</code> <code>int</code> Random seed for reproducibility"},{"location":"api/structure/#methods_4","title":"Methods","text":""},{"location":"api/structure/#create_nh2_h_configs","title":"create_NH2_H_configs","text":"<pre><code>create_NH2_H_configs(\n    n_configs: int = 10,\n    h_height: float = 1.0,\n    min_h_distance: float = 1.5,\n    max_h_distance: float = 4.0\n) -&gt; List[Atoms]\n</code></pre> <p>Generate NH2 + H configurations.</p> <p>Example:</p> <pre><code>decomp = DecompositionBuilder(nh3_on_slab)\nnh2_h = decomp.create_NH2_H_configs(n_configs=10)\n</code></pre>"},{"location":"api/structure/#create_nh_2h_configs","title":"create_NH_2H_configs","text":"<pre><code>create_NH_2H_configs(\n    n_configs: int = 10,\n    h_h_min: float = 1.5\n) -&gt; List[Atoms]\n</code></pre> <p>Generate NH + 2H configurations.</p>"},{"location":"api/structure/#create_n_3h_configs","title":"create_N_3H_configs","text":"<pre><code>create_N_3H_configs(\n    n_configs: int = 5,\n    cluster_h: bool = False\n) -&gt; List[Atoms]\n</code></pre> <p>Generate N + 3H configurations.</p>"},{"location":"api/structure/#helper-functions","title":"Helper Functions","text":""},{"location":"api/structure/#generate_decomposition_pathway","title":"generate_decomposition_pathway","text":"<pre><code>generate_decomposition_pathway(\n    nh3_on_slab: Atoms,\n    n_configs_per_step: int = 5,\n    random_seed: int = None\n) -&gt; Dict[str, List[Atoms]]\n</code></pre> <p>Generate all decomposition intermediates.</p> <p>Returns:</p> <pre><code>{\n    \"NH3\": [atoms],\n    \"NH2_H\": [atoms, atoms, ...],\n    \"NH_2H\": [atoms, atoms, ...],\n    \"N_3H\": [atoms, atoms, ...]\n}\n</code></pre>"},{"location":"api/structure/#supported-adsorbates","title":"Supported Adsorbates","text":"Name Formula Atoms Default Height <code>\"NH3\"</code> NH3 4 2.0 \u00c5 <code>\"NH2\"</code> NH2 3 1.8 \u00c5 <code>\"NH\"</code> NH 2 1.5 \u00c5 <code>\"N\"</code> N 1 1.2 \u00c5 <code>\"H\"</code> H 1 1.0 \u00c5 <code>\"H2\"</code> H2 2 2.5 \u00c5 <code>\"H2O\"</code> H2O 3 2.0 \u00c5 <code>\"O\"</code> O 1 1.2 \u00c5 <code>\"OH\"</code> OH 2 1.5 \u00c5"},{"location":"api/structure/#exsolutionbuilder","title":"ExsolutionBuilder","text":"<p>Create structures for exsolution processes where transition metals migrate from perovskite bulk to surface.</p> <pre><code>from nh3sofc.structure import ExsolutionBuilder\n</code></pre>"},{"location":"api/structure/#constructor_5","title":"Constructor","text":"<pre><code>ExsolutionBuilder(\n    structure: Union[SlabStructure, Atoms],\n    a_site_elements: List[str] = None,\n    b_site_elements: List[str] = None\n)\n</code></pre> <p>Parameters:</p> Name Type Default Description <code>structure</code> <code>SlabStructure</code> or <code>Atoms</code> - Perovskite surface slab <code>a_site_elements</code> <code>List[str]</code> <code>[\"La\", \"Sr\", \"Ba\", \"Ca\"]</code> A-site elements <code>b_site_elements</code> <code>List[str]</code> <code>[\"Ti\", \"V\", \"Mn\", \"Fe\", \"Co\", \"Ni\"]</code> B-site elements"},{"location":"api/structure/#methods_5","title":"Methods","text":""},{"location":"api/structure/#identify_perovskite_sites","title":"identify_perovskite_sites","text":"<pre><code>identify_perovskite_sites() -&gt; Dict[str, List[int]]\n</code></pre> <p>Identify A-site, B-site, and O-site atom indices.</p> <p>Returns:</p> <pre><code>{\n    \"A_site\": [0, 1, 2, ...],\n    \"B_site\": [4, 5, ...],\n    \"O_site\": [8, 9, 10, ...]\n}\n</code></pre>"},{"location":"api/structure/#create_defective_perovskite","title":"create_defective_perovskite","text":"<pre><code>create_defective_perovskite(\n    a_site_vacancy_fraction: float = 0.0,\n    b_site_vacancy_fraction: float = 0.0,\n    oxygen_vacancy_fraction: float = 0.0,\n    b_site_element: str = None,\n    random_seed: int = None\n) -&gt; Atoms\n</code></pre> <p>Create defective perovskite with cation and anion vacancies.</p> <p>Parameters:</p> Name Type Default Description <code>a_site_vacancy_fraction</code> <code>float</code> <code>0.0</code> Fraction of A-site to remove <code>b_site_vacancy_fraction</code> <code>float</code> <code>0.0</code> Fraction of B-site to remove <code>oxygen_vacancy_fraction</code> <code>float</code> <code>0.0</code> Fraction of O to remove <code>b_site_element</code> <code>str</code> <code>None</code> Specific B-site element for vacancies <code>random_seed</code> <code>int</code> <code>None</code> Random seed for reproducibility <p>Example:</p> <pre><code>builder = ExsolutionBuilder(surface)\ndefective = builder.create_defective_perovskite(\n    a_site_vacancy_fraction=0.05,\n    b_site_vacancy_fraction=0.1,\n    oxygen_vacancy_fraction=0.08,\n    b_site_element=\"Ni\"\n)\n</code></pre>"},{"location":"api/structure/#create_surface_segregation","title":"create_surface_segregation","text":"<pre><code>create_surface_segregation(\n    metal: str,\n    n_atoms: int = 1,\n    random_seed: int = None\n) -&gt; Atoms\n</code></pre> <p>Move B-site metal atoms from bulk to surface layer.</p> <p>Parameters:</p> Name Type Default Description <code>metal</code> <code>str</code> - Element to segregate (\"Ni\", \"Co\", \"Fe\") <code>n_atoms</code> <code>int</code> <code>1</code> Number of atoms to move <code>random_seed</code> <code>int</code> <code>None</code> Random seed"},{"location":"api/structure/#create_nanoparticle","title":"create_nanoparticle","text":"<pre><code>create_nanoparticle(\n    metal: str,\n    n_atoms: int,\n    shape: str = \"hemispherical\",\n    position: str = \"hollow\",\n    interface_distance: float = 2.0,\n    socketed: bool = True,\n    random_seed: int = None\n) -&gt; Atoms\n</code></pre> <p>Place metallic nanoparticle on surface.</p> <p>Parameters:</p> Name Type Default Description <code>metal</code> <code>str</code> - Metal element (\"Ni\", \"Co\", \"Fe\") <code>n_atoms</code> <code>int</code> - Cluster size (1, 4, 7, 13, 19) <code>shape</code> <code>str</code> <code>\"hemispherical\"</code> Shape: \"hemispherical\" or \"icosahedral\" <code>position</code> <code>str</code> <code>\"hollow\"</code> Position: \"hollow\", \"ontop\", \"bridge\", \"random\" <code>interface_distance</code> <code>float</code> <code>2.0</code> Metal-surface distance (\u00c5) <code>socketed</code> <code>bool</code> <code>True</code> Remove atoms under particle (real exsolution) <code>random_seed</code> <code>int</code> <code>None</code> Random seed <p>Example:</p> <pre><code>builder = ExsolutionBuilder(surface)\nwith_particle = builder.create_nanoparticle(\n    metal=\"Ni\",\n    n_atoms=13,\n    shape=\"hemispherical\",\n    socketed=True\n)\n</code></pre>"},{"location":"api/structure/#create_exsolution_pathway","title":"create_exsolution_pathway","text":"<pre><code>create_exsolution_pathway(\n    metal: str,\n    particle_size: int,\n    vacancy_fraction: float = 0.1,\n    random_seed: int = None\n) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Generate complete exsolution pathway structures.</p> <p>Returns:</p> <pre><code>[\n    {\"atoms\": Atoms, \"stage\": \"pristine\", \"description\": \"...\"},\n    {\"atoms\": Atoms, \"stage\": \"defective\", \"description\": \"...\"},\n    {\"atoms\": Atoms, \"stage\": \"segregated\", \"description\": \"...\"},\n    {\"atoms\": Atoms, \"stage\": \"exsolved\", \"description\": \"...\"}\n]\n</code></pre>"},{"location":"api/structure/#get_adsorption_sites","title":"get_adsorption_sites","text":"<pre><code>get_adsorption_sites(\n    structure: Atoms = None,\n    particle_indices: List[int] = None\n) -&gt; Dict[str, List[Dict]]\n</code></pre> <p>Identify adsorption sites on exsolved particle system.</p> <p>Returns:</p> <pre><code>{\n    \"metal_top\": [...],        # Top of metal particle\n    \"interface_edge\": [...],   # Metal-oxide boundary\n    \"vacancy_site\": [...],     # Near O vacancies\n    \"oxide_surface\": [...]     # Remaining perovskite\n}\n</code></pre>"},{"location":"api/structure/#exsolutionstructure","title":"ExsolutionStructure","text":"<p>Structure class with exsolution metadata tracking.</p> <pre><code>from nh3sofc.structure import ExsolutionStructure\n</code></pre>"},{"location":"api/structure/#constructor_6","title":"Constructor","text":"<pre><code>ExsolutionStructure(\n    atoms: Atoms,\n    exsolution_metal: str = None,\n    nanoparticle_size: int = None,\n    a_site_vacancy_concentration: float = 0.0,\n    b_site_vacancy_concentration: float = 0.0,\n    oxygen_vacancy_concentration: float = 0.0,\n    exsolution_state: str = \"pristine\"\n)\n</code></pre>"},{"location":"api/structure/#attributes","title":"Attributes","text":"Name Type Description <code>exsolution_metal</code> <code>str</code> Metal being exsolved (Ni, Co, Fe) <code>nanoparticle_size</code> <code>int</code> Number of atoms in particle <code>exsolution_state</code> <code>str</code> State: pristine, defective, segregated, exsolved <code>oxygen_vacancy_concentration</code> <code>float</code> O vacancy fraction"},{"location":"api/structure/#helper-functions_1","title":"Helper Functions","text":""},{"location":"api/structure/#create_metallic_cluster","title":"create_metallic_cluster","text":"<pre><code>create_metallic_cluster(\n    metal: str,\n    n_atoms: int,\n    shape: str = \"hemispherical\"\n) -&gt; Atoms\n</code></pre> <p>Create isolated metallic cluster.</p> <p>Example:</p> <pre><code>from nh3sofc.structure import create_metallic_cluster\n\nni13 = create_metallic_cluster(\"Ni\", 13, \"hemispherical\")\n</code></pre>"},{"location":"api/structure/#generate_exsolution_series","title":"generate_exsolution_series","text":"<pre><code>generate_exsolution_series(\n    base_structure: Atoms,\n    metal: str,\n    vacancy_range: List[float],\n    particle_sizes: List[int],\n    n_configs: int = 3,\n    random_seed: int = None\n) -&gt; List[Dict]\n</code></pre> <p>Generate series for screening.</p> <p>Example:</p> <pre><code>from nh3sofc.structure import generate_exsolution_series\n\nseries = generate_exsolution_series(\n    surface,\n    metal=\"Ni\",\n    vacancy_range=[0.0, 0.05, 0.1],\n    particle_sizes=[1, 13],\n    n_configs=3\n)\n</code></pre>"},{"location":"api/structure/#dopantbuilder","title":"DopantBuilder","text":"<p>Create acceptor-doped ceria structures (GDC, SDC, PDC) with charge-compensating oxygen vacancies.</p> <pre><code>from nh3sofc.structure import DopantBuilder\n</code></pre>"},{"location":"api/structure/#constructor_7","title":"Constructor","text":"<pre><code>DopantBuilder(structure: Union[SlabStructure, Atoms])\n</code></pre> <p>Parameters:</p> Name Type Description <code>structure</code> <code>SlabStructure</code> or <code>Atoms</code> CeO2 structure (bulk or slab) to dope"},{"location":"api/structure/#methods_6","title":"Methods","text":""},{"location":"api/structure/#create_doped_structure","title":"create_doped_structure","text":"<pre><code>create_doped_structure(\n    dopant: str,\n    dopant_fraction: float,\n    host_cation: str = \"Ce\",\n    auto_compensate: bool = True,\n    vacancy_placement: str = \"random\",\n    dopant_placement: str = \"random\",\n    dopant_preference: float = 0.7,\n    vacancy_preference: float = 0.7,\n    pr_trivalent_fraction: float = 1.0,\n    z_threshold: float = 0.3,\n    random_seed: int = None\n) -&gt; Atoms\n</code></pre> <p>Create doped structure with charge-compensating vacancies.</p> <p>Parameters:</p> Name Type Default Description <code>dopant</code> <code>str</code> - Dopant element (\"Sm\", \"Gd\", \"Pr\", \"Y\", \"La\", \"Nd\") <code>dopant_fraction</code> <code>float</code> - Fraction of host cations to replace (0.0 to 1.0) <code>host_cation</code> <code>str</code> <code>\"Ce\"</code> Cation to replace <code>auto_compensate</code> <code>bool</code> <code>True</code> Create compensating vacancies automatically <code>vacancy_placement</code> <code>str</code> <code>\"random\"</code> Vacancy placement strategy (see below) <code>dopant_placement</code> <code>str</code> <code>\"random\"</code> Dopant placement strategy <code>dopant_preference</code> <code>float</code> <code>0.7</code> Bias strength for dopant placement (0.5=uniform, 1.0=strong) <code>vacancy_preference</code> <code>float</code> <code>0.7</code> Bias strength for vacancy placement <code>pr_trivalent_fraction</code> <code>float</code> <code>1.0</code> For Pr: fraction that is Pr\u00b3\u207a (rest is Pr\u2074\u207a) <code>z_threshold</code> <code>float</code> <code>0.3</code> Fraction of slab considered \"surface\" <code>random_seed</code> <code>int</code> <code>None</code> Random seed for reproducibility <p>Placement strategies:</p> Strategy Description <code>\"random\"</code> Uniform random distribution (ignores preference) <code>\"surface\"</code> Preferentially place at high z (surface) <code>\"bulk\"</code> Preferentially place at low z (bulk) <code>\"near_dopant\"</code> Place vacancies near dopant atoms (vacancy only) <p>Example:</p> <pre><code>builder = DopantBuilder(ceo2_slab)\n\n# 10% Gd-doped ceria (GDC) with random placement\ngdc = builder.create_doped_structure(\n    dopant=\"Gd\",\n    dopant_fraction=0.10,\n)\n\n# GDC with vacancies preferring dopant sites\ngdc_associated = builder.create_doped_structure(\n    dopant=\"Gd\",\n    dopant_fraction=0.10,\n    vacancy_placement=\"near_dopant\",\n    vacancy_preference=0.8,\n)\n\n# Pr-doped ceria with mixed valence\npdc = builder.create_doped_structure(\n    dopant=\"Pr\",\n    dopant_fraction=0.20,\n    pr_trivalent_fraction=0.5,  # 50% Pr\u00b3\u207a, 50% Pr\u2074\u207a\n)\n</code></pre>"},{"location":"api/structure/#create_doped_pool","title":"create_doped_pool","text":"<pre><code>create_doped_pool(\n    dopant: str,\n    dopant_fraction: Union[float, List[float]],\n    n_configs: int = 3,\n    strategies: List[str] = None,\n    host_cation: str = \"Ce\",\n    dopant_placement: str = \"random\",\n    dopant_preference: float = 0.7,\n    vacancy_preference: float = 0.7,\n    pr_trivalent_fraction: float = 1.0,\n    z_threshold: float = 0.3,\n    random_seed: int = None\n) -&gt; List[Dict]\n</code></pre> <p>Generate multiple doped configurations for screening.</p> <p>Parameters:</p> Name Type Default Description <code>dopant</code> <code>str</code> - Dopant element <code>dopant_fraction</code> <code>float</code> or <code>List[float]</code> - Fraction(s) of host cations to replace. Single value or list for concentration series. <code>n_configs</code> <code>int</code> <code>3</code> Configurations per (fraction, strategy) combination <code>strategies</code> <code>List[str]</code> See below Strategies to use <p>Default strategies:</p> <ul> <li>Single fraction: <code>[\"random\", \"surface\", \"near_dopant\"]</code></li> <li>List of fractions: <code>[\"random\"]</code> (concentration series typically don't need strategy variation)</li> </ul> <p>Returns:</p> <pre><code>[{\n    \"atoms\": Atoms,\n    \"dopant\": str,\n    \"dopant_fraction\": float,\n    \"vacancy_placement\": str,\n    \"config_id\": int,\n}, ...]\n</code></pre> <p>Examples:</p> <pre><code># Single fraction, multiple strategies\npool = builder.create_doped_pool(\n    dopant=\"Sm\",\n    dopant_fraction=0.15,\n    n_configs=5,\n    strategies=[\"random\", \"surface\", \"near_dopant\"],\n)\nprint(f\"Generated {len(pool)} configurations\")  # 15 configs\n\n# Concentration series (multiple fractions)\npool = builder.create_doped_pool(\n    dopant=\"Gd\",\n    dopant_fraction=[0.05, 0.10, 0.15, 0.20],\n    n_configs=3,\n)\nprint(f\"Generated {len(pool)} configurations\")  # 12 configs\n</code></pre>"},{"location":"api/structure/#dopedceriastructure","title":"DopedCeriaStructure","text":"<p>Structure class for doped ceria materials with metadata tracking.</p> <pre><code>from nh3sofc.structure import DopedCeriaStructure\n</code></pre>"},{"location":"api/structure/#constructor_8","title":"Constructor","text":"<pre><code>DopedCeriaStructure(\n    atoms: Atoms,\n    dopant: str,\n    dopant_fraction: float,\n    n_vacancies: int,\n    parent_formula: str = None\n)\n</code></pre>"},{"location":"api/structure/#class-methods_1","title":"Class Methods","text":""},{"location":"api/structure/#from_ceria","title":"from_ceria","text":"<pre><code>@classmethod\nDopedCeriaStructure.from_ceria(\n    ceria: Union[Atoms, BaseStructure],\n    dopant: str,\n    dopant_fraction: float,\n    host_cation: str = \"Ce\",\n    vacancy_placement: str = \"random\",\n    dopant_placement: str = \"random\",\n    random_seed: int = None\n) -&gt; DopedCeriaStructure\n</code></pre> <p>Create doped ceria from pristine CeO2 structure.</p> <p>Example:</p> <pre><code>doped = DopedCeriaStructure.from_ceria(\n    ceo2_slab,\n    dopant=\"Gd\",\n    dopant_fraction=0.10,\n)\nprint(doped.get_dopant_name())  # \"GDC\"\n</code></pre>"},{"location":"api/structure/#methods_7","title":"Methods","text":""},{"location":"api/structure/#get_stoichiometry","title":"get_stoichiometry","text":"<pre><code>get_stoichiometry() -&gt; Dict[str, float]\n</code></pre> <p>Calculate stoichiometry relative to total cation sites.</p> <p>Example:</p> <pre><code>stoich = doped.get_stoichiometry()\n# {\"Ce\": 0.9, \"Gd\": 0.1, \"O\": 1.95}\n</code></pre>"},{"location":"api/structure/#get_dopant_name","title":"get_dopant_name","text":"<pre><code>get_dopant_name() -&gt; str\n</code></pre> <p>Get material abbreviation (GDC, SDC, PDC, etc.).</p>"},{"location":"api/structure/#attributes_1","title":"Attributes","text":"Name Type Description <code>dopant</code> <code>str</code> Dopant element symbol <code>dopant_fraction</code> <code>float</code> Fraction of host cations replaced <code>n_vacancies</code> <code>int</code> Number of oxygen vacancies created <code>parent_formula</code> <code>str</code> Original CeO2 formula"},{"location":"api/structure/#dopant-analysis-functions","title":"Dopant Analysis Functions","text":""},{"location":"api/structure/#analyze_dopant_distribution","title":"analyze_dopant_distribution","text":"<pre><code>analyze_dopant_distribution(\n    atoms: Atoms,\n    dopant: str,\n    reference_atoms: Atoms = None,\n    z_threshold: float = 0.3,\n    near_dopant_cutoff: float = 3.5\n) -&gt; Dict[str, Any]\n</code></pre> <p>Analyze dopant and vacancy distribution in a structure.</p> <p>Parameters:</p> Name Type Default Description <code>atoms</code> <code>Atoms</code> - Doped structure to analyze <code>dopant</code> <code>str</code> - Dopant element symbol <code>reference_atoms</code> <code>Atoms</code> <code>None</code> Original structure for vacancy counting <code>z_threshold</code> <code>float</code> <code>0.3</code> Surface region fraction <code>near_dopant_cutoff</code> <code>float</code> <code>3.5</code> Distance cutoff (\u00c5) for near-dopant analysis <p>Returns:</p> <pre><code>{\n    \"dopant\": str,\n    \"dopant_total\": int,\n    \"dopant_surface\": int,\n    \"dopant_surface_fraction\": float,\n    \"vacancy_total\": int,\n    \"vacancy_near_dopant\": int,\n    \"vacancy_near_dopant_fraction\": float,\n    ...\n}\n</code></pre> <p>Example:</p> <pre><code>from nh3sofc.structure import analyze_dopant_distribution\n\nstats = analyze_dopant_distribution(gdc, \"Gd\", reference_atoms=ceo2)\nprint(f\"Gd in surface: {stats['dopant_surface_fraction']:.1%}\")\nprint(f\"Vacancies near Gd: {stats['vacancy_near_dopant_fraction']:.1%}\")\n</code></pre>"},{"location":"api/structure/#generate_dopant_series-deprecated","title":"generate_dopant_series (Deprecated)","text":"<p>Deprecated</p> <p>Use <code>DopantBuilder.create_doped_pool(dopant_fraction=[...])</code> instead.</p> <pre><code>generate_dopant_series(\n    structure: Union[Atoms, BaseStructure],\n    dopant: str,\n    dopant_fractions: List[float],\n    n_configs: int = 3,\n    host_cation: str = \"Ce\",\n    random_seed: int = None\n) -&gt; List[Dict]\n</code></pre> <p>Generate structures with varying dopant concentrations.</p> <p>Preferred approach:</p> <pre><code># Use create_doped_pool with list of fractions instead\nbuilder = DopantBuilder(ceo2_slab)\npool = builder.create_doped_pool(\n    dopant=\"Gd\",\n    dopant_fraction=[0.05, 0.10, 0.15, 0.20],\n    n_configs=5,\n)\n</code></pre>"},{"location":"api/structure/#print_dopant_analysis","title":"print_dopant_analysis","text":"<pre><code>print_dopant_analysis(stats: Dict[str, Any], title: str = \"Dopant Distribution Analysis\")\n</code></pre> <p>Print formatted summary of dopant distribution analysis.</p>"},{"location":"api/structure/#dopant-constants","title":"Dopant Constants","text":"<p>Available in <code>nh3sofc.core.constants</code>:</p> <pre><code>from nh3sofc.core.constants import ACCEPTOR_DOPANTS, HOST_CATIONS, CHARGE_COMPENSATION\n\n# Supported acceptor dopants for CeO2\nACCEPTOR_DOPANTS = {\n    \"Sm\": {\"charge\": +3, \"ionic_radius\": 1.079, \"name\": \"Samarium\"},\n    \"Gd\": {\"charge\": +3, \"ionic_radius\": 1.053, \"name\": \"Gadolinium\"},\n    \"Pr\": {\"charge\": +3, \"ionic_radius\": 1.126, \"name\": \"Praseodymium\"},\n    \"Y\":  {\"charge\": +3, \"ionic_radius\": 1.019, \"name\": \"Yttrium\"},\n    \"La\": {\"charge\": +3, \"ionic_radius\": 1.160, \"name\": \"Lanthanum\"},\n    \"Nd\": {\"charge\": +3, \"ionic_radius\": 1.109, \"name\": \"Neodymium\"},\n    \"Tb\": {\"charge\": +3, \"ionic_radius\": 1.040, \"name\": \"Terbium\"},\n}\n\n# Host cations\nHOST_CATIONS = {\n    \"Ce\": {\"charge\": +4, \"ionic_radius\": 0.970},\n    \"Zr\": {\"charge\": +4, \"ionic_radius\": 0.840},\n}\n\n# Charge compensation: 2 M\u00b3\u207a + 1 V_O^{2+} \u2192 neutral\nCHARGE_COMPENSATION = {\n    3: (2, 1),  # 2 trivalent dopants : 1 vacancy\n    2: (1, 1),  # 1 divalent dopant : 1 vacancy\n}\n</code></pre>"},{"location":"api/workflows/","title":"Workflows Module","text":"<p>The <code>nh3sofc.workflows</code> module provides high-level workflow classes for common computational tasks.</p>"},{"location":"api/workflows/#relaxationworkflow","title":"RelaxationWorkflow","text":"<p>Geometry optimization workflow.</p> <pre><code>from nh3sofc.workflows import RelaxationWorkflow\n</code></pre>"},{"location":"api/workflows/#constructor","title":"Constructor","text":"<pre><code>RelaxationWorkflow(\n    atoms: Atoms,\n    work_dir: str = \".\",\n    calculator: str = \"vasp\",\n    **calc_kwargs\n)\n</code></pre> <p>Parameters:</p> Name Type Default Description <code>atoms</code> <code>Atoms</code> - Initial structure <code>work_dir</code> <code>str</code> <code>\".\"</code> Working directory <code>calculator</code> <code>str</code> <code>\"vasp\"</code> Calculator: \"vasp\" or \"mace\" <code>**calc_kwargs</code> - - Calculator parameters"},{"location":"api/workflows/#methods","title":"Methods","text":""},{"location":"api/workflows/#setup","title":"setup","text":"<pre><code>setup() -&gt; dict\n</code></pre> <p>Set up calculation files.</p>"},{"location":"api/workflows/#run","title":"run","text":"<pre><code>run(submit: bool = False) -&gt; Atoms\n</code></pre> <p>Run optimization (MACE) or generate files (VASP).</p>"},{"location":"api/workflows/#parse_results","title":"parse_results","text":"<pre><code>parse_results() -&gt; dict\n</code></pre> <p>Parse optimization results.</p> <p>Example:</p> <pre><code>from ase.io import read\nfrom nh3sofc.workflows import RelaxationWorkflow\n\natoms = read(\"initial.xyz\")\n\n# VASP relaxation\nworkflow = RelaxationWorkflow(\n    atoms,\n    work_dir=\"./relax\",\n    calculator=\"vasp\",\n    encut=520,\n    kspacing=0.03,\n    hubbard_u={\"V\": 3.25},\n)\n\nworkflow.setup()\n\n# After VASP completes...\nresults = workflow.parse_results()\nrelaxed = results[\"atoms\"]\nprint(f\"Final energy: {results['energy']:.4f} eV\")\n</code></pre>"},{"location":"api/workflows/#decompositionworkflow","title":"DecompositionWorkflow","text":"<p>NH3 decomposition pathway workflow.</p> <pre><code>from nh3sofc.workflows import DecompositionWorkflow\n</code></pre>"},{"location":"api/workflows/#constructor_1","title":"Constructor","text":"<pre><code>DecompositionWorkflow(\n    nh3_on_slab: Atoms,\n    work_dir: str = \"./decomposition\",\n    n_configs_per_step: int = 5,\n    calculator: str = \"vasp\",\n    **calc_kwargs\n)\n</code></pre> <p>Parameters:</p> Name Type Default Description <code>nh3_on_slab</code> <code>Atoms</code> - Optimized NH3 on surface <code>work_dir</code> <code>str</code> <code>\"./decomposition\"</code> Working directory <code>n_configs_per_step</code> <code>int</code> <code>5</code> Configurations per step <code>calculator</code> <code>str</code> <code>\"vasp\"</code> Calculator type"},{"location":"api/workflows/#methods_1","title":"Methods","text":""},{"location":"api/workflows/#setup_1","title":"setup","text":"<pre><code>setup() -&gt; Dict[str, List[str]]\n</code></pre> <p>Generate all intermediate configurations and calculation files.</p> <p>Returns: Dictionary mapping step names to list of calculation directories.</p>"},{"location":"api/workflows/#get_status","title":"get_status","text":"<pre><code>get_status() -&gt; Dict[str, dict]\n</code></pre> <p>Check calculation status for all steps.</p>"},{"location":"api/workflows/#parse_results_1","title":"parse_results","text":"<pre><code>parse_results() -&gt; Dict[str, List[dict]]\n</code></pre> <p>Parse all calculation results.</p>"},{"location":"api/workflows/#get_lowest_energies","title":"get_lowest_energies","text":"<pre><code>get_lowest_energies() -&gt; Dict[str, float]\n</code></pre> <p>Get lowest energy for each step.</p>"},{"location":"api/workflows/#get_energy_profile","title":"get_energy_profile","text":"<pre><code>get_energy_profile(reference: str = \"NH3\") -&gt; Dict[str, float]\n</code></pre> <p>Get relative energy profile.</p>"},{"location":"api/workflows/#get_reaction_energies","title":"get_reaction_energies","text":"<pre><code>get_reaction_energies() -&gt; Dict[str, float]\n</code></pre> <p>Get step-by-step reaction energies.</p>"},{"location":"api/workflows/#print_summary","title":"print_summary","text":"<pre><code>print_summary()\n</code></pre> <p>Print formatted results summary.</p> <p>Example:</p> <pre><code>from ase.io import read\nfrom nh3sofc.workflows import DecompositionWorkflow\n\nnh3_on_slab = read(\"relaxed_nh3_on_surface.traj\")\n\nworkflow = DecompositionWorkflow(\n    nh3_on_slab=nh3_on_slab,\n    work_dir=\"./decomposition_study\",\n    n_configs_per_step=5,\n    encut=520,\n    hubbard_u={\"V\": 3.25},\n    vdw=\"D3BJ\",\n)\n\n# Setup all calculations\npaths = workflow.setup()\nfor step, dirs in paths.items():\n    print(f\"{step}: {len(dirs)} configurations\")\n\n# After calculations complete...\nprofile = workflow.get_energy_profile()\nworkflow.print_summary()\n</code></pre>"},{"location":"api/workflows/#directory-structure","title":"Directory Structure","text":"<pre><code>decomposition_study/\n\u251c\u2500\u2500 initial_configs/\n\u2502   \u251c\u2500\u2500 NH3.xyz\n\u2502   \u251c\u2500\u2500 NH2_H_000.xyz\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 NH3/\n\u2502   \u2514\u2500\u2500 config_000/\n\u251c\u2500\u2500 NH2_H/\n\u2502   \u251c\u2500\u2500 config_000/\n\u2502   \u251c\u2500\u2500 config_001/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 NH_2H/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 N_3H/\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"api/workflows/#nebworkflow","title":"NEBWorkflow","text":"<p>Nudged Elastic Band workflow for transition states.</p> <pre><code>from nh3sofc.workflows import NEBWorkflow\n</code></pre>"},{"location":"api/workflows/#constructor_2","title":"Constructor","text":"<pre><code>NEBWorkflow(\n    initial: Atoms,\n    final: Atoms,\n    work_dir: str = \"./neb\",\n    n_images: int = 5,\n    calculator: str = \"vasp\",\n    **calc_kwargs\n)\n</code></pre> <p>Parameters:</p> Name Type Default Description <code>initial</code> <code>Atoms</code> - Initial state structure <code>final</code> <code>Atoms</code> - Final state structure <code>work_dir</code> <code>str</code> <code>\"./neb\"</code> Working directory <code>n_images</code> <code>int</code> <code>5</code> Number of NEB images <code>calculator</code> <code>str</code> <code>\"vasp\"</code> Calculator type"},{"location":"api/workflows/#methods_2","title":"Methods","text":""},{"location":"api/workflows/#setup_2","title":"setup","text":"<pre><code>setup(\n    interpolation: str = \"idpp\",\n    climb: bool = True\n) -&gt; dict\n</code></pre> <p>Set up NEB calculation.</p> <p>Parameters:</p> Name Type Default Description <code>interpolation</code> <code>str</code> <code>\"idpp\"</code> Interpolation: \"linear\" or \"idpp\" <code>climb</code> <code>bool</code> <code>True</code> Use climbing image NEB"},{"location":"api/workflows/#run_mace","title":"run_mace","text":"<pre><code>run_mace(\n    fmax: float = 0.05,\n    steps: int = 500\n) -&gt; List[Atoms]\n</code></pre> <p>Run NEB with MACE calculator.</p>"},{"location":"api/workflows/#parse_results_2","title":"parse_results","text":"<pre><code>parse_results() -&gt; dict\n</code></pre> <p>Parse NEB results.</p> <p>Returns:</p> <pre><code>{\n    \"images\": List[Atoms],\n    \"energies\": List[float],\n    \"barrier_forward\": float,\n    \"barrier_reverse\": float,\n    \"ts_image\": int,\n    \"ts_structure\": Atoms,\n}\n</code></pre>"},{"location":"api/workflows/#plot_energy_profile","title":"plot_energy_profile","text":"<pre><code>plot_energy_profile(filename: str = None)\n</code></pre> <p>Plot NEB energy profile.</p> <p>Example:</p> <pre><code>from ase.io import read\nfrom nh3sofc.workflows import NEBWorkflow\n\ninitial = read(\"nh3_on_surface.traj\")\nfinal = read(\"nh2_h_on_surface.traj\")\n\nneb = NEBWorkflow(\n    initial=initial,\n    final=final,\n    work_dir=\"./neb_nh3_dissociation\",\n    n_images=7,\n    encut=520,\n)\n\n# For VASP\nneb.setup(interpolation=\"idpp\", climb=True)\n\n# Or run with MACE\nneb_images = neb.run_mace(fmax=0.03)\n\nresults = neb.parse_results()\nprint(f\"Forward barrier: {results['barrier_forward']:.3f} eV\")\nprint(f\"Reverse barrier: {results['barrier_reverse']:.3f} eV\")\n\nneb.plot_energy_profile(\"neb_profile.png\")\n</code></pre>"},{"location":"api/workflows/#frequencyworkflow","title":"FrequencyWorkflow","text":"<p>Vibrational frequency and thermochemistry workflow.</p> <pre><code>from nh3sofc.workflows import FrequencyWorkflow\n</code></pre>"},{"location":"api/workflows/#constructor_3","title":"Constructor","text":"<pre><code>FrequencyWorkflow(\n    atoms: Atoms,\n    work_dir: str = \"./frequency\",\n    adsorbate_indices: List[int] = None,\n    calculator: str = \"vasp\",\n    **calc_kwargs\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>atoms</code> <code>Atoms</code> Optimized structure <code>work_dir</code> <code>str</code> Working directory <code>adsorbate_indices</code> <code>List[int]</code> Indices of adsorbate atoms <code>calculator</code> <code>str</code> Calculator type"},{"location":"api/workflows/#methods_3","title":"Methods","text":""},{"location":"api/workflows/#setup_3","title":"setup","text":"<pre><code>setup(nfree: int = 2) -&gt; dict\n</code></pre> <p>Set up frequency calculation.</p>"},{"location":"api/workflows/#parse_results_3","title":"parse_results","text":"<pre><code>parse_results() -&gt; dict\n</code></pre> <p>Parse frequencies and calculate thermochemistry.</p> <p>Returns:</p> <pre><code>{\n    \"frequencies\": List[float],\n    \"real_frequencies\": List[float],\n    \"imaginary\": List[float],\n    \"zpe\": float,\n    \"thermo\": HarmonicThermo,\n}\n</code></pre>"},{"location":"api/workflows/#get_thermochemistry","title":"get_thermochemistry","text":"<pre><code>get_thermochemistry(\n    temperature: float = 673.0,\n    pressure: float = 1.0\n) -&gt; dict\n</code></pre> <p>Calculate thermodynamic properties.</p> <p>Returns:</p> <pre><code>{\n    \"zpe\": float,\n    \"U_vib\": float,\n    \"S_vib\": float,\n    \"G\": float,\n    \"H\": float,\n}\n</code></pre> <p>Example:</p> <pre><code>from nh3sofc.workflows import FrequencyWorkflow\n\nworkflow = FrequencyWorkflow(\n    optimized_atoms,\n    work_dir=\"./freq\",\n    adsorbate_indices=[48, 49, 50, 51],  # NH3 atom indices\n    encut=520,\n)\n\nworkflow.setup()\n\n# After VASP completes...\nresults = workflow.parse_results()\nprint(f\"Frequencies (cm^-1): {results['real_frequencies']}\")\nprint(f\"ZPE: {results['zpe']:.4f} eV\")\n\n# Thermochemistry at 673 K\nthermo = workflow.get_thermochemistry(temperature=673)\nprint(f\"G(673K): {thermo['G']:.4f} eV\")\n</code></pre>"},{"location":"api/workflows/#screeningworkflow","title":"ScreeningWorkflow","text":"<p>High-throughput parameter screening.</p> <pre><code>from nh3sofc.workflows import ScreeningWorkflow\n</code></pre>"},{"location":"api/workflows/#constructor_4","title":"Constructor","text":"<pre><code>ScreeningWorkflow(\n    base_structure: Atoms,\n    parameter_space: Dict[str, List],\n    work_dir: str = \"./screening\",\n    calculator: str = \"vasp\",\n    **calc_kwargs\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>base_structure</code> <code>Atoms</code> Base structure to modify <code>parameter_space</code> <code>dict</code> Parameters to scan <code>work_dir</code> <code>str</code> Working directory"},{"location":"api/workflows/#methods_4","title":"Methods","text":""},{"location":"api/workflows/#setup_4","title":"setup","text":"<pre><code>setup() -&gt; Dict[str, str]\n</code></pre> <p>Generate all calculation directories.</p>"},{"location":"api/workflows/#get_status_1","title":"get_status","text":"<pre><code>get_status() -&gt; Dict[str, str]\n</code></pre> <p>Check status of all calculations.</p>"},{"location":"api/workflows/#parse_results_4","title":"parse_results","text":"<pre><code>parse_results() -&gt; pd.DataFrame\n</code></pre> <p>Parse all results into DataFrame.</p>"},{"location":"api/workflows/#find_optimal","title":"find_optimal","text":"<pre><code>find_optimal(metric: str = \"energy\") -&gt; dict\n</code></pre> <p>Find optimal parameters.</p> <p>Example:</p> <pre><code>from nh3sofc.workflows import ScreeningWorkflow\n\nworkflow = ScreeningWorkflow(\n    base_structure=surface,\n    parameter_space={\n        \"vacancy_concentration\": [0.0, 0.05, 0.10, 0.15, 0.20],\n        \"nitrogen_fraction\": [0.5, 0.67, 0.75],\n    },\n    work_dir=\"./oxynitride_screening\",\n    encut=520,\n)\n\n# Setup all calculations\ncalc_dirs = workflow.setup()\nprint(f\"Created {len(calc_dirs)} calculations\")\n\n# After completion...\nresults = workflow.parse_results()\noptimal = workflow.find_optimal(metric=\"adsorption_energy\")\nprint(f\"Optimal parameters: {optimal}\")\n</code></pre>"},{"location":"api/workflows/#compositionscreening","title":"CompositionScreening","text":"<p>Specialized workflow for composition screening.</p> <pre><code>from nh3sofc.workflows import CompositionScreening\n</code></pre>"},{"location":"api/workflows/#constructor_5","title":"Constructor","text":"<pre><code>CompositionScreening(\n    base_structure: Atoms,\n    elements_to_vary: Dict[str, List[str]],\n    work_dir: str = \"./composition_screening\",\n    **calc_kwargs\n)\n</code></pre> <p>Example:</p> <pre><code>workflow = CompositionScreening(\n    base_structure=surface,\n    elements_to_vary={\n        \"La\": [\"La\", \"Sr\", \"Ba\"],\n        \"V\": [\"V\", \"Ti\", \"Nb\"],\n    },\n    work_dir=\"./dopant_screening\",\n)\n\nworkflow.setup()\n</code></pre>"},{"location":"api/workflows/#adsorbatescreening","title":"AdsorbateScreening","text":"<p>Screen multiple adsorbates and sites.</p> <pre><code>from nh3sofc.workflows import AdsorbateScreening\n</code></pre>"},{"location":"api/workflows/#constructor_6","title":"Constructor","text":"<pre><code>AdsorbateScreening(\n    surface: Atoms,\n    adsorbates: List[str],\n    sites: List[str] = None,\n    work_dir: str = \"./adsorbate_screening\",\n    **calc_kwargs\n)\n</code></pre> <p>Example:</p> <pre><code>workflow = AdsorbateScreening(\n    surface=surface,\n    adsorbates=[\"NH3\", \"NH2\", \"NH\", \"N\", \"H\"],\n    sites=[\"ontop_La\", \"ontop_V\", \"bridge\", \"hollow\"],\n    work_dir=\"./adsorbate_study\",\n)\n\npaths = workflow.setup()\n# Creates calculations for all adsorbate-site combinations\n</code></pre>"},{"location":"api/workflows/#workflow-utilities","title":"Workflow Utilities","text":""},{"location":"api/workflows/#submit_all","title":"submit_all","text":"<pre><code>from nh3sofc.workflows import submit_all\n\nsubmit_all(\n    work_dir: str,\n    job_system: str = \"pbs\",\n    dry_run: bool = False\n)\n</code></pre> <p>Submit all jobs in a workflow directory.</p>"},{"location":"api/workflows/#check_all_complete","title":"check_all_complete","text":"<pre><code>from nh3sofc.workflows import check_all_complete\n\ncomplete = check_all_complete(work_dir)\nif complete:\n    print(\"All calculations finished\")\n</code></pre>"},{"location":"api/workflows/#collect_results","title":"collect_results","text":"<pre><code>from nh3sofc.workflows import collect_results\n\nresults = collect_results(\n    work_dir,\n    output_format=\"dataframe\"  # or \"dict\" or \"json\"\n)\n</code></pre>"},{"location":"api/workflows/#exsolutionworkflow","title":"ExsolutionWorkflow","text":"<p>Workflow for studying exsolution processes in perovskite materials.</p> <pre><code>from nh3sofc.workflows import ExsolutionWorkflow\n</code></pre>"},{"location":"api/workflows/#constructor_7","title":"Constructor","text":"<pre><code>ExsolutionWorkflow(\n    atoms: Atoms,\n    work_dir: str,\n    metal: str = \"Ni\",\n    particle_size: int = 13,\n    vacancy_fraction: float = 0.1,\n    calculator: str = \"vasp\",\n    **calc_kwargs\n)\n</code></pre> <p>Parameters:</p> Name Type Default Description <code>atoms</code> <code>Atoms</code> - Perovskite surface structure <code>work_dir</code> <code>str</code> - Working directory <code>metal</code> <code>str</code> <code>\"Ni\"</code> Exsolution metal (Ni, Co, Fe) <code>particle_size</code> <code>int</code> <code>13</code> Nanoparticle size <code>vacancy_fraction</code> <code>float</code> <code>0.1</code> Oxygen vacancy concentration <code>calculator</code> <code>str</code> <code>\"vasp\"</code> Calculator type"},{"location":"api/workflows/#methods_5","title":"Methods","text":""},{"location":"api/workflows/#generate_pathway_structures","title":"generate_pathway_structures","text":"<pre><code>generate_pathway_structures() -&gt; List[Dict]\n</code></pre> <p>Generate structures for all exsolution stages: 1. Pristine perovskite 2. Defective (with vacancies) 3. Surface-segregated 4. Exsolved nanoparticle</p>"},{"location":"api/workflows/#setup_5","title":"setup","text":"<pre><code>setup() -&gt; Dict[str, Dict[str, Path]]\n</code></pre> <p>Set up calculations for all stages.</p>"},{"location":"api/workflows/#parse_results_5","title":"parse_results","text":"<pre><code>parse_results() -&gt; Dict[str, Any]\n</code></pre> <p>Parse results and calculate exsolution energetics.</p> <p>Returns:</p> <pre><code>{\n    \"pristine\": {\"energy\": ..., \"converged\": ...},\n    \"defective\": {\"energy\": ..., ...},\n    \"segregated\": {\"energy\": ..., ...},\n    \"exsolved\": {\"energy\": ..., ...},\n    \"exsolution_energy\": float,  # Calculated driving force\n    \"segregation_energy\": float,\n    \"summary\": {...}\n}\n</code></pre>"},{"location":"api/workflows/#couple_with_decomposition","title":"couple_with_decomposition","text":"<pre><code>couple_with_decomposition(\n    decomposition_kwargs: Dict = None\n) -&gt; DecompositionWorkflow\n</code></pre> <p>Set up NH3 decomposition study on exsolved particle.</p> <p>Example:</p> <pre><code>from nh3sofc.structure import BulkStructure, SurfaceBuilder\nfrom nh3sofc.workflows import ExsolutionWorkflow\n\n# Prepare perovskite surface\nbulk = BulkStructure.from_cif(\"LaSrTiNiO3.cif\")\nsurface = SurfaceBuilder(bulk).create_surface((0,0,1), layers=6, vacuum=15)\n\n# Set up exsolution workflow\nwf = ExsolutionWorkflow(\n    atoms=surface.atoms,\n    work_dir=\"./exsolution_study\",\n    metal=\"Ni\",\n    particle_size=13,\n    vacancy_fraction=0.1,\n    hubbard_u={\"Ni\": 6.2, \"Ti\": 3.0},\n)\n\nwf.generate_pathway_structures()\nwf.setup()\n\n# After VASP calculations:\nresults = wf.parse_results()\nprint(f\"Exsolution energy: {results['exsolution_energy']:.2f} eV\")\nprint(f\"Favorable: {results['summary']['favorable']}\")\n\n# Continue with NH3 decomposition on exsolved particle\ndecomp_wf = wf.couple_with_decomposition()\ndecomp_wf.setup()\n</code></pre>"},{"location":"api/workflows/#exsolutionscreeningworkflow","title":"ExsolutionScreeningWorkflow","text":"<p>High-throughput screening for exsolution parameters.</p> <pre><code>from nh3sofc.workflows import ExsolutionScreeningWorkflow\n</code></pre>"},{"location":"api/workflows/#constructor_8","title":"Constructor","text":"<pre><code>ExsolutionScreeningWorkflow(\n    base_structure: Atoms,\n    parameter_space: Dict[str, List],\n    work_dir: str,\n    calculator: str = \"vasp\",\n    n_configs_per_combo: int = 1,\n    **calc_kwargs\n)\n</code></pre> <p>Parameters:</p> Name Type Description <code>base_structure</code> <code>Atoms</code> Base perovskite surface <code>parameter_space</code> <code>dict</code> Parameters to screen <code>work_dir</code> <code>str</code> Working directory <code>n_configs_per_combo</code> <code>int</code> Configurations per combination <p>Parameter space options:</p> <pre><code>parameter_space = {\n    \"metal\": [\"Ni\", \"Co\", \"Fe\"],\n    \"particle_size\": [1, 4, 13],\n    \"vacancy_fraction\": [0.0, 0.05, 0.1]\n}\n</code></pre>"},{"location":"api/workflows/#methods_6","title":"Methods","text":""},{"location":"api/workflows/#generate_all","title":"generate_all","text":"<pre><code>generate_all() -&gt; List[Dict]\n</code></pre> <p>Generate all parameter combinations.</p>"},{"location":"api/workflows/#setup_all","title":"setup_all","text":"<pre><code>setup_all() -&gt; Dict[str, Dict]\n</code></pre> <p>Set up calculations for all configurations.</p>"},{"location":"api/workflows/#parse_all","title":"parse_all","text":"<pre><code>parse_all() -&gt; List[Dict]\n</code></pre> <p>Parse all results.</p>"},{"location":"api/workflows/#get_best_result","title":"get_best_result","text":"<pre><code>get_best_result(\n    metric: str = \"exsolution_energy\",\n    minimize: bool = True\n) -&gt; Dict\n</code></pre> <p>Get best result by specified metric.</p> <p>Example:</p> <pre><code>screening = ExsolutionScreeningWorkflow(\n    base_structure=surface,\n    parameter_space={\n        \"metal\": [\"Ni\", \"Co\", \"Fe\"],\n        \"particle_size\": [1, 13],\n        \"vacancy_fraction\": [0.05, 0.1],\n    },\n    work_dir=\"./exsolution_screening\",\n)\n\nscreening.generate_all()\nscreening.setup_all()\n\n# After calculations:\nresults = screening.parse_all()\nbest = screening.get_best_result()\nprint(f\"Best: {best['config']}\")\n</code></pre>"},{"location":"api/workflows/#run_exsolution_study","title":"run_exsolution_study","text":"<p>Convenience function for quick exsolution study setup.</p> <pre><code>from nh3sofc.workflows import run_exsolution_study\n\nresult = run_exsolution_study(\n    atoms=surface,\n    work_dir=\"./exsolution\",\n    metal=\"Ni\",\n    particle_size=13,\n    calculator=\"vasp\"\n)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides for common workflows in NH3-SOFC research.</p>"},{"location":"tutorials/#getting-started","title":"Getting Started","text":"Tutorial Description Time Surface Building Create surfaces and oxynitride defects 15 min Adsorbate Placement 6 methods for placing molecules 20 min VASP Calculations Generate inputs, parse outputs 25 min"},{"location":"tutorials/#nh3-decomposition","title":"NH3 Decomposition","text":"Tutorial Description Time Decomposition Pathway Complete NH3\u2192N2+H2 workflow 30 min NEB Transition States Find reaction barriers 25 min Frequency &amp; Thermochemistry ZPE, entropy, Gibbs energy 20 min"},{"location":"tutorials/#analysis-theory","title":"Analysis &amp; Theory","text":"Tutorial Description Time Theoretical Framework D-band analysis, BEP relations, energy span model 30 min Microkinetic Modeling TOF and steady-state analysis 35 min Surface Comparison Ranking catalysts with volcano plots 20 min"},{"location":"tutorials/#advanced-topics","title":"Advanced Topics","text":"Tutorial Description Time Doped Ceria (GDC/SDC/PDC) Acceptor-doped ceria with O vacancies 25 min Exsolution Simulation Metal nanoparticle exsolution from perovskites 35 min High-Throughput Screening Systematic parameter scans 30 min MACE ML Force Fields Training and active learning 40 min"},{"location":"tutorials/#workflow-diagrams","title":"Workflow Diagrams","text":""},{"location":"tutorials/#complete-nh3-decomposition-study","title":"Complete NH3 Decomposition Study","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Build Surface  \u2502\n\u2502  from Bulk CIF  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Create Defects  \u2502\n\u2502 (O\u2192N, vacancies)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Place NH3      \u2502\n\u2502  (6 methods)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Relax Structure \u2502\n\u2502  (VASP/MACE)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Decomposition   \u2502\n\u2502  Intermediates  \u2502\n\u2502  NH2*, NH*, N*  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  NEB  \u2502 \u2502  Freq  \u2502\n\u2502  TS   \u2502 \u2502  ZPE   \u2502\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n    \u2502         \u2502\n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Analysis     \u2502\n\u2502 \u2022 Energy profile\u2502\n\u2502 \u2022 RDS/barriers  \u2502\n\u2502 \u2022 Gibbs \u0394G      \u2502\n\u2502 \u2022 Microkinetics \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tutorials/#calculation-types","title":"Calculation Types","text":"Calc Type VASP INCAR Purpose <code>relax</code> IBRION=2, NSW=300 Geometry optimization <code>static</code> NSW=0 Single-point energy <code>frequency</code> IBRION=5, NFREE=2 Vibrational modes <code>neb</code> IMAGES=5, LCLIMB=T Transition states <code>md</code> IBRION=0, SMASS=0 Molecular dynamics"},{"location":"tutorials/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/#1-start-simple","title":"1. Start Simple","text":"<ul> <li>Begin with a small test system (2x2 surface)</li> <li>Use lower ENCUT (400 eV) for initial tests</li> <li>Verify convergence before production runs</li> </ul>"},{"location":"tutorials/#2-systematic-studies","title":"2. Systematic Studies","text":"<ul> <li>Use consistent parameters across comparisons</li> <li>Save all structures to database</li> <li>Document calculation settings</li> </ul>"},{"location":"tutorials/#3-validation","title":"3. Validation","text":"<ul> <li>Compare with literature values for benchmark systems</li> <li>Check for imaginary frequencies after relaxation</li> <li>Verify energy convergence with k-points and ENCUT</li> </ul>"},{"location":"tutorials/#example-scripts","title":"Example Scripts","text":"<p>All tutorials include complete, runnable code. Download example scripts:</p> <pre><code># Clone with examples\ngit clone https://github.com/lizhenzhupearl/nh3sofc.git\ncd NH3SOFC/examples\n</code></pre>"},{"location":"tutorials/#video-tutorials","title":"Video Tutorials","text":"<p>(Coming soon)</p>"},{"location":"tutorials/adsorbate_placement/","title":"Tutorial: Adsorbate Placement","text":"<p>This tutorial covers 6 different methods for placing adsorbate molecules on surfaces.</p>"},{"location":"tutorials/adsorbate_placement/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the 6 adsorbate placement methods</li> <li>Generate multiple adsorption configurations with proper rotation sampling</li> <li>Filter and select configurations for calculations</li> </ul>"},{"location":"tutorials/adsorbate_placement/#the-6-placement-methods","title":"The 6 Placement Methods","text":"Method Use Case <code>add_simple()</code> Manual placement at known position <code>add_random()</code> Exploratory sampling <code>add_grid()</code> Systematic coverage <code>add_on_site()</code> Specific atomic sites (most physically meaningful) <code>add_with_collision()</code> Safe random placement <code>add_catkit()</code> Automated site detection via CatKit"},{"location":"tutorials/adsorbate_placement/#setup","title":"Setup","text":"<pre><code>from ase.io import read\nfrom nh3sofc.structure import AdsorbatePlacer\n\n# Load your surface (POSCAR or CIF format recommended)\nsurface = read(\"work/surfaces/LaVO3_001/surface.vasp\", format=\"vasp\")\n\n# Create placer\nplacer = AdsorbatePlacer(surface)\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#rotation-sampling","title":"Rotation Sampling","text":"<p>All placement methods (except <code>add_simple()</code>) apply uniform random rotations on SO(3) for unbiased molecular orientations. This uses proper spherical sampling:</p> <pre><code># Internally, rotations use: \u03b2 = arccos(1 - 2u) for uniform coverage\n# This avoids clustering near the \"poles\" that occurs with naive sampling\n</code></pre> <p>For reproducibility, always set <code>random_seed</code>:</p> <pre><code>configs_a = placer.add_random(\"NH3\", n_configs=10, random_seed=42)\nconfigs_b = placer.add_random(\"NH3\", n_configs=10, random_seed=42)\n# configs_a and configs_b are identical\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#method-1-simple-manual","title":"Method 1: Simple (Manual)","text":"<p>Place at specific (x, y) coordinates with optional rotation.</p> <pre><code># Place NH3 at position (2.5, 2.5) \u00c5, 2.0 \u00c5 above surface\nresult = placer.add_simple(\n    adsorbate=\"NH3\",\n    position=(2.5, 2.5),\n    height=2.0,\n    rotation=(0, 0, 0)  # Euler angles (alpha, beta, gamma) in radians\n)\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#method-2-random","title":"Method 2: Random","text":"<p>Generate random configurations with uniform rotation sampling.</p> <pre><code># Generate 10 random configurations\nconfigs = placer.add_random(\n    adsorbate=\"NH3\",\n    n_configs=10,\n    height=2.0,\n    random_seed=42  # Reproducibility\n)\n\nprint(f\"Generated {len(configs)} configurations\")\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#method-3-grid","title":"Method 3: Grid","text":"<p>Systematic grid-based placement with multiple orientations per point.</p> <pre><code># 3x3 grid with 4 orientations per point\nconfigs = placer.add_grid(\n    adsorbate=\"NH3\",\n    grid_size=(3, 3),\n    orientations=4,   # 4 random orientations per grid point\n    height=2.0,\n    random_seed=42\n)\n# Returns 3 \u00d7 3 \u00d7 4 = 36 configurations\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#method-4-on-site-atomic-sites","title":"Method 4: On-Site (Atomic Sites)","text":"<p>Place on specific atomic sites. This is the most physically meaningful method.</p> <p>Important: Only atoms in the top bilayer (within <code>layer_tolerance</code> of the topmost atom) are considered as surface sites. Bulk atoms are automatically excluded.</p> <pre><code># On top of La and V atoms in the surface bilayer\nconfigs = placer.add_on_site(\n    adsorbate=\"NH3\",\n    site_type=\"ontop\",\n    atom_types=[\"La\", \"V\"],\n    n_orientations=5,     # 5 orientations per site\n    height=2.0,\n    layer_tolerance=2.0,  # Top 2 \u00c5 = surface bilayer (default)\n    random_seed=42\n)\n\n# For only the topmost layer (e.g., VO2 termination only)\nconfigs = placer.add_on_site(\n    adsorbate=\"NH3\",\n    site_type=\"ontop\",\n    atom_types=[\"V\"],\n    n_orientations=3,\n    layer_tolerance=1.0,  # Only topmost ~1 \u00c5\n    random_seed=42\n)\n\n# Bridge sites (requires CatKit or uses geometric approximation)\nconfigs = placer.add_on_site(\n    adsorbate=\"H\",\n    site_type=\"bridge\",\n    atom_types=[\"O\"],\n    height=1.0\n)\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#surface-detection","title":"Surface Detection","text":"<p>The <code>layer_tolerance</code> parameter controls which atoms are considered \"on the surface\":</p> <code>layer_tolerance</code> Effect 1.0 \u00c5 Topmost atomic layer only 2.0 \u00c5 (default) Top bilayer (e.g., VO2 + LaO in perovskites) 3.0 \u00c5 Top 2-3 layers"},{"location":"tutorials/adsorbate_placement/#method-5-collision-aware","title":"Method 5: Collision-Aware","text":"<p>Random placement with minimum distance checking.</p> <pre><code># Ensure no atoms closer than 2.0 \u00c5\nconfigs = placer.add_with_collision(\n    adsorbate=\"NH3\",\n    n_configs=10,\n    min_distance=2.0,\n    height=2.0,\n    random_seed=42\n)\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#method-6-catkit-integration","title":"Method 6: CatKit Integration","text":"<p>Use CatKit for automated site detection with rotation support.</p> <pre><code># Requires catkit installation: pip install catkit\nconfigs = placer.add_catkit(\n    adsorbate=\"NH3\",\n    site_type=\"ontop\",      # or \"bridge\", \"hollow\", \"4fold\"\n    n_orientations=3,       # 3 orientations per site\n    random_seed=42\n)\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#supported-adsorbates","title":"Supported Adsorbates","text":"Name Formula Default Height <code>\"NH3\"</code> NH\u2083 2.0 \u00c5 <code>\"NH2\"</code> NH\u2082 1.8 \u00c5 <code>\"NH\"</code> NH 1.5 \u00c5 <code>\"N\"</code> N 1.2 \u00c5 <code>\"H\"</code> H 1.0 \u00c5 <code>\"H2\"</code> H\u2082 2.5 \u00c5 <code>\"H2O\"</code> H\u2082O 2.0 \u00c5 <code>\"O\"</code> O 1.2 \u00c5 <code>\"OH\"</code> OH 1.5 \u00c5"},{"location":"tutorials/adsorbate_placement/#filtering-configurations","title":"Filtering Configurations","text":"<p>Remove duplicate configurations based on adsorbate-only RMSD:</p> <pre><code>from nh3sofc.structure.adsorbates import filter_unique_configs, save_configs\n\n# Remove similar configurations (RMSD &lt; 0.5 \u00c5 on adsorbate atoms only)\nunique_configs = filter_unique_configs(\n    configs,\n    threshold=0.5,        # RMSD threshold in Angstroms\n    n_slab_atoms=len(surface)  # Number of atoms in the original slab\n)\nprint(f\"Filtered {len(configs)} \u2192 {len(unique_configs)} unique\")\n\n# Save to files\npaths = save_configs(unique_configs, output_dir=\"./configs\", format=\"vasp\")\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#why-n_slab_atoms","title":"Why <code>n_slab_atoms</code>?","text":"<p>When adsorbates are added, they are appended to the end of the atom list:</p> <pre><code>Structure: [slab_0, slab_1, ..., slab_N-1, adsorbate_0, adsorbate_1, ...]\n            |&lt;------ slab (N atoms) -----&gt;|&lt;---- adsorbate (M atoms) ---&gt;|\n</code></pre> <p>The <code>n_slab_atoms</code> parameter tells the filter where the adsorbate atoms start, so it only compares those atoms (not the identical slab atoms).</p>"},{"location":"tutorials/adsorbate_placement/#getting-site-information","title":"Getting Site Information","text":"<p>Inspect available adsorption sites before placement:</p> <pre><code>info = placer.get_site_info(layer_tolerance=2.0)\n\nprint(f\"Surface atoms: {info['n_surface_atoms']}\")\nprint(f\"By element: {info['element_counts']}\")\n# Output: {'La': 1, 'V': 1, 'O': 3}\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#complete-example","title":"Complete Example","text":"<pre><code>from ase.io import read\nfrom nh3sofc.structure import AdsorbatePlacer\nfrom nh3sofc.structure.adsorbates import filter_unique_configs, save_configs\n\n# Load surface\nsurface = read(\"work/surfaces/LaVO3_001/surface.vasp\", format=\"vasp\")\nn_slab_atoms = len(surface)  # Remember slab size for filtering\nplacer = AdsorbatePlacer(surface)\n\n# Check available sites\ninfo = placer.get_site_info()\nprint(f\"Surface sites: {info['element_counts']}\")\n\n# Generate configurations on La and V sites\nconfigs = placer.add_on_site(\n    \"NH3\",\n    atom_types=[\"La\", \"V\"],\n    n_orientations=5,\n    random_seed=42\n)\nprint(f\"Generated: {len(configs)} configurations\")\n\n# Filter duplicates (adsorbate-only RMSD)\nunique = filter_unique_configs(configs, threshold=0.5, n_slab_atoms=n_slab_atoms)\nprint(f\"Unique: {len(unique)} configurations\")\n\n# Save for VASP calculations\npaths = save_configs(unique, \"work/adsorbates/NH3_on_LaVO3\", format=\"vasp\")\n</code></pre>"},{"location":"tutorials/adsorbate_placement/#next-steps","title":"Next Steps","text":"<ul> <li>VASP Calculations - Optimize the configurations</li> <li>Decomposition Pathway - Study NH3 decomposition</li> </ul>"},{"location":"tutorials/decomposition/","title":"Tutorial: NH3 Decomposition Pathway","text":"<p>This tutorial walks through a complete workflow for studying the NH3 decomposition reaction on a catalyst surface.</p>"},{"location":"tutorials/decomposition/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this tutorial, you will be able to:</p> <ul> <li>Generate decomposition intermediate configurations</li> <li>Set up batch calculations for all steps</li> <li>Calculate energy profiles</li> <li>Identify the rate-determining step</li> </ul>"},{"location":"tutorials/decomposition/#background","title":"Background","text":"<p>NH3 decomposition follows the co-adsorption pathway:</p> <pre><code>NH3* \u2192 NH2* + H* \u2192 NH* + 2H* \u2192 N* + 3H* \u2192 \u00bdN2(g) + 3/2H2(g)\n</code></pre> <p>Each step involves dissociating one N-H bond and placing H on the surface.</p>"},{"location":"tutorials/decomposition/#step-1-prepare-the-initial-structure","title":"Step 1: Prepare the Initial Structure","text":"<p>First, we need an optimized NH3 on surface structure:</p> <pre><code>from ase.io import read\nfrom nh3sofc.structure import AdsorbatePlacer\nfrom nh3sofc import write_poscar\n\n# Load your relaxed surface (POSCAR format)\nsurface = read(\"work/surfaces/LaVO3_001/relaxed.vasp\", format=\"vasp\")\n\n# Add NH3\nplacer = AdsorbatePlacer(surface)\nnh3_configs = placer.add_on_site(\"NH3\", site_type=\"ontop\", height=2.0)\n\n# Use the first configuration\nnh3_on_slab = nh3_configs[0]\n\n# Save initial NH3/surface structure (atoms sorted by element automatically)\nwork_dir = \"work/decomposition/LaVO3_001\"\nwrite_poscar(nh3_on_slab, f\"{work_dir}/NH3_initial.vasp\")\n</code></pre> <p>Important: For accurate decomposition energetics, the initial NH3* structure should be fully optimized.</p>"},{"location":"tutorials/decomposition/#step-2-generate-decomposition-intermediates","title":"Step 2: Generate Decomposition Intermediates","text":""},{"location":"tutorials/decomposition/#using-decompositionbuilder","title":"Using DecompositionBuilder","text":"<pre><code>from nh3sofc.structure import DecompositionBuilder\n\n# Initialize builder with relaxed NH3/surface\ndecomp = DecompositionBuilder(nh3_on_slab)\n\n# Step 1: NH3* \u2192 NH2* + H*\nnh2_h_configs = decomp.create_NH2_H_configs(\n    n_configs=10,  # Generate 10 configurations\n    h_sites=\"auto\" # Automatically find H binding sites\n)\nprint(f\"NH2+H configurations: {len(nh2_h_configs)}\")\n\n# Step 2: NH2* + H* \u2192 NH* + 2H*\nnh_2h_configs = decomp.create_NH_2H_configs(n_configs=10)\nprint(f\"NH+2H configurations: {len(nh_2h_configs)}\")\n\n# Step 3: NH* + 2H* \u2192 N* + 3H*\nn_3h_configs = decomp.create_N_3H_configs(n_configs=5)\nprint(f\"N+3H configurations: {len(n_3h_configs)}\")\n</code></pre>"},{"location":"tutorials/decomposition/#understanding-configuration-generation","title":"Understanding Configuration Generation","text":"<p>For NH2+H step: - One H is removed from NH3 - The H is placed at various surface sites (ontop, bridge, hollow) - Distance constraints ensure physical configurations</p> <pre><code># Customize H placement\nnh2_h_custom = decomp.create_NH2_H_configs(\n    n_configs=10,\n    h_height=1.0,           # Height above surface\n    min_h_distance=1.5,     # Min distance from N\n    max_h_distance=4.0,     # Max distance from N\n    random_seed=42          # Reproducibility\n)\n</code></pre>"},{"location":"tutorials/decomposition/#step-3-set-up-calculations","title":"Step 3: Set Up Calculations","text":""},{"location":"tutorials/decomposition/#using-decompositionworkflow","title":"Using DecompositionWorkflow","text":"<pre><code>from nh3sofc.workflows import DecompositionWorkflow\n\nworkflow = DecompositionWorkflow(\n    nh3_on_slab=nh3_on_slab,\n    work_dir=\"./decomposition_study\",\n    n_configs_per_step=5,\n    calculator=\"vasp\",\n    # VASP parameters\n    encut=520,\n    kspacing=0.03,\n    hubbard_u={\"V\": 3.25},\n    vdw=\"D3BJ\",\n    # PBS parameters\n    nodes=1,\n    ppn=24,\n    walltime=\"24:00:00\",\n)\n\n# Generate configurations and set up all calculations\nfile_paths = workflow.setup()\n\nprint(\"Calculation directories created:\")\nfor step, paths in file_paths.items():\n    print(f\"  {step}: {len(paths)} configurations\")\n</code></pre>"},{"location":"tutorials/decomposition/#directory-structure","title":"Directory Structure","text":"<pre><code>work/decomposition/LaVO3_001/\n\u251c\u2500\u2500 initial_configs/          # Initial structures (POSCAR format)\n\u2502   \u251c\u2500\u2500 POSCAR_NH3\n\u2502   \u251c\u2500\u2500 POSCAR_NH2_H_000\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 NH3/                      # NH3* calculations\n\u2502   \u2514\u2500\u2500 config_000/\n\u2502       \u251c\u2500\u2500 INCAR\n\u2502       \u251c\u2500\u2500 KPOINTS\n\u2502       \u251c\u2500\u2500 POSCAR\n\u2502       \u251c\u2500\u2500 POTCAR\n\u2502       \u2514\u2500\u2500 run.pbs\n\u251c\u2500\u2500 NH2_H/                    # NH2* + H* calculations\n\u2502   \u251c\u2500\u2500 config_000/\n\u2502   \u251c\u2500\u2500 config_001/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 NH_2H/                    # NH* + 2H* calculations\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 N_3H/                     # N* + 3H* calculations\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"tutorials/decomposition/#submit-jobs","title":"Submit Jobs","text":"<pre><code># Submit all jobs\ncd decomposition_study\nfor dir in */config_*/; do\n    cd $dir\n    qsub run.pbs\n    cd ../..\ndone\n</code></pre>"},{"location":"tutorials/decomposition/#step-4-parse-results","title":"Step 4: Parse Results","text":"<p>After calculations complete:</p> <pre><code># Parse all results\nresults = workflow.parse_results()\n\n# Check status\nstatus = workflow.get_status()\nfor step, s in status.items():\n    print(f\"{step}: {s['completed']}/{sum(s.values())} completed\")\n\n# Get lowest energies\nlowest = workflow.get_lowest_energies()\nfor step, energy in lowest.items():\n    print(f\"{step}: {energy:.4f} eV\")\n</code></pre>"},{"location":"tutorials/decomposition/#step-5-calculate-energy-profile","title":"Step 5: Calculate Energy Profile","text":""},{"location":"tutorials/decomposition/#relative-energies","title":"Relative Energies","text":"<pre><code># Get energy profile relative to NH3*\nprofile = workflow.get_energy_profile(reference=\"NH3\")\n\nprint(\"\\nEnergy Profile (vs NH3*):\")\nfor step, dE in profile.items():\n    print(f\"  {step:10s}: {dE:+.3f} eV\")\n</code></pre>"},{"location":"tutorials/decomposition/#reaction-energies","title":"Reaction Energies","text":"<pre><code># Step-by-step reaction energies\nreactions = workflow.get_reaction_energies()\n\nprint(\"\\nReaction Energies:\")\nfor name, dE in reactions.items():\n    sign = \"exothermic\" if dE &lt; 0 else \"endothermic\"\n    print(f\"  {name:20s}: {dE:+.3f} eV ({sign})\")\n</code></pre>"},{"location":"tutorials/decomposition/#plotting","title":"Plotting","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Prepare data\nsteps = list(profile.keys())\nenergies = [profile[s] for s in steps]\n\n# Create energy diagram\nfig, ax = plt.subplots(figsize=(10, 6))\n\nx = np.arange(len(steps))\nax.step(x, energies, where='mid', linewidth=2, color='blue')\nax.scatter(x, energies, s=100, zorder=5)\n\n# Add labels\nax.set_xticks(x)\nax.set_xticklabels(steps, rotation=45, ha='right')\nax.set_ylabel('Energy (eV)', fontsize=12)\nax.set_title('NH3 Decomposition Energy Profile', fontsize=14)\nax.axhline(0, color='gray', linestyle='--', alpha=0.5)\n\n# Annotate reaction energies\nfor i in range(len(steps)-1):\n    dE = energies[i+1] - energies[i]\n    color = 'green' if dE &lt; 0 else 'red'\n    ax.annotate(f'{dE:+.2f}', xy=(i+0.5, (energies[i]+energies[i+1])/2),\n                fontsize=10, color=color, ha='center')\n\nplt.tight_layout()\nplt.savefig('energy_profile.png', dpi=150)\n</code></pre>"},{"location":"tutorials/decomposition/#step-6-identify-rate-determining-step","title":"Step 6: Identify Rate-Determining Step","text":""},{"location":"tutorials/decomposition/#using-rds-analyzer","title":"Using RDS Analyzer","text":"<pre><code>from nh3sofc.analysis import RDSAnalyzer\n\nanalyzer = RDSAnalyzer()\nanalyzer.set_pathway(profile)\n\n# Thermodynamic RDS (highest \u0394E step)\nrds_step, rds_energy = analyzer.find_rds_thermodynamic()\nprint(f\"Thermodynamic RDS: {rds_step} (\u0394E = {rds_energy:.3f} eV)\")\n\n# BEP-estimated barriers\nbep_rds, bep_barrier = analyzer.find_rds_bep()\nprint(f\"BEP-estimated RDS: {bep_rds} (E_a \u2248 {bep_barrier:.3f} eV)\")\n\n# Energy span model\nspan, tdts, tdi = analyzer.find_rds_energy_span()\nprint(f\"Energy span: {span:.3f} eV\")\nprint(f\"  TDTS: {tdts}\")\nprint(f\"  TDI: {tdi}\")\n</code></pre>"},{"location":"tutorials/decomposition/#full-analysis-report","title":"Full Analysis Report","text":"<pre><code>analyzer.print_analysis()\n</code></pre> <p>Output: <pre><code>============================================================\nRate-Determining Step Analysis\n============================================================\n\n1. Thermodynamic RDS (highest \u0394E):\n   Step: NH3*\u2192NH2*+H*\n   \u0394E = 0.800 eV\n\n2. BEP-estimated RDS (highest E_a):\n   Step: NH3*\u2192NH2*+H*\n   E_a \u2248 1.646 eV\n\n3. Energy Span Model:\n   Energy span: 1.500 eV\n   TDTS: TS_NH3*_NH2*+H*\n   TDI: NH3*\n\n4. Step-by-step barriers:\n   NH3*\u2192NH2*+H*: E_a = 1.646 eV (BEP), \u0394E = 0.800 eV\n   NH2*+H*\u2192NH*+2H*: E_a = 1.558 eV (BEP), \u0394E = 0.700 eV\n   NH*+2H*\u2192N*+3H*: E_a = 0.515 eV (BEP), \u0394E = -0.300 eV\n============================================================\n</code></pre></p>"},{"location":"tutorials/decomposition/#step-7-compare-with-other-surfaces","title":"Step 7: Compare with Other Surfaces","text":"<pre><code>from nh3sofc.analysis import SurfaceComparator\n\n# Collect results from multiple surfaces\nsurfaces = {\n    'LaO-term': workflow.get_energy_profile(),\n    # Add more surfaces...\n}\n\ncomparator = SurfaceComparator(surfaces)\nranking = comparator.rank_by_energy_span()\n\nprint(\"\\nSurface Ranking (by activity):\")\nfor i, (name, span) in enumerate(ranking, 1):\n    print(f\"  {i}. {name}: \u03b4E = {span:.3f} eV\")\n</code></pre>"},{"location":"tutorials/decomposition/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/decomposition/#1-configuration-sampling","title":"1. Configuration Sampling","text":"<ul> <li>Generate more configs than needed, then filter</li> <li>Use RMSD filtering to remove duplicates</li> <li>Include diverse H positions</li> </ul>"},{"location":"tutorials/decomposition/#2-convergence-checks","title":"2. Convergence Checks","text":"<ul> <li>Verify all calculations converged</li> <li>Check for imaginary frequencies (optimize further if found)</li> <li>Ensure forces are below threshold</li> </ul>"},{"location":"tutorials/decomposition/#3-thermochemistry","title":"3. Thermochemistry","text":"<ul> <li>Include ZPE corrections for accurate energetics</li> <li>Consider temperature effects for reaction conditions</li> </ul>"},{"location":"tutorials/decomposition/#next-steps","title":"Next Steps","text":"<ul> <li>NEB Calculations - Calculate actual transition state barriers</li> <li>Frequency Calculations - Add thermodynamic corrections</li> <li>Microkinetic Modeling - Predict reaction rates</li> </ul>"},{"location":"tutorials/decomposition/#complete-script","title":"Complete Script","text":"<pre><code>\"\"\"Complete NH3 decomposition workflow.\"\"\"\n\nfrom ase.io import read\nfrom nh3sofc.workflows import DecompositionWorkflow\nfrom nh3sofc.analysis import RDSAnalyzer, SurfaceComparator\n\n# Work directory for this study\nwork_dir = \"work/decomposition/LaVO3_001_LaO\"\n\n# 1. Load relaxed NH3/surface (from previous calculation)\nnh3_on_slab = read(\"work/adsorbates/NH3_on_LaVO3_001/relaxed.vasp\", format=\"vasp\")\n\n# 2. Set up workflow\nworkflow = DecompositionWorkflow(\n    nh3_on_slab=nh3_on_slab,\n    work_dir=work_dir,\n    n_configs_per_step=5,\n    encut=520,\n    hubbard_u={\"V\": 3.25},\n    vdw=\"D3BJ\",\n)\n\n# 3. Setup calculations (generates POSCAR files with atoms sorted by element)\nworkflow.setup()\n\n# 4. After calculations complete...\n# results = workflow.parse_results()\n\n# 5. Analyze\n# profile = workflow.get_energy_profile()\n# workflow.print_summary()\n</code></pre>"},{"location":"tutorials/doped_fluorite/","title":"Doped Fluorite Materials Tutorial (GDC, SDC, YSZ, ScSZ)","text":"<p>This tutorial covers creating acceptor-doped fluorite oxide structures for solid oxide fuel cell applications.</p>"},{"location":"tutorials/doped_fluorite/#overview","title":"Overview","text":"<p>Doped fluorite oxides are crucial for ionic conductivity in SOFCs:</p>"},{"location":"tutorials/doped_fluorite/#ceria-based-ceo2","title":"Ceria-Based (CeO2)","text":"<ul> <li>GDC: Gadolinium-doped ceria (Ce\u2081\u208b\u2093Gd\u2093O\u2082\u208b\u03b4)</li> <li>SDC: Samarium-doped ceria (Ce\u2081\u208b\u2093Sm\u2093O\u2082\u208b\u03b4)</li> <li>PDC: Praseodymium-doped ceria (Ce\u2081\u208b\u2093Pr\u2093O\u2082\u208b\u03b4)</li> <li>YDC: Yttrium-doped ceria (Ce\u2081\u208b\u2093Y\u2093O\u2082\u208b\u03b4)</li> </ul>"},{"location":"tutorials/doped_fluorite/#zirconia-based-zro2","title":"Zirconia-Based (ZrO2)","text":"<ul> <li>YSZ: Yttria-stabilized zirconia (Zr\u2081\u208b\u2093Y\u2093O\u2082\u208b\u03b4)</li> <li>ScSZ: Scandia-stabilized zirconia (Zr\u2081\u208b\u2093Sc\u2093O\u2082\u208b\u03b4)</li> <li>CSZ: Calcia-stabilized zirconia (Zr\u2081\u208b\u2093Ca\u2093O\u2082\u208b\u03b4)</li> <li>MSZ: Magnesia-stabilized zirconia (Zr\u2081\u208b\u2093Mg\u2093O\u2082\u208b\u03b4)</li> </ul>"},{"location":"tutorials/doped_fluorite/#chemistry","title":"Chemistry","text":"<p>Acceptor dopants substitute M\u2074\u207a sites (Ce\u2074\u207a, Zr\u2074\u207a). Charge compensation requires oxygen vacancy formation:</p> <p>Trivalent dopants (Gd\u00b3\u207a, Y\u00b3\u207a, Sc\u00b3\u207a): <pre><code>2 M\u2074\u207a \u2192 2 D\u00b3\u207a + V_O^{2+}  (2:1 dopant:vacancy ratio)\n</code></pre></p> <p>Divalent dopants (Ca\u00b2\u207a, Mg\u00b2\u207a): <pre><code>M\u2074\u207a \u2192 D\u00b2\u207a + V_O^{2+}  (1:1 dopant:vacancy ratio)\n</code></pre></p> <p>Odd Number of Trivalent Dopants</p> <p>When the number of trivalent dopants is odd (e.g., 9 Gd\u00b3\u207a), the ideal vacancy count would be non-integer (4.5). The code uses floor division, creating 4 vacancies in this case.</p> <p>The uncompensated negative charge physically corresponds to M\u2074\u207a \u2192 M\u00b3\u207a reduction (small polaron formation), which is realistic for reducible oxides like CeO\u2082.</p>"},{"location":"tutorials/doped_fluorite/#basic-usage","title":"Basic Usage","text":""},{"location":"tutorials/doped_fluorite/#creating-gd-doped-ceria-gdc","title":"Creating Gd-Doped Ceria (GDC)","text":"<pre><code>from ase.build import bulk\nfrom nh3sofc.structure import DopantBuilder\n\n# Create CeO2 supercell\nceo2 = bulk('CeO2', 'fluorite', a=5.41)\nceo2_slab = ceo2 * (2, 2, 2)  # 8 Ce, 16 O\n\n# Initialize builder\nbuilder = DopantBuilder(ceo2_slab)\n\n# Create 10% Gd-doped ceria\ngdc = builder.create_doped_structure(\n    dopant=\"Gd\",\n    dopant_fraction=0.10,  # 10% of Ce \u2192 Gd\n    random_seed=42,\n)\n\n# Check composition\nsymbols = gdc.get_chemical_symbols()\nn_gd = symbols.count(\"Gd\")\nn_ce = symbols.count(\"Ce\")\nn_o = symbols.count(\"O\")\n\nprint(f\"Gd atoms: {n_gd}\")        # ~1 (10% of 8)\nprint(f\"Ce atoms: {n_ce}\")        # ~7\nprint(f\"O atoms: {n_o}\")          # 16 - vacancies\nprint(f\"Charge balanced: 2 Gd \u2192 1 vacancy\")\n</code></pre>"},{"location":"tutorials/doped_fluorite/#creating-yttria-stabilized-zirconia-ysz","title":"Creating Yttria-Stabilized Zirconia (YSZ)","text":"<pre><code>from ase.build import bulk\nfrom nh3sofc.structure import DopantBuilder\n\n# Create ZrO2 supercell (cubic fluorite phase)\nzro2 = bulk('ZrO2', 'fluorite', a=5.07)\nzro2_slab = zro2 * (2, 2, 2)  # 8 Zr, 16 O\n\n# Initialize builder\nbuilder = DopantBuilder(zro2_slab)\n\n# Create 8% Y-doped zirconia (8YSZ)\nysz = builder.create_doped_structure(\n    dopant=\"Y\",\n    dopant_fraction=0.08,\n    host_cation=\"Zr\",  # Specify the host cation\n    random_seed=42,\n)\n\n# Check composition\nsymbols = ysz.get_chemical_symbols()\nprint(f\"Y atoms: {symbols.count('Y')}\")\nprint(f\"Zr atoms: {symbols.count('Zr')}\")\n</code></pre>"},{"location":"tutorials/doped_fluorite/#creating-scandia-stabilized-zirconia-scsz","title":"Creating Scandia-Stabilized Zirconia (ScSZ)","text":"<pre><code># ScSZ has the highest ionic conductivity among zirconia-based electrolytes\nscsz = builder.create_doped_structure(\n    dopant=\"Sc\",\n    dopant_fraction=0.10,  # 10 mol% Sc2O3\n    host_cation=\"Zr\",\n    random_seed=42,\n)\n</code></pre>"},{"location":"tutorials/doped_fluorite/#creating-calcia-stabilized-zirconia-csz","title":"Creating Calcia-Stabilized Zirconia (CSZ)","text":"<pre><code># Divalent dopants have 1:1 dopant:vacancy ratio\ncsz = builder.create_doped_structure(\n    dopant=\"Ca\",\n    dopant_fraction=0.15,\n    host_cation=\"Zr\",\n    random_seed=42,\n)\n\n# 1 Ca\u00b2\u207a \u2192 1 vacancy (not 2:1 like trivalent dopants)\n</code></pre>"},{"location":"tutorials/doped_fluorite/#using-dopedfluoritestructure","title":"Using DopedFluoriteStructure","text":"<p>The <code>DopedFluoriteStructure</code> class tracks dopant metadata:</p> <pre><code>from nh3sofc.structure import DopedFluoriteStructure\n\n# Ceria-based (GDC)\ngdc = DopedFluoriteStructure.from_ceria(\n    ceo2_slab,\n    dopant=\"Gd\",\n    dopant_fraction=0.10,\n    random_seed=42,\n)\nprint(gdc)  # DopedFluoriteStructure(GDC, Gd_frac=10.0%, n_vac=0)\nprint(gdc.get_material_name())  # \"GDC\"\n\n# Zirconia-based (YSZ)\nysz = DopedFluoriteStructure.from_zirconia(\n    zro2_slab,\n    dopant=\"Y\",\n    dopant_fraction=0.08,\n    random_seed=42,\n)\nprint(ysz.get_material_name())  # \"YSZ\"\nprint(ysz.host_cation)  # \"Zr\"\n\n# General factory (works with any host)\ndoped = DopedFluoriteStructure.from_parent(\n    parent_structure,\n    dopant=\"Sc\",\n    dopant_fraction=0.10,\n    host_cation=\"Zr\",\n    random_seed=42,\n)\n</code></pre> <p>Backwards Compatibility</p> <p><code>DopedCeriaStructure</code> is still available as a deprecated alias. Existing code will continue to work but will show deprecation warnings.</p>"},{"location":"tutorials/doped_fluorite/#placement-strategies","title":"Placement Strategies","text":"<p>Control where dopants and vacancies are placed:</p>"},{"location":"tutorials/doped_fluorite/#random-placement-default","title":"Random Placement (Default)","text":"<p>Uniform random distribution - represents high-temperature equilibrium:</p> <pre><code>gdc_random = builder.create_doped_structure(\n    dopant=\"Gd\",\n    dopant_fraction=0.20,\n    dopant_placement=\"random\",\n    vacancy_placement=\"random\",\n)\n</code></pre>"},{"location":"tutorials/doped_fluorite/#surface-preferring-placement","title":"Surface-Preferring Placement","text":"<p>For surface-segregated dopants or vacancies:</p> <pre><code>gdc_surface = builder.create_doped_structure(\n    dopant=\"Gd\",\n    dopant_fraction=0.20,\n    dopant_placement=\"surface\",\n    dopant_preference=0.8,  # Strong surface bias\n    vacancy_placement=\"surface\",\n    vacancy_preference=0.7,\n)\n</code></pre>"},{"location":"tutorials/doped_fluorite/#associated-dopant-vacancy-pairs","title":"Associated Dopant-Vacancy Pairs","text":"<p>Vacancies near dopants (low-temperature regime):</p> <pre><code>gdc_associated = builder.create_doped_structure(\n    dopant=\"Gd\",\n    dopant_fraction=0.20,\n    vacancy_placement=\"near_dopant\",\n    vacancy_preference=0.9,  # Strong association\n)\n</code></pre>"},{"location":"tutorials/doped_fluorite/#bulk-preferring-placement","title":"Bulk-Preferring Placement","text":"<p>For bulk-segregated defects:</p> <pre><code>gdc_bulk = builder.create_doped_structure(\n    dopant=\"Gd\",\n    dopant_fraction=0.20,\n    dopant_placement=\"bulk\",\n    vacancy_placement=\"bulk\",\n)\n</code></pre>"},{"location":"tutorials/doped_fluorite/#mixed-valence-dopants-pr-tb","title":"Mixed Valence Dopants (Pr, Tb)","text":"<p>Praseodymium and Terbium can exist as M\u00b3\u207a or M\u2074\u207a:</p> <pre><code># 20% Pr, but only half is Pr\u00b3\u207a (contributes to vacancies)\npdc = builder.create_doped_structure(\n    dopant=\"Pr\",\n    dopant_fraction=0.20,       # 20% total Pr\n    pr_trivalent_fraction=0.5,  # 50% is Pr\u00b3\u207a\n    random_seed=42,\n)\n# Effective: 10% Pr\u00b3\u207a \u2192 5% vacancies (half of normal)\n\n# Same applies to Tb\ntdc = builder.create_doped_structure(\n    dopant=\"Tb\",\n    dopant_fraction=0.15,\n    pr_trivalent_fraction=0.7,  # 70% is Tb\u00b3\u207a\n    random_seed=42,\n)\n</code></pre> <p>Parameter Name</p> <p>The parameter is named <code>pr_trivalent_fraction</code> for historical reasons but applies to both Pr and Tb dopants. The alias <code>trivalent_fraction</code> is also available in <code>DopedFluoriteStructure.from_ceria()</code>.</p>"},{"location":"tutorials/doped_fluorite/#generating-configuration-pools","title":"Generating Configuration Pools","text":"<p>For screening studies, generate multiple configurations:</p> <pre><code># Pool with different vacancy placement strategies\npool = builder.create_doped_pool(\n    dopant=\"Gd\",\n    dopant_fraction=0.15,\n    n_configs=5,\n    strategies=[\"random\", \"surface\", \"near_dopant\"],\n    random_seed=42,\n)\n\nprint(f\"Generated {len(pool)} configurations\")  # 15 configs\n\n# Each config has metadata\nfor config in pool[:3]:\n    print(f\"Config {config['config_id']}: {config['vacancy_placement']}\")\n</code></pre>"},{"location":"tutorials/doped_fluorite/#zirconia-pools","title":"Zirconia Pools","text":"<pre><code># YSZ configuration pool\nysz_pool = builder.create_doped_pool(\n    dopant=\"Y\",\n    dopant_fraction=0.08,\n    n_configs=3,\n    strategies=[\"random\", \"surface\"],\n    host_cation=\"Zr\",\n    random_seed=42,\n)\n</code></pre>"},{"location":"tutorials/doped_fluorite/#concentration-series","title":"Concentration Series","text":"<p>Generate structures with varying dopant levels by passing a list of fractions:</p> <pre><code># Use create_doped_pool with a list of fractions\npool = builder.create_doped_pool(\n    dopant=\"Gd\",\n    dopant_fraction=[0.05, 0.10, 0.15, 0.20, 0.25],\n    n_configs=3,\n    random_seed=42,\n)\n\nprint(f\"Generated {len(pool)} structures\")  # 15 (5 fractions \u00d7 3 configs)\n\n# Group by fraction\nfrom collections import defaultdict\nby_fraction = defaultdict(list)\nfor s in pool:\n    by_fraction[s[\"dopant_fraction\"]].append(s[\"atoms\"])\n</code></pre> <p>Default Strategy for Concentration Series</p> <p>When <code>dopant_fraction</code> is a list, the default strategy is <code>[\"random\"]</code> since concentration series typically don't need strategy variation. Override with <code>strategies=[\"random\", \"surface\"]</code> if needed.</p>"},{"location":"tutorials/doped_fluorite/#analysis","title":"Analysis","text":""},{"location":"tutorials/doped_fluorite/#single-structure-analysis","title":"Single Structure Analysis","text":"<pre><code>from nh3sofc.structure import analyze_dopant_distribution, print_dopant_analysis\n\n# Analyze doped structure\nstats = analyze_dopant_distribution(\n    gdc,\n    dopant=\"Gd\",\n    reference_atoms=ceo2_slab,  # Original for vacancy counting\n    z_threshold=0.3,            # Top 30% = surface\n    near_dopant_cutoff=3.5,     # \u00c5\n)\n\n# Print formatted report\nprint_dopant_analysis(stats, title=\"GDC Analysis\")\n</code></pre> <p>Output: <pre><code>============================================================\nGDC Analysis\n============================================================\n\nDopant: Gd\n  Total Gd atoms: 2\n  Gd in surface (top 30%): 1 (50.0%)\n  Gd in bulk: 1\n  Dopant fraction: 25.0%\n\nHost Cations:\n  Ce atoms remaining: 6\n  O atoms: 15\n\nVacancy Distribution:\n  Total vacancies: 1\n  Vacancies in surface: 1 (100.0%)\n  Vacancies in bulk: 0\n  Vacancies near Gd (&lt; 3.5 \u00c5): 1 (100.0%)\n\nCharge Balance Check:\n  Expected vacancies (n_dopant/2): 1\n  Actual vacancies: 1\n  Status: Charge balanced\n============================================================\n</code></pre></p>"},{"location":"tutorials/doped_fluorite/#key-metrics","title":"Key Metrics","text":"Metric Description <code>dopant_surface_fraction</code> Fraction of dopants in surface region <code>vacancy_surface_fraction</code> Fraction of vacancies in surface region <code>vacancy_near_dopant_fraction</code> Fraction of vacancies within cutoff of dopants <code>dopant_fraction</code> Actual dopant/(dopant+host) ratio"},{"location":"tutorials/doped_fluorite/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code>from ase.build import bulk\nfrom ase.io import write\nfrom nh3sofc.structure import (\n    DopantBuilder,\n    DopedFluoriteStructure,\n    analyze_dopant_distribution,\n    print_dopant_analysis,\n)\nfrom nh3sofc.calculators.vasp import VASPInputGenerator\nimport os\n\n# 1. Create CeO2 surface\nceo2 = bulk('CeO2', 'fluorite', a=5.41) * (3, 3, 3)\n\n# 2. Create 10% GDC with surface-preferring vacancies\nbuilder = DopantBuilder(ceo2)\ngdc = builder.create_doped_structure(\n    dopant=\"Gd\",\n    dopant_fraction=0.10,\n    vacancy_placement=\"surface\",\n    vacancy_preference=0.75,\n    random_seed=42,\n)\n\n# 3. Analyze distribution\nstats = analyze_dopant_distribution(gdc, \"Gd\", reference_atoms=ceo2)\nprint_dopant_analysis(stats)\n\n# 4. Save structure\nwrite(\"GDC_10pct.vasp\", gdc, format=\"vasp\")\n\n# 5. Generate VASP inputs\nos.makedirs(\"calc_gdc\", exist_ok=True)\nvasp = VASPInputGenerator(\n    gdc,\n    calc_type=\"relax\",\n    work_dir=\"calc_gdc\",\n)\nvasp.generate_all(\n    encut=520,\n    hubbard_u={\"Ce\": 5.0},  # DFT+U for Ce 4f electrons\n    vdw=\"D3BJ\",\n)\n</code></pre>"},{"location":"tutorials/doped_fluorite/#ysz-workflow-example","title":"YSZ Workflow Example","text":"<pre><code># 1. Create ZrO2 structure\nzro2 = bulk('ZrO2', 'fluorite', a=5.07) * (3, 3, 3)\n\n# 2. Create 8YSZ\nysz = DopedFluoriteStructure.from_zirconia(\n    zro2,\n    dopant=\"Y\",\n    dopant_fraction=0.08,\n    vacancy_placement=\"random\",\n    random_seed=42,\n)\n\nprint(f\"Created {ysz.get_material_name()}\")\nprint(f\"Host: {ysz.host_cation}, Dopant: {ysz.dopant}\")\nprint(f\"Vacancies: {ysz.n_vacancies}\")\n\n# Save structure\nwrite(\"YSZ_8mol.vasp\", ysz.atoms, format=\"vasp\")\n</code></pre>"},{"location":"tutorials/doped_fluorite/#supported-dopants","title":"Supported Dopants","text":""},{"location":"tutorials/doped_fluorite/#trivalent-dopants-21-dopantvacancy-ratio","title":"Trivalent Dopants (2:1 dopant:vacancy ratio)","text":"Dopant Name Ionic Radius (\u00c5) Common Use Gd Gadolinium 1.053 GDC - highest conductivity for ceria Sm Samarium 1.079 SDC - high conductivity Pr Praseodymium 1.126 PDC - mixed ionic-electronic Y Yttrium 1.019 YDC, YSZ - most common for zirconia La Lanthanum 1.160 LDC Nd Neodymium 1.109 NDC Tb Terbium 1.040 TDC - mixed valence Sc Scandium 0.870 ScSZ - highest conductivity for zirconia"},{"location":"tutorials/doped_fluorite/#divalent-dopants-11-dopantvacancy-ratio","title":"Divalent Dopants (1:1 dopant:vacancy ratio)","text":"Dopant Name Ionic Radius (\u00c5) Common Use Ca Calcium 1.120 CSZ - cost-effective Mg Magnesium 0.890 MSZ"},{"location":"tutorials/doped_fluorite/#supported-host-materials","title":"Supported Host Materials","text":"Host Oxide Lattice (\u00c5) Notes Ce CeO2 5.41 Reducible, high electronic conductivity at low pO2 Zr ZrO2 5.07 Stable, purely ionic conductor Hf HfO2 5.11 Similar to zirconia Th ThO2 5.60 Nuclear applications"},{"location":"tutorials/doped_fluorite/#tips","title":"Tips","text":"<ol> <li> <p>Dopant fraction: Typical SOFC concentrations are 8-20% (x = 0.08-0.20)</p> </li> <li> <p>Charge balance: Always verify with <code>analyze_dopant_distribution()</code></p> </li> <li> <p>Surface vs bulk: Use <code>z_threshold</code> to define what counts as \"surface\"</p> </li> <li> <p>Multiple configs: Generate pools for statistical sampling of configurations</p> </li> <li> <p>Mixed valence: Remember to set <code>pr_trivalent_fraction</code> for Pr/Tb studies</p> </li> <li> <p>YSZ vs ScSZ: ScSZ has higher conductivity but Sc is more expensive</p> </li> <li> <p>Divalent dopants: Remember they create more vacancies per dopant (1:1 vs 2:1)</p> </li> </ol>"},{"location":"tutorials/doped_fluorite/#next-steps","title":"Next Steps","text":"<ul> <li>VASP Calculations - Run DFT on doped structures</li> <li>High-Throughput Screening - Screen multiple configurations</li> <li>Exsolution Simulation - Metal particles on doped fluorites</li> </ul>"},{"location":"tutorials/exsolution/","title":"Exsolution Simulation","text":"<p>This tutorial covers simulating exsolution processes in perovskite materials, where transition metal cations migrate from the bulk to the surface under reducing conditions to form metallic nanoparticles.</p>"},{"location":"tutorials/exsolution/#background","title":"Background","text":"<p>Exsolution is a phenomenon where B-site transition metals (Ni, Co, Fe) in perovskite oxides (e.g., La\u2080.\u2084Sr\u2080.\u2084Ti\u2080.\u2089Ni\u2080.\u2081O\u2083) emerge from the lattice to form metallic nanoparticles on the surface. Key features:</p> <ul> <li>Occurs under reducing atmospheres (H\u2082, NH\u2083)</li> <li>Creates socketed nanoparticles anchored into the surface</li> <li>Generates oxygen vacancies that enhance catalytic activity</li> <li>Produces highly stable, sinter-resistant metal particles</li> </ul>"},{"location":"tutorials/exsolution/#exsolution-pathway","title":"Exsolution Pathway","text":"<p>The exsolution process involves four stages:</p> <pre><code>1. Pristine      \u2192 2. Defective     \u2192 3. Segregated   \u2192 4. Exsolved\n   Perovskite       + Vacancies        + Surface B       + Nanoparticle\n</code></pre>"},{"location":"tutorials/exsolution/#quick-start","title":"Quick Start","text":""},{"location":"tutorials/exsolution/#create-exsolution-structures","title":"Create Exsolution Structures","text":"<pre><code>from nh3sofc.structure import BulkStructure, SurfaceBuilder, ExsolutionBuilder\nfrom nh3sofc import write_poscar\n\n# Load perovskite structure\nbulk = BulkStructure.from_cif(\"LaSrTiNiO3.cif\")\n\n# Create (001) surface\nsurface = SurfaceBuilder(bulk).create_surface(\n    miller_index=(0, 0, 1),\n    layers=6,\n    vacuum=15.0\n)\nsurface.fix_bottom_layers(2)\n\n# Create exsolution builder\nbuilder = ExsolutionBuilder(surface)\n\n# Generate full exsolution pathway\npathway = builder.create_exsolution_pathway(\n    metal=\"Ni\",\n    particle_size=13,\n    vacancy_fraction=0.1\n)\n\n# Save structures with proper POSCAR format (atoms sorted automatically)\nwork_dir = \"work/exsolution/Ni13\"\nfor step in pathway:\n    atoms = step[\"atoms\"]\n    stage = step[\"stage\"]\n    write_poscar(atoms, f\"{work_dir}/{stage}.vasp\")\n    print(f\"{stage}: {step['description']}\")\n</code></pre>"},{"location":"tutorials/exsolution/#individual-steps","title":"Individual Steps","text":""},{"location":"tutorials/exsolution/#1-identify-perovskite-sites","title":"1. Identify Perovskite Sites","text":"<pre><code>sites = builder.identify_perovskite_sites()\nprint(f\"A-site atoms: {len(sites['A_site'])}\")  # La, Sr\nprint(f\"B-site atoms: {len(sites['B_site'])}\")  # Ti, Ni\nprint(f\"O-site atoms: {len(sites['O_site'])}\")  # O\n</code></pre>"},{"location":"tutorials/exsolution/#2-create-defective-perovskite","title":"2. Create Defective Perovskite","text":"<pre><code>from nh3sofc import write_poscar\n\ndefective = builder.create_defective_perovskite(\n    a_site_vacancy_fraction=0.05,   # 5% A-site vacancies\n    b_site_vacancy_fraction=0.1,    # 10% B-site (Ni) vacancies\n    oxygen_vacancy_fraction=0.08,   # 8% O vacancies\n    b_site_element=\"Ni\",            # Specifically remove Ni\n    random_seed=42\n)\nwrite_poscar(defective, \"work/exsolution/defective.vasp\")\n</code></pre>"},{"location":"tutorials/exsolution/#3-create-nanoparticle-on-surface","title":"3. Create Nanoparticle on Surface","text":"<pre><code>exsolved = builder.create_nanoparticle(\n    metal=\"Ni\",\n    n_atoms=13,                  # Ni13 cluster (magic number)\n    shape=\"hemispherical\",       # or \"icosahedral\"\n    position=\"hollow\",           # or \"ontop\", \"bridge\", \"random\"\n    interface_distance=2.0,      # Metal-oxide distance\n    socketed=True,               # Remove surface atoms (real exsolution)\n    random_seed=42\n)\nwrite_poscar(exsolved, \"work/exsolution/exsolved_Ni13.vasp\")\n</code></pre>"},{"location":"tutorials/exsolution/#running-calculations","title":"Running Calculations","text":""},{"location":"tutorials/exsolution/#single-exsolution-study","title":"Single Exsolution Study","text":"<pre><code>from nh3sofc.workflows import ExsolutionWorkflow\n\nwf = ExsolutionWorkflow(\n    atoms=surface.atoms,\n    work_dir=\"./exsolution_Ni13\",\n    metal=\"Ni\",\n    particle_size=13,\n    vacancy_fraction=0.1,\n    calculator=\"vasp\",\n    encut=520,\n    hubbard_u={\"Ni\": 6.2, \"Ti\": 3.0},\n    vdw=\"D3BJ\",\n)\n\n# Generate all structures\nwf.generate_pathway_structures()\n\n# Setup VASP calculations\nwf.setup()\n\n# Submit jobs\n# cd exsolution_Ni13 &amp;&amp; bash submit_all.sh\n</code></pre>"},{"location":"tutorials/exsolution/#parse-results","title":"Parse Results","text":"<pre><code># After VASP calculations complete\nresults = wf.parse_results()\n\nprint(f\"Pristine energy: {results['pristine']['energy']:.2f} eV\")\nprint(f\"Exsolved energy: {results['exsolved']['energy']:.2f} eV\")\nprint(f\"Exsolution energy: {results['exsolution_energy']:.2f} eV\")\nprint(f\"Favorable: {results['summary']['favorable']}\")\n</code></pre>"},{"location":"tutorials/exsolution/#energetics-analysis","title":"Energetics Analysis","text":""},{"location":"tutorials/exsolution/#calculate-exsolution-driving-force","title":"Calculate Exsolution Driving Force","text":"<pre><code>from nh3sofc.analysis import ExsolutionEnergetics\n\nenergetics = ExsolutionEnergetics(\n    metal=\"Ni\",\n    temperature=873.0,  # 600\u00b0C\n    p_o2=1e-20          # Reducing atmosphere\n)\n\n# Set reference\nenergetics.set_reference_energies(e_pristine=-250.0)\n\n# Add DFT results\nenergetics.add_stage(\"pristine\", -250.0)\nenergetics.add_stage(\"defective\", -235.0, n_o_vacancies=4)\nenergetics.add_stage(\"segregated\", -238.0)\nenergetics.add_stage(\"exsolved\", -265.0, n_particle_atoms=13, n_o_vacancies=4)\n\n# Calculate thermodynamics\nresult = energetics.get_exsolution_driving_force()\n\nprint(f\"\u0394G_exsolution = {result['delta_G']:.2f} eV\")\nprint(f\"\u03bc_O = {result['mu_O']:.2f} eV\")\nprint(f\"Favorable: {result['favorable']}\")\n\n# Print summary\nenergetics.print_summary()\n</code></pre>"},{"location":"tutorials/exsolution/#effect-of-temperature-and-pressure","title":"Effect of Temperature and Pressure","text":"<pre><code>import numpy as np\n\n# Vary temperature\nfor T in [673, 773, 873, 973]:\n    result = energetics.get_exsolution_driving_force(temperature=T)\n    print(f\"T={T}K: \u0394G={result['delta_G']:.2f} eV\")\n\n# Vary oxygen partial pressure\nfor log_p in [-25, -20, -15, -10]:\n    result = energetics.get_exsolution_driving_force(p_o2=10**log_p)\n    print(f\"log(p_O2)={log_p}: \u0394G={result['delta_G']:.2f} eV\")\n</code></pre>"},{"location":"tutorials/exsolution/#high-throughput-screening","title":"High-Throughput Screening","text":""},{"location":"tutorials/exsolution/#screen-multiple-metals-and-sizes","title":"Screen Multiple Metals and Sizes","text":"<pre><code>from nh3sofc.workflows import ExsolutionScreeningWorkflow\n\nscreening = ExsolutionScreeningWorkflow(\n    base_structure=surface.atoms,\n    parameter_space={\n        \"metal\": [\"Ni\", \"Co\", \"Fe\"],\n        \"particle_size\": [1, 4, 13],\n        \"vacancy_fraction\": [0.05, 0.1, 0.15],\n    },\n    work_dir=\"./exsolution_screening\",\n    calculator=\"vasp\",\n    encut=520,\n)\n\n# Generate all combinations\nconfigs = screening.generate_all()\nprint(f\"Total configurations: {len(configs)}\")\n\n# Setup calculations\nscreening.setup_all()\n\n# After completion:\nresults = screening.parse_all()\nbest = screening.get_best_result(metric=\"exsolution_energy\", minimize=True)\nprint(f\"Best configuration: {best['config']}\")\n</code></pre>"},{"location":"tutorials/exsolution/#nh3-catalysis-on-exsolved-particles","title":"NH3 Catalysis on Exsolved Particles","text":""},{"location":"tutorials/exsolution/#identify-adsorption-sites","title":"Identify Adsorption Sites","text":"<p>Exsolved particles have multiple unique adsorption site types:</p> <pre><code># Get adsorption sites on exsolved structure\nsites = builder.get_adsorption_sites(exsolved)\n\nprint(f\"Metal top sites: {len(sites['metal_top'])}\")\nprint(f\"Interface edge sites: {len(sites['interface_edge'])}\")\nprint(f\"Vacancy sites: {len(sites['vacancy_site'])}\")\nprint(f\"Oxide surface sites: {len(sites['oxide_surface'])}\")\n</code></pre>"},{"location":"tutorials/exsolution/#couple-with-nh3-decomposition","title":"Couple with NH3 Decomposition","text":"<pre><code># Continue from exsolution workflow\ndecomp_wf = wf.couple_with_decomposition()\ndecomp_wf.setup()\n\n# This creates NH3 decomposition pathway on the exsolved particle\n</code></pre>"},{"location":"tutorials/exsolution/#compare-with-clean-surface","title":"Compare with Clean Surface","text":"<pre><code># Energies from NH3 decomposition on exsolved particle\nexsolved_energies = {\n    \"NH3*\": -0.8,\n    \"NH2*+H*\": 0.2,\n    \"NH*+2H*\": 0.5,\n    \"N*+3H*\": 0.3,\n}\n\n# Energies from clean perovskite surface\nclean_energies = {\n    \"NH3*\": -0.5,\n    \"NH2*+H*\": 0.6,\n    \"NH*+2H*\": 1.2,\n    \"N*+3H*\": 0.9,\n}\n\ncomparison = energetics.compare_with_clean_surface(\n    exsolved_energies,\n    clean_energies\n)\n\nprint(\"More favorable on exsolved:\", comparison[\"more_favorable_on_exsolved\"])\nprint(\"More favorable on clean:\", comparison[\"more_favorable_on_clean\"])\n</code></pre>"},{"location":"tutorials/exsolution/#key-differences-exsolved-vs-deposited-catalysts","title":"Key Differences: Exsolved vs. Deposited Catalysts","text":"Feature Exsolved Deposited Anchoring Socketed into support Weakly bound Sintering Resistant Prone to coalescence Active sites Metal + interface + vacancies Metal surface only Coking Resistant (small particles) Variable"},{"location":"tutorials/exsolution/#best-practices","title":"Best Practices","text":"<ol> <li>Particle sizes: Use magic numbers (1, 4, 7, 13, 19) for stable clusters</li> <li>Vacancy coupling: ~2 O vacancies per reduced B-site cation</li> <li>Socket modeling: Enable <code>socketed=True</code> for realistic exsolution</li> <li>Temperature: Typical exsolution occurs at 600-900\u00b0C</li> <li>Atmosphere: Use very low p(O\u2082) (~10\u207b\u00b2\u2070 atm) for reducing conditions</li> </ol>"},{"location":"tutorials/exsolution/#example-directory-structure","title":"Example Directory Structure","text":"<pre><code>exsolution_study/\n\u251c\u2500\u2500 pristine/\n\u2502   \u251c\u2500\u2500 INCAR, POSCAR, KPOINTS, POTCAR\n\u2502   \u2514\u2500\u2500 run.pbs\n\u251c\u2500\u2500 defective/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 segregated/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 exsolved/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 submit_all.sh\n\u2514\u2500\u2500 nh3_decomposition/  # From couple_with_decomposition()\n    \u251c\u2500\u2500 NH3/\n    \u251c\u2500\u2500 NH2_H/\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"tutorials/exsolution/#next-steps","title":"Next Steps","text":"<ul> <li>Thermochemistry - Calculate Gibbs free energies</li> <li>Microkinetics - Model reaction rates on exsolved particles</li> <li>Surface Comparison - Compare different catalyst surfaces</li> </ul>"},{"location":"tutorials/mace/","title":"Tutorial: MACE ML Force Fields","text":"<p>This tutorial covers using MACE machine learning force fields for fast calculations.</p>"},{"location":"tutorials/mace/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Use MACE foundation models</li> <li>Train custom MACE models</li> <li>Implement active learning workflows</li> </ul>"},{"location":"tutorials/mace/#overview","title":"Overview","text":"<p>MACE provides ML force fields that are: - 100-1000x faster than DFT - Accurate for similar systems - Useful for screening and exploration</p>"},{"location":"tutorials/mace/#step-1-using-foundation-models","title":"Step 1: Using Foundation Models","text":"<pre><code>from nh3sofc.calculators.mace import MACECalculatorWrapper\n\n# Load foundation model\nmace = MACECalculatorWrapper(\n    foundation_model=\"medium\",  # \"small\", \"medium\", or \"large\"\n    device=\"auto\"  # \"cpu\", \"cuda\", or \"auto\"\n)\n\n# Get ASE calculator\ncalc = mace.get_calculator()\n\n# Attach to atoms\natoms.calc = calc\nenergy = atoms.get_potential_energy()\nforces = atoms.get_forces()\n\nprint(f\"Energy: {energy:.4f} eV\")\n</code></pre>"},{"location":"tutorials/mace/#step-2-fast-relaxation","title":"Step 2: Fast Relaxation","text":"<pre><code>from ase.optimize import BFGS\n\natoms.calc = mace.get_calculator()\n\nopt = BFGS(atoms, trajectory=\"relax.traj\")\nopt.run(fmax=0.03)\n\nprint(f\"Final energy: {atoms.get_potential_energy():.4f} eV\")\n</code></pre>"},{"location":"tutorials/mace/#step-3-fast-neb","title":"Step 3: Fast NEB","text":"<pre><code>from nh3sofc.workflows import NEBWorkflow\n\nneb = NEBWorkflow(\n    initial=initial,\n    final=final,\n    work_dir=\"./mace_neb\",\n    n_images=7,\n)\n\n# Run with MACE (much faster than VASP)\nimages = neb.run_mace(fmax=0.03, steps=500)\n\nresults = neb.parse_results()\nprint(f\"Barrier: {results['barrier_forward']:.3f} eV\")\n</code></pre>"},{"location":"tutorials/mace/#step-4-training-custom-models","title":"Step 4: Training Custom Models","text":""},{"location":"tutorials/mace/#extract-training-data","title":"Extract Training Data","text":"<pre><code>from nh3sofc.calculators.mace import TrainingDataExtractor\n\nextractor = TrainingDataExtractor()\n\n# Extract from VASP calculations\nfor calc_dir in [\"./calc1\", \"./calc2\", \"./calc3\"]:\n    extractor.extract_from_directory(\n        calc_dir,\n        include_trajectory=True  # Include ionic steps\n    )\n\ntraining_data = extractor.extract_all()\nprint(f\"Extracted {len(training_data)} configurations\")\n\n# Filter high-energy configs\nfiltered = extractor.filter_by_energy(\n    training_data,\n    max_energy_per_atom=-2.0\n)\n\n# Save\nextractor.write_xyz(\"training_data.xyz\", filtered)\n</code></pre>"},{"location":"tutorials/mace/#generate-training-config","title":"Generate Training Config","text":"<pre><code>from nh3sofc.calculators.mace import MACETrainingConfig\n\nconfig = MACETrainingConfig(\n    train_file=\"train.xyz\",\n    valid_file=\"valid.xyz\",\n    model_name=\"LaVON_MACE\"\n)\n\nconfig.generate_config(\n    r_max=6.0,\n    max_epochs=500,\n    batch_size=5,\n)\n\nconfig.write_config(\"mace_config.yaml\")\nconfig.generate_training_script(\"train.sh\")\n</code></pre>"},{"location":"tutorials/mace/#train-model","title":"Train Model","text":"<pre><code># Run training script\nbash train.sh\n\n# Or manually\nmace_run_train --config mace_config.yaml\n</code></pre>"},{"location":"tutorials/mace/#step-5-uncertainty-estimation","title":"Step 5: Uncertainty Estimation","text":"<pre><code>from nh3sofc.calculators.mace import MACEEnsemble\n\n# Ensemble of models\nensemble = MACEEnsemble([\n    \"./model_1.model\",\n    \"./model_2.model\",\n    \"./model_3.model\",\n])\n\nresults = ensemble.calculate_with_uncertainty(atoms)\n\nprint(f\"Energy: {results['energy']:.4f} \u00b1 {results['energy_std']:.4f} eV\")\nprint(f\"Max force std: {results['max_force_std']:.4f} eV/\u00c5\")\n\n# Flag high uncertainty for DFT recalculation\nif results['max_force_std'] &gt; 0.1:\n    print(\"High uncertainty - add to training data!\")\n</code></pre>"},{"location":"tutorials/mace/#step-6-active-learning","title":"Step 6: Active Learning","text":"<pre><code>from nh3sofc.calculators.mace import ActiveLearningWorkflow\n\nal = ActiveLearningWorkflow(\n    initial_training_data=\"train.xyz\",\n    ensemble_size=3,\n    uncertainty_threshold=0.1,  # eV/\u00c5\n    work_dir=\"./active_learning\",\n)\n\n# Run active learning loop\nfor iteration in range(5):\n    # 1. Train ensemble\n    al.train_ensemble()\n\n    # 2. Explore with MACE\n    new_configs = al.explore(\n        base_structure=surface,\n        n_configs=100,\n        method=\"md\",  # or \"random\"\n        temperature=673,\n    )\n\n    # 3. Select high-uncertainty configs\n    selected = al.select_for_dft(new_configs, n_select=10)\n\n    # 4. Run DFT on selected\n    al.run_dft_calculations(selected)\n\n    # 5. Update training data\n    al.update_training_data()\n\n    print(f\"Iteration {iteration}: Added {len(selected)} new configs\")\n</code></pre>"},{"location":"tutorials/mace/#complete-example","title":"Complete Example","text":"<pre><code>from ase.io import read\nfrom nh3sofc.calculators.mace import MACECalculatorWrapper, TrainingDataExtractor\nfrom nh3sofc.workflows import NEBWorkflow\nfrom ase.optimize import BFGS\n\n# 1. Quick relaxation with foundation model\natoms = read(\"structure.xyz\")\nmace = MACECalculatorWrapper(foundation_model=\"medium\")\n\natoms.calc = mace.get_calculator()\nopt = BFGS(atoms)\nopt.run(fmax=0.05)\n\n# 2. Use as starting point for VASP\natoms.write(\"mace_relaxed.xyz\")\n\n# 3. Or run NEB with MACE\ninitial = read(\"initial.traj\")\nfinal = read(\"final.traj\")\n\nneb = NEBWorkflow(initial, final, n_images=5)\nimages = neb.run_mace(fmax=0.05)\n\nprint(f\"Quick barrier estimate: {neb.parse_results()['barrier_forward']:.2f} eV\")\n</code></pre>"},{"location":"tutorials/mace/#best-practices","title":"Best Practices","text":"<ol> <li>Foundation models - Good for similar chemistries</li> <li>Custom training - Needed for unusual systems</li> <li>Validate with DFT - Always check key results</li> <li>Active learning - Most efficient for new systems</li> <li>Ensemble uncertainty - Detect extrapolation</li> </ol>"},{"location":"tutorials/mace/#next-steps","title":"Next Steps","text":"<ul> <li>Microkinetic Modeling - Use ML-computed data for kinetics</li> <li>Screening - ML-accelerated screening</li> </ul>"},{"location":"tutorials/microkinetics/","title":"Tutorial: Microkinetic Modeling","text":"<p>This tutorial covers microkinetic modeling to predict reaction rates and identify rate-limiting steps.</p>"},{"location":"tutorials/microkinetics/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Build microkinetic models from DFT data</li> <li>Solve for steady-state coverages</li> <li>Calculate turnover frequencies (TOF)</li> <li>Identify rate-determining steps</li> </ul>"},{"location":"tutorials/microkinetics/#overview","title":"Overview","text":"<p>Microkinetic modeling connects DFT energetics to observable kinetics:</p> <pre><code>DFT Energies \u2192 Rate Constants \u2192 Coverages \u2192 TOF\n</code></pre>"},{"location":"tutorials/microkinetics/#step-1-calculate-rate-constants","title":"Step 1: Calculate Rate Constants","text":"<pre><code>from nh3sofc.analysis import RateConstantCalculator\n\ncalc = RateConstantCalculator(temperature=673)  # K\n\n# From barrier (Eyring equation)\nbarrier = 1.0  # eV\nk = calc.from_barrier(barrier)\nprint(f\"Rate constant: {k:.2e} s^-1\")\n\n# Include entropy (more accurate)\nk = calc.from_barrier(\n    barrier=1.0,\n    delta_S=-0.0005  # eV/K (entropy change)\n)\n</code></pre>"},{"location":"tutorials/microkinetics/#step-2-build-microkinetic-model","title":"Step 2: Build Microkinetic Model","text":""},{"location":"tutorials/microkinetics/#manual-model-construction","title":"Manual Model Construction","text":"<pre><code>from nh3sofc.analysis import MicroKineticModel\n\nmodel = MicroKineticModel(temperature=673, total_sites=1.0)\n\n# Add surface species\nmodel.add_species(\"*\", is_site=True)       # Empty site\nmodel.add_species(\"NH3*\")\nmodel.add_species(\"NH2*\")\nmodel.add_species(\"H*\")\nmodel.add_species(\"N*\")\n\n# Add gas species with partial pressures (bar)\nmodel.add_gas(\"NH3(g)\", pressure=0.1)\nmodel.add_gas(\"H2(g)\", pressure=0.01)\nmodel.add_gas(\"N2(g)\", pressure=0.01)\n\n# Add reactions with barriers\nmodel.add_reaction(\n    name=\"NH3_adsorption\",\n    reactants={\"NH3(g)\": 1, \"*\": 1},\n    products={\"NH3*\": 1},\n    Ea_fwd=0.0,   # Adsorption barrier\n    dG=-0.5       # Free energy change\n)\n\nmodel.add_reaction(\n    name=\"NH3_dissociation\",\n    reactants={\"NH3*\": 1, \"*\": 1},\n    products={\"NH2*\": 1, \"H*\": 1},\n    Ea_fwd=1.2,   # Forward barrier\n    Ea_rev=0.4    # Reverse barrier\n)\n\n# ... add more reactions\n</code></pre>"},{"location":"tutorials/microkinetics/#using-pre-built-nh3-decomposition-model","title":"Using Pre-built NH3 Decomposition Model","text":"<pre><code>from nh3sofc.analysis import NH3DecompositionModel\n\n# Default barriers\nmodel = NH3DecompositionModel(temperature=673)\n\n# Or custom barriers from your DFT\nbarriers = {\n    \"NH3_ads\": 0.0,\n    \"NH3_NH2\": 1.0,\n    \"NH2_NH\": 0.9,\n    \"NH_N\": 0.7,\n    \"N_N2\": 1.3,\n    \"H_H2\": 0.5,\n}\n\nmodel = NH3DecompositionModel(\n    temperature=673,\n    barriers=barriers\n)\n</code></pre>"},{"location":"tutorials/microkinetics/#step-3-solve-steady-state","title":"Step 3: Solve Steady State","text":"<pre><code>coverages = model.solve_steady_state()\n\nprint(\"Steady-state coverages:\")\nfor species, theta in coverages.items():\n    print(f\"  {species}: {theta:.4f}\")\n</code></pre>"},{"location":"tutorials/microkinetics/#step-4-calculate-tof","title":"Step 4: Calculate TOF","text":"<pre><code>tof = model.get_tof()\nprint(f\"Turnover frequency: {tof:.4e} s^-1\")\n\n# Per reaction\nreaction_rates = model.get_reaction_rates(coverages)\nfor rxn, rate in reaction_rates.items():\n    print(f\"  {rxn}: {rate:.4e} s^-1\")\n</code></pre>"},{"location":"tutorials/microkinetics/#step-5-sensitivity-analysis","title":"Step 5: Sensitivity Analysis","text":"<pre><code># Degree of rate control\ndrc = model.degree_of_rate_control()\n\nprint(\"Degree of Rate Control:\")\nfor rxn, chi in sorted(drc.items(), key=lambda x: -abs(x[1])):\n    print(f\"  {rxn}: {chi:.3f}\")\n</code></pre>"},{"location":"tutorials/microkinetics/#step-6-temperature-dependence","title":"Step 6: Temperature Dependence","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\ntemperatures = np.linspace(500, 900, 50)\ntofs = []\n\nfor T in temperatures:\n    model.set_temperature(T)\n    coverages = model.solve_steady_state()\n    tofs.append(model.get_tof(coverages))\n\nplt.figure(figsize=(8, 5))\nplt.semilogy(1000/temperatures, tofs, 'b-', linewidth=2)\nplt.xlabel('1000/T (K$^{-1}$)')\nplt.ylabel('TOF (s$^{-1}$)')\nplt.title('Arrhenius Plot')\nplt.savefig('arrhenius.png', dpi=150)\n</code></pre>"},{"location":"tutorials/microkinetics/#complete-example","title":"Complete Example","text":"<pre><code>from nh3sofc.analysis import NH3DecompositionModel\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 1. Create model with custom barriers\nbarriers = {\n    \"NH3_ads\": 0.0,\n    \"NH3_NH2\": 1.0,  # From NEB\n    \"NH2_NH\": 0.85,\n    \"NH_N\": 0.70,\n    \"N_N2\": 1.25,\n    \"H_H2\": 0.50,\n}\n\nmodel = NH3DecompositionModel(\n    temperature=673,\n    barriers=barriers\n)\n\n# 2. Solve steady state\ncoverages = model.solve_steady_state()\n\nprint(\"Steady-state coverages:\")\nfor species, theta in coverages.items():\n    if theta &gt; 1e-6:\n        print(f\"  {species}: {theta:.4f}\")\n\n# 3. Calculate TOF\ntof = model.get_tof()\nprint(f\"\\nTOF: {tof:.4e} s^-1\")\n\n# 4. Rate control analysis\ndrc = model.degree_of_rate_control()\nrds = max(drc, key=drc.get)\nprint(f\"\\nRate-determining step: {rds}\")\n\n# 5. Apparent activation energy\nfrom nh3sofc.core.constants import KB_EV\n\nT1, T2 = 650, 700\nmodel.set_temperature(T1)\ntof1 = model.get_tof()\nmodel.set_temperature(T2)\ntof2 = model.get_tof()\n\nEa_app = -KB_EV * np.log(tof2/tof1) / (1/T2 - 1/T1)\nprint(f\"Apparent Ea: {Ea_app:.2f} eV\")\n</code></pre>"},{"location":"tutorials/microkinetics/#advanced-pressure-dependence","title":"Advanced: Pressure Dependence","text":"<pre><code>import numpy as np\n\np_NH3_range = np.logspace(-3, 0, 20)  # 0.001 to 1 bar\ntofs = []\n\nfor p in p_NH3_range:\n    model.set_pressure(\"NH3(g)\", p)\n    coverages = model.solve_steady_state()\n    tofs.append(model.get_tof(coverages))\n\n# Reaction order\nfrom scipy.stats import linregress\nslope, _, _, _, _ = linregress(np.log(p_NH3_range), np.log(tofs))\nprint(f\"Reaction order in NH3: {slope:.2f}\")\n</code></pre>"},{"location":"tutorials/microkinetics/#best-practices","title":"Best Practices","text":"<ol> <li>Consistent energies - Use same DFT settings for all barriers</li> <li>Include ZPE - Correct barriers for zero-point energy</li> <li>Check convergence - Verify steady-state is reached</li> <li>Validate - Compare with experimental data when available</li> </ol>"},{"location":"tutorials/microkinetics/#next-steps","title":"Next Steps","text":"<ul> <li>Surface Comparison - Compare TOF across surfaces</li> <li>Thermochemistry - Improve barriers with thermodynamic corrections</li> </ul>"},{"location":"tutorials/neb/","title":"Tutorial: NEB Transition States","text":"<p>This tutorial covers finding transition states using the Nudged Elastic Band (NEB) method.</p>"},{"location":"tutorials/neb/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Set up NEB calculations</li> <li>Use climbing image NEB</li> <li>Extract barrier heights</li> <li>Validate transition states</li> </ul>"},{"location":"tutorials/neb/#overview","title":"Overview","text":"<p>NEB finds the minimum energy path between two states:</p> <pre><code>Initial State \u2192 TS \u2192 Final State\n     \u2193           \u2193        \u2193\n   NH3*         TS      NH2* + H*\n</code></pre>"},{"location":"tutorials/neb/#step-1-prepare-endpoints","title":"Step 1: Prepare Endpoints","text":"<pre><code>from ase.io import read\n\n# Load optimized initial and final structures (POSCAR format)\ninitial = read(\"work/decomposition/LaVO3_001/NH3/relaxed.vasp\", format=\"vasp\")  # NH3*\nfinal = read(\"work/decomposition/LaVO3_001/NH2_H/relaxed.vasp\", format=\"vasp\")  # NH2* + H*\n</code></pre> <p>Important: Both endpoints must be fully optimized (converged relaxation).</p>"},{"location":"tutorials/neb/#step-2-set-up-neb","title":"Step 2: Set Up NEB","text":""},{"location":"tutorials/neb/#using-nebworkflow","title":"Using NEBWorkflow","text":"<pre><code>from nh3sofc.workflows import NEBWorkflow\n\nneb = NEBWorkflow(\n    initial=initial,\n    final=final,\n    work_dir=\"./neb_nh3_dissociation\",\n    n_images=7,\n    calculator=\"vasp\",\n    encut=520,\n    kspacing=0.03,\n)\n\n# Setup with IDPP interpolation\nneb.setup(\n    interpolation=\"idpp\",  # Image Dependent Pair Potential\n    climb=True,            # Climbing image NEB\n)\n</code></pre>"},{"location":"tutorials/neb/#directory-structure","title":"Directory Structure","text":"<pre><code>neb_nh3_dissociation/\n\u251c\u2500\u2500 00/          # Initial image\n\u2502   \u251c\u2500\u2500 POSCAR\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 01/          # Intermediate image 1\n\u251c\u2500\u2500 02/          # ...\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 07/          # Final image\n\u2514\u2500\u2500 run.pbs\n</code></pre>"},{"location":"tutorials/neb/#step-3-run-with-mace-quick-test","title":"Step 3: Run with MACE (Quick Test)","text":"<p>Before expensive VASP calculations, test with MACE:</p> <pre><code># Run NEB with MACE ML force field\nimages = neb.run_mace(\n    fmax=0.03,   # Force convergence (eV/\u00c5)\n    steps=500,   # Max optimization steps\n)\n\n# Check results\nresults = neb.parse_results()\nprint(f\"Forward barrier: {results['barrier_forward']:.3f} eV\")\nprint(f\"Reverse barrier: {results['barrier_reverse']:.3f} eV\")\n</code></pre>"},{"location":"tutorials/neb/#step-4-parse-vasp-results","title":"Step 4: Parse VASP Results","text":"<p>After VASP NEB completes:</p> <pre><code>results = neb.parse_results()\n\nprint(f\"Forward barrier: {results['barrier_forward']:.3f} eV\")\nprint(f\"Reverse barrier: {results['barrier_reverse']:.3f} eV\")\nprint(f\"TS image index: {results['ts_image']}\")\n\n# Get transition state structure and save as POSCAR\nfrom nh3sofc import write_poscar\nts = results[\"ts_structure\"]\nwrite_poscar(ts, \"work/neb/NH3_to_NH2_H/ts.vasp\")\n</code></pre>"},{"location":"tutorials/neb/#step-5-visualize","title":"Step 5: Visualize","text":"<pre><code>neb.plot_energy_profile(\"neb_profile.png\")\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nenergies = results[\"energies\"]\nx = np.arange(len(energies))\n\nplt.figure(figsize=(8, 5))\nplt.plot(x, energies, 'o-', markersize=10)\nplt.xlabel(\"Reaction Coordinate\")\nplt.ylabel(\"Energy (eV)\")\nplt.title(\"NEB Energy Profile\")\nplt.axhline(0, color='gray', linestyle='--')\nplt.savefig(\"neb_profile.png\", dpi=150)\n</code></pre>"},{"location":"tutorials/neb/#step-6-validate-ts-frequency","title":"Step 6: Validate TS (Frequency)","text":"<p>A true transition state has exactly one imaginary frequency:</p> <pre><code>from nh3sofc.workflows import FrequencyWorkflow\n\nts = results[\"ts_structure\"]\n\nfreq = FrequencyWorkflow(\n    ts,\n    work_dir=\"./ts_freq\",\n    adsorbate_indices=ts_atom_indices,\n)\n\nfreq.setup()\n\n# After calculation...\nfreq_results = freq.parse_results()\n\nimaginary = freq_results[\"imaginary\"]\nif len(imaginary) == 1:\n    print(f\"Valid TS! Imaginary frequency: {imaginary[0]:.1f}i cm^-1\")\nelse:\n    print(f\"Warning: {len(imaginary)} imaginary frequencies\")\n</code></pre>"},{"location":"tutorials/neb/#best-practices","title":"Best Practices","text":"<ol> <li>Optimize endpoints - Ensure both initial and final states are fully relaxed</li> <li>Number of images - Use 5-9 images (7 is typical)</li> <li>IDPP interpolation - Better than linear for complex paths</li> <li>Climbing image - Always use for accurate barrier</li> <li>Check forces - Final forces should be &lt; 0.05 eV/\u00c5</li> <li>Validate with frequency - Confirm exactly one imaginary mode</li> </ol>"},{"location":"tutorials/neb/#complete-example","title":"Complete Example","text":"<pre><code>from ase.io import read\nfrom nh3sofc.workflows import NEBWorkflow, FrequencyWorkflow\nfrom nh3sofc import write_poscar\n\n# 1. Load endpoints (POSCAR format)\ninitial = read(\"work/decomposition/LaVO3_001/NH3/relaxed.vasp\", format=\"vasp\")\nfinal = read(\"work/decomposition/LaVO3_001/NH2_H/relaxed.vasp\", format=\"vasp\")\n\n# 2. Setup NEB with meaningful work directory\nneb = NEBWorkflow(\n    initial=initial,\n    final=final,\n    work_dir=\"work/neb/LaVO3_001_NH3_to_NH2_H\",\n    n_images=7,\n    encut=520,\n    hubbard_u={\"V\": 3.25},\n)\n\nneb.setup(interpolation=\"idpp\", climb=True)\n\n# 3. Quick test with MACE\nimages = neb.run_mace(fmax=0.05)\n\n# 4. Parse results\nresults = neb.parse_results()\nprint(f\"Barrier: {results['barrier_forward']:.3f} eV\")\n\n# 5. Save transition state\nts = results[\"ts_structure\"]\nwrite_poscar(ts, \"work/neb/LaVO3_001_NH3_to_NH2_H/ts.vasp\")\n\n# 6. Plot\nneb.plot_energy_profile(\"work/neb/LaVO3_001_NH3_to_NH2_H/barrier.png\")\n</code></pre>"},{"location":"tutorials/neb/#next-steps","title":"Next Steps","text":"<ul> <li>Thermochemistry - Add ZPE corrections to barriers</li> <li>Microkinetic Modeling - Use barriers for rate predictions</li> </ul>"},{"location":"tutorials/screening/","title":"Tutorial: High-Throughput Screening","text":"<p>This tutorial covers systematic screening of compositions, defects, and adsorption configurations.</p>"},{"location":"tutorials/screening/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Set up parameter space screening</li> <li>Manage large numbers of calculations</li> <li>Analyze screening results</li> </ul>"},{"location":"tutorials/screening/#overview","title":"Overview","text":"<p>High-throughput screening automates exploration of: - Vacancy concentrations - Nitrogen fractions - Dopant elements - Adsorption sites</p>"},{"location":"tutorials/screening/#step-1-define-parameter-space","title":"Step 1: Define Parameter Space","text":"<pre><code>from nh3sofc.workflows import ScreeningWorkflow\n\nworkflow = ScreeningWorkflow(\n    base_structure=surface,\n    parameter_space={\n        \"vacancy_concentration\": [0.0, 0.05, 0.10, 0.15, 0.20],\n        \"nitrogen_fraction\": [0.5, 0.67, 0.75],\n    },\n    work_dir=\"./oxynitride_screening\",\n    encut=520,\n    kspacing=0.03,\n)\n</code></pre> <p>This creates 5 \u00d7 3 = 15 calculations.</p>"},{"location":"tutorials/screening/#step-2-setup-calculations","title":"Step 2: Setup Calculations","text":"<pre><code>calc_dirs = workflow.setup()\nprint(f\"Created {len(calc_dirs)} calculation directories\")\n\n# Directory structure:\n# oxynitride_screening/\n# \u251c\u2500\u2500 vac0.00_N0.50/\n# \u251c\u2500\u2500 vac0.00_N0.67/\n# \u251c\u2500\u2500 vac0.00_N0.75/\n# \u251c\u2500\u2500 vac0.05_N0.50/\n# ...\n</code></pre>"},{"location":"tutorials/screening/#step-3-monitor-progress","title":"Step 3: Monitor Progress","text":"<pre><code>status = workflow.get_status()\n\nfor name, state in status.items():\n    print(f\"{name}: {state}\")\n\n# Output:\n# vac0.00_N0.50: completed\n# vac0.00_N0.67: running\n# vac0.05_N0.50: pending\n# ...\n</code></pre>"},{"location":"tutorials/screening/#step-4-parse-results","title":"Step 4: Parse Results","text":"<pre><code>import pandas as pd\n\nresults = workflow.parse_results()\n\n# Returns DataFrame with columns:\n# - vacancy_concentration\n# - nitrogen_fraction\n# - energy\n# - converged\n# - ...\n\nprint(results.head())\n</code></pre>"},{"location":"tutorials/screening/#step-5-find-optimal","title":"Step 5: Find Optimal","text":"<pre><code>optimal = workflow.find_optimal(metric=\"energy\")\nprint(f\"Optimal parameters: {optimal}\")\n\n# Or custom criteria\nbest = results.loc[results[\"energy\"].idxmin()]\nprint(f\"Lowest energy: {best}\")\n</code></pre>"},{"location":"tutorials/screening/#specialized-screening","title":"Specialized Screening","text":""},{"location":"tutorials/screening/#composition-screening","title":"Composition Screening","text":"<pre><code>from nh3sofc.workflows import CompositionScreening\n\nworkflow = CompositionScreening(\n    base_structure=surface,\n    elements_to_vary={\n        \"La\": [\"La\", \"Sr\", \"Ba\", \"Ca\"],\n        \"V\": [\"V\", \"Ti\", \"Nb\", \"Ta\"],\n    },\n    work_dir=\"./dopant_screening\",\n)\n\nworkflow.setup()\n# Creates 4 \u00d7 4 = 16 calculations\n</code></pre>"},{"location":"tutorials/screening/#adsorbate-screening","title":"Adsorbate Screening","text":"<pre><code>from nh3sofc.workflows import AdsorbateScreening\n\nworkflow = AdsorbateScreening(\n    surface=surface,\n    adsorbates=[\"NH3\", \"NH2\", \"NH\", \"N\", \"H\"],\n    sites=[\"ontop_La\", \"ontop_V\", \"bridge\", \"hollow\"],\n    work_dir=\"./adsorbate_screening\",\n)\n\npaths = workflow.setup()\n# Creates 5 \u00d7 4 = 20 calculations\n</code></pre>"},{"location":"tutorials/screening/#generating-adsorbate-configurations","title":"Generating Adsorbate Configurations","text":"<p>For fine-grained control over adsorbate placement, use <code>AdsorbatePlacer</code> directly. All placement methods use uniform sampling on SO(3) for unbiased molecular orientations, ensuring proper coverage of configurational space.</p> <pre><code>from nh3sofc.structure import AdsorbatePlacer, SlabStructure\n\n# Load surface\nslab = SlabStructure.from_file(\"surface.vasp\")\nplacer = AdsorbatePlacer(slab)\n\n# Method 1: Random placement with random orientations\nconfigs = placer.add_random(\n    \"NH3\",\n    n_configs=20,\n    height=2.0,\n    random_seed=42,\n)\n# Generates 20 configurations with uniformly sampled positions and orientations\n\n# Method 2: Grid-based placement with multiple orientations per point\nconfigs = placer.add_grid(\n    \"NH3\",\n    grid_size=(3, 3),    # 3x3 grid of positions\n    orientations=4,       # 4 random orientations per grid point\n    height=2.0,\n    random_seed=42,\n)\n# Generates 3 \u00d7 3 \u00d7 4 = 36 configurations\n\n# Method 3: Site-specific placement (most physically meaningful)\n# Step 1: Identify surface atoms (within 2 \u00c5 of topmost atom)\n# Step 2: Filter to only La and V atoms among those surface atoms\nconfigs = placer.add_on_site(\n    \"NH3\",\n    atom_types=[\"La\", \"V\"],  # Select La/V from surface atoms only\n    n_orientations=5,         # 5 orientations per site\n    height=2.0,\n    layer_tolerance=2.0,      # Top bilayer (default for perovskites)\n    random_seed=42,\n)\n# Places above La and V atoms in the TOP BILAYER only\n# Bulk La/V atoms are automatically excluded\n\n# For only the topmost layer (e.g., just VO2 termination)\nconfigs = placer.add_on_site(\n    \"NH3\",\n    atom_types=[\"V\"],\n    n_orientations=3,\n    layer_tolerance=1.0,      # Only topmost ~1 \u00c5\n    random_seed=42,\n)\n\n# Method 4: Collision-aware random placement\nconfigs = placer.add_with_collision(\n    \"NH3\",\n    n_configs=10,\n    min_distance=2.0,  # Minimum atom-atom distance\n    height=2.0,\n    random_seed=42,\n)\n</code></pre>"},{"location":"tutorials/screening/#rotation-sampling","title":"Rotation Sampling","text":"<p>All methods apply uniform random rotations using proper SO(3) sampling:</p> <pre><code># The rotation uses: \u03b2 = arccos(1 - 2u) for uniform spherical coverage\n# This avoids clustering near the \"poles\" that occurs with naive sampling\n\n# For reproducibility, always set random_seed\nconfigs_a = placer.add_random(\"NH3\", n_configs=10, random_seed=42)\nconfigs_b = placer.add_random(\"NH3\", n_configs=10, random_seed=42)\n# configs_a and configs_b are identical\n</code></pre>"},{"location":"tutorials/screening/#filtering-unique-configurations","title":"Filtering Unique Configurations","text":"<p>After generating many configurations, filter duplicates based on adsorbate-only RMSD:</p> <pre><code>from nh3sofc.structure.adsorbates import filter_unique_configs, save_configs\n\n# Remove duplicates (compares only adsorbate atoms, not the slab)\n# n_slab_atoms = number of atoms BEFORE adding adsorbate\nn_slab_atoms = len(slab.atoms)\nunique = filter_unique_configs(\n    configs,\n    threshold=0.5,        # RMSD threshold in Angstroms\n    n_slab_atoms=n_slab_atoms\n)\nprint(f\"Filtered {len(configs)} \u2192 {len(unique)} unique configurations\")\n\n# Save for calculations\npaths = save_configs(unique, output_dir=\"./adsorbate_configs\", format=\"vasp\")\n</code></pre> <p>Why <code>n_slab_atoms</code>? Adsorbate atoms are appended to the end of the structure. This parameter tells the filter to compare only atoms at index <code>n_slab_atoms</code> onwards, ignoring the identical slab atoms that would otherwise dominate the RMSD.</p>"},{"location":"tutorials/screening/#visualizing-results","title":"Visualizing Results","text":"<pre><code>import matplotlib.pyplot as plt\n\nresults = workflow.parse_results()\n\n# Heatmap\npivot = results.pivot(\n    index=\"vacancy_concentration\",\n    columns=\"nitrogen_fraction\",\n    values=\"energy\"\n)\n\nplt.figure(figsize=(8, 6))\nplt.imshow(pivot.values, cmap='RdYlGn_r')\nplt.colorbar(label='Energy (eV)')\nplt.xlabel('Nitrogen Fraction')\nplt.ylabel('Vacancy Concentration')\nplt.savefig('screening_heatmap.png', dpi=150)\n</code></pre>"},{"location":"tutorials/screening/#complete-example","title":"Complete Example","text":"<pre><code>from ase.io import read\nfrom nh3sofc.workflows import ScreeningWorkflow\n\n# 1. Load base structure (POSCAR format)\nsurface = read(\"work/surfaces/LaVO3_001/surface.vasp\", format=\"vasp\")\n\n# 2. Define screening with meaningful work directory\nworkflow = ScreeningWorkflow(\n    base_structure=surface,\n    parameter_space={\n        \"vacancy_concentration\": [0.0, 0.10, 0.20],\n        \"nitrogen_fraction\": [0.5, 0.67],\n    },\n    work_dir=\"work/screening/LaVON_composition\",\n    encut=520,\n)\n\n# 3. Setup (generates POSCAR files with atoms sorted by element)\nworkflow.setup()\n\n# 4. After completion, analyze\nresults = workflow.parse_results()\n\n# 5. Find optimal\noptimal = workflow.find_optimal(\"energy\")\nprint(f\"Best: {optimal}\")\n\n# 6. Save results\nresults.to_csv(\"work/screening/LaVON_composition/results.csv\")\n</code></pre>"},{"location":"tutorials/screening/#best-practices","title":"Best Practices","text":"<ol> <li>Start small - Test with subset before full screening</li> <li>Use database - Store all results in ASE database</li> <li>Check convergence - Verify all calculations completed</li> <li>Automate submission - Use job arrays for HPC</li> </ol>"},{"location":"tutorials/screening/#next-steps","title":"Next Steps","text":"<ul> <li>Surface Comparison - Rank screened surfaces</li> <li>MACE Force Fields - Use ML for faster screening</li> </ul>"},{"location":"tutorials/surface_building/","title":"Tutorial: Surface Building","text":"<p>This tutorial covers building surfaces from bulk structures, handling surface polarity, and creating oxynitride defects.</p>"},{"location":"tutorials/surface_building/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Load bulk structures from CIF files</li> <li>Generate surface slabs with different Miller indices</li> <li>Handle polar surfaces (critical for perovskites)</li> <li>Create symmetric slabs with specific terminations</li> <li>Create oxynitride structures with different defect placement strategies</li> <li>Generate configuration pools for screening studies</li> </ul>"},{"location":"tutorials/surface_building/#step-1-load-bulk-structure","title":"Step 1: Load Bulk Structure","text":"<pre><code>from nh3sofc.structure import BulkStructure\n\n# Load from CIF\nbulk = BulkStructure.from_cif(\"LaVO3.cif\")\nprint(f\"Formula: {bulk.atoms.get_chemical_formula()}\")\nprint(f\"Space group: {bulk.get_spacegroup()}\")\n\n# Create supercell if needed\nsupercell = bulk.make_supercell((2, 2, 1))\n</code></pre>"},{"location":"tutorials/surface_building/#step-2-generate-surface-slab","title":"Step 2: Generate Surface Slab","text":""},{"location":"tutorials/surface_building/#basic-surface-creation","title":"Basic Surface Creation","text":"<pre><code>from nh3sofc.structure import SurfaceBuilder\n\nbuilder = SurfaceBuilder(bulk)\n\n# Create (001) surface\nsurface = builder.create_surface(\n    miller_index=(0, 0, 1),\n    layers=6,\n    vacuum=15.0,\n    fix_bottom=2\n)\n\nprint(f\"Surface atoms: {len(surface.atoms)}\")\nprint(f\"Cell: {surface.atoms.cell.lengths()}\")\n</code></pre>"},{"location":"tutorials/surface_building/#different-terminations","title":"Different Terminations","text":"<pre><code>from nh3sofc import write_poscar\nimport os\n\n# Create work directory for this surface study\nwork_dir = \"work/surfaces/LaVO3_001\"\nif not os.path.exists(work_dir):\n    os.makedirs(work_dir)\n\n# Get all possible terminations\nterminations = builder.get_all_terminations((0, 0, 1))\n\nfor i, term in enumerate(terminations):\n    info = builder.identify_termination(term)\n    print(f\"Termination {i}: {info['composition']}\")\n    # Save as POSCAR with proper format (atoms sorted by element automatically)\n    write_poscar(term.atoms, f\"{work_dir}/POSCAR_term_{i}\")\n</code></pre>"},{"location":"tutorials/surface_building/#creating-supercells","title":"Creating Supercells","text":"<pre><code># Method 1: Using supercell parameter (recommended)\nsurface = builder.create_surface_with_size(\n    miller_index=(0, 0, 1),\n    size=(2, 2, 6),  # 2x2 supercell, 6 layers\n    vacuum=15.0\n)\nprint(f\"Surface atoms: {len(surface.atoms)}\")\nprint(f\"Cell: {surface.atoms.cell.lengths()}\")\n\n# Method 2: Repeat after creation (preserves constraints)\nsurface = builder.create_surface(\n    miller_index=(0, 0, 1),\n    layers=6,\n    fix_bottom=2\n)\nsurface = surface.repeat_xy(2, 2)  # Fixed atoms are preserved\nprint(f\"Surface atoms: {len(surface.atoms)}\")\nprint(f\"Cell: {surface.atoms.cell.lengths()}\")\n</code></pre>"},{"location":"tutorials/surface_building/#step-3-handling-surface-polarity","title":"Step 3: Handling Surface Polarity","text":"<p>Many oxide surfaces are polar, meaning they have alternating charged layers that create an electric dipole. This is critical for accurate DFT calculations.</p>"},{"location":"tutorials/surface_building/#check-surface-polarity","title":"Check Surface Polarity","text":"<pre><code># Analyze polarity\npolarity = surface.check_polarity()\n\nprint(f\"Is polar: {polarity['is_polar']}\")\nprint(f\"Dipole (z-component): {polarity['dipole_z']:.2f} e\u00b7\u00c5\")\nprint(f\"Layer charges: {polarity['layer_charges']}\")\nprint(f\"Recommendation: {polarity['recommendation']}\")\n</code></pre>"},{"location":"tutorials/surface_building/#analyze-layers","title":"Analyze Layers","text":"<pre><code># Identify atomic layers (uses automatic tolerance based on covalent radii)\nlayers = surface.identify_layers()  # tolerance=\"auto\" by default\n\nfor i, layer in enumerate(layers):\n    print(f\"Layer {i}: z={layer['z']:.2f} \u00c5, composition={layer['composition']}\")\n\n# Check what tolerance was calculated\ntol = surface.estimate_layer_tolerance()\nprint(f\"Auto-calculated tolerance: {tol:.2f} \u00c5\")\n\n# For complex materials like perovskites, auto tolerance correctly groups\n# atoms that belong to the same layer (e.g., V and O in VO2 layers)\n# You can override with explicit tolerance if needed:\nlayers_custom = surface.identify_layers(tolerance=0.5)\n\n# Get layer spacing\nspacings = surface.get_layer_spacing()\nprint(f\"Interlayer distances: {spacings}\")\n</code></pre>"},{"location":"tutorials/surface_building/#create-symmetric-slabs","title":"Create Symmetric Slabs","text":"<p>For polar surfaces, symmetric slabs (same termination on both sides) help cancel the dipole. NH3SOFC creates truly symmetric slabs by trimming to matching top/bottom layer compositions:</p> <pre><code># Create symmetric slab (automatically trims to matching terminations)\nsupercell = bulk.make_supercell((2, 2, 1))\nbuilder = SurfaceBuilder(supercell)\nsymmetric_surface = builder.create_symmetric_slab(\n    #termination={\"V\":1, \"O\":2},\n    miller_index=(0, 0, 1),\n    layers=4,\n    vacuum=15.0,\n    fix_bottom=2\n)\n\n# Verify top and bottom layers match\nlayers = symmetric_surface.identify_layers()\nprint(f\"Top layer: {layers[-1]['composition']}\")\nprint(f\"Bottom layer: {layers[0]['composition']}\")\n\n# Verify reduced dipole\npolarity = symmetric_surface.check_polarity()\nprint(f\"Dipole after symmetrization: {polarity['dipole_z']:.2f} e\u00b7\u00c5\")\nprint(f\"Total number of atoms: {symmetric_surface.atoms.get_number_of_atoms()}\")\n</code></pre>"},{"location":"tutorials/surface_building/#requesting-specific-terminations","title":"Requesting Specific Terminations","text":"<p>You can request a specific termination for your symmetric slab. The termination is specified as an element ratio, so <code>{\"La\": 1, \"O\": 1}</code> and <code>{\"La\": 8, \"O\": 8}</code> give identical results:</p> <pre><code># Create LaO-terminated symmetric slab\nlao_symmetric = builder.create_symmetric_slab(\n    miller_index=(0, 0, 1),\n    layers=7,\n    vacuum=15.0,\n    termination={\"La\": 1, \"O\": 1},  # LaO composition ratio (1:1)\n    min_layers=5,\n    fix_bottom=2\n)\n\n# Create VO2-terminated symmetric slab\nvo2_symmetric = builder.create_symmetric_slab(\n    miller_index=(0, 0, 1),\n    layers=7,\n    vacuum=15.0,\n    termination={\"V\": 1, \"O\": 2},  # VO2 composition ratio (1:2)\n    min_layers=5,\n    fix_bottom=2\n)\n</code></pre> <p>When no termination is specified, the builder automatically tries all unique layer compositions and picks the one that creates the best symmetric slab (most layers). This usually works well, but for precise control, specifying the termination explicitly is recommended.</p>"},{"location":"tutorials/surface_building/#manual-trimming-for-fine-control","title":"Manual Trimming for Fine Control","text":"<p>For more control, you can create an oversized slab and trim it yourself:</p> <pre><code># Create oversized slab\noversized = builder.create_surface(\n    miller_index=(0, 0, 1),\n    layers=6,\n    vacuum=15.0\n)\n\n# Trim to symmetric LaO termination\nsymmetric = oversized.trim_to_symmetric_termination(\n    termination={\"La\": 1, \"O\": 1},\n    min_layers=5\n)\n\n# Verify the result\nlayers = symmetric.identify_layers()\nprint(f\"Total number of atoms: {symmetric.atoms.get_number_of_atoms()}\")\nprint(f\"Total layers: {len(layers)}\")\nprint(f\"Top: {layers[-1]['composition']}\")\nprint(f\"Bottom: {layers[0]['composition']}\")\n</code></pre>"},{"location":"tutorials/surface_building/#step-4-stoichiometry-validation","title":"Step 4: Stoichiometry Validation","text":"<p>Check if your surface has the expected composition:</p> <pre><code># Get stoichiometry\nstoich = surface.get_stoichiometry()\nprint(f\"Normalized stoichiometry: {stoich}\")\n\n# Check against expected\nresult = surface.check_stoichiometry(\n    expected={\"La\": 1, \"V\": 1, \"O\": 3},\n    tolerance=0.1\n)\nprint(f\"Is stoichiometric: {result['is_stoichiometric']}\")\nif result['warnings']:\n    print(f\"Warnings: {result['warnings']}\")\n\n# Layer-by-layer stoichiometry\nlayers = surface.get_layer_stoichiometry()\nfor layer in layers:\n    print(f\"z={layer['z']:.1f}: {layer['composition']}\")\n</code></pre>"},{"location":"tutorials/surface_building/#step-5-create-oxynitride-structure","title":"Step 5: Create Oxynitride Structure","text":"<pre><code>from nh3sofc.structure import DefectBuilder\n\ndefect = DefectBuilder(symmetric_surface)\n\n# Create oxynitride: replace 2/3 of O with N, add 10% vacancies\noxynitride = defect.create_oxynitride(\n    nitrogen_fraction=0.67,      # 2/3 O \u2192 N\n    vacancy_concentration=0.10,  # 10% vacancies (x in LaVON2-x)\n)\n\nprint(f\"Formula: {oxynitride.get_chemical_formula()}\")\n</code></pre>"},{"location":"tutorials/surface_building/#defect-placement-strategies","title":"Defect Placement Strategies","text":"<p>Control where defects are placed using <code>placement</code> and preference parameters. The placement uses probability-weighted selection - atoms in preferred regions have higher probability of being selected, but selection is still stochastic, so each configuration is unique.</p> <pre><code># Random placement (default) - uniform probability\noxynitride_random = defect.create_oxynitride(\n    vacancy_element=\"N\",\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.10,\n    placement=\"random\"\n)\n\n# Surface-populated: N preferentially at surface\n# surface_n_preference controls how strongly N prefers surface:\n#   0.5 = random distribution\n#   0.7 = ~70% of surface anions will be N (default)\n#   0.9 = ~90% of surface anions will be N\n# z_threshold defines what fraction of slab is \"surface\" (default: 0.3 = top 30%)\noxynitride_surface = defect.create_oxynitride(\n    vacancy_element=\"N\",\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.10,\n    placement=\"surface\",\n    surface_n_preference=0.8,   # 80% of surface anions are N\n    vacancy_preference=0.6,     # Vacancies slightly prefer surface\n    z_threshold=0.3,            # Top 30% of slab is \"surface\"\n)\n\n# Near-N: vacancies preferentially near existing N atoms\n# vacancy_preference controls how strongly vacancies prefer being near N\noxynitride_near_n = defect.create_oxynitride(\n    vacancy_element=\"N\",\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.10,\n    placement=\"near_N\",\n    vacancy_preference=0.7,     # Vacancies moderately prefer being near N\n)\n</code></pre>"},{"location":"tutorials/surface_building/#preference-parameters","title":"Preference Parameters","text":"Parameter Range Description <code>surface_n_preference</code> 0.5-1.0 For \"surface\" placement: fraction of surface anions that are N <code>vacancy_preference</code> 0.5-1.0 Preference strength for vacancy placement (surface or near-N) <code>z_threshold</code> 0.0-1.0 Fraction of slab height considered as \"surface\" (default: 0.3 = top 30%) <ul> <li>0.5 = Random (no preference)</li> <li>0.7 = Moderate preference (default)</li> <li>0.9-1.0 = Strong preference (most defects in target region)</li> </ul> <p>Important: The <code>z_threshold</code> used during defect creation must match the value used in <code>analyze_defect_distribution()</code> for consistent analysis.</p>"},{"location":"tutorials/surface_building/#generate-configuration-pool","title":"Generate Configuration Pool","text":"<p>For screening studies, generate multiple configurations with all strategies. Each configuration is unique due to probability-weighted selection:</p> <pre><code>from nh3sofc import save_configurations\n\n# Generate pool of candidate structures with preference settings\npool = defect.create_oxynitride_pool(\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.10,\n    n_configs_per_strategy=5,       # 5 configs \u00d7 3 strategies = 15 total\n    surface_n_preference=0.8,       # For \"surface\": 80% surface anions are N\n    vacancy_preference=0.6,         # Moderate vacancy preference\n    z_threshold=0.3,                # Top 30% is \"surface\" (for analysis consistency)\n)\n\nprint(f\"Generated {len(pool)} configurations\")\n\n# Extract atoms and create descriptive names\nconfigs = [config['atoms'] for config in pool]\nnames = [f\"{config['placement']}_{config['config_id']}\" for config in pool]\n\n# Option 1: Auto-generate work directory (creates folder like \"work/slab_La8V8N16O8_40atoms/\")\nresult = save_configurations(configs, names=names, prefix=\"oxynitride\")\nprint(f\"Saved to: {result['work_dir']}\")\n\n# Option 2: Specify work directory explicitly\nresult = save_configurations(configs, \"work/oxynitrides/LaVON2_001\", names=names)\n\nfor config, p in zip(pool, result[\"configs\"]):\n    print(f\"Saved {p['poscar'].name}: {config['atoms'].get_chemical_formula()}\")\n\n# Each config dict contains:\n# - atoms: the Atoms object\n# - placement: \"random\", \"surface\", or \"near_N\"\n# - surface_n_preference, vacancy_preference: the preference values used\n# - z_threshold: the surface region definition (for consistent analysis)\n# - nitrogen_fraction, vacancy_concentration\n# - config_id: unique identifier\n</code></pre>"},{"location":"tutorials/surface_building/#analyze-defect-distribution","title":"Analyze Defect Distribution","text":"<p>Use statistical analysis to verify that defects are distributed as expected:</p> <pre><code>from nh3sofc.structure import (\n    analyze_defect_distribution,\n    analyze_oxynitride_pool,\n    print_defect_analysis,\n    plot_defect_distribution,\n)\n\n# Analyze a single configuration\nstats = analyze_defect_distribution(\n    oxynitride_surface,\n    z_threshold=0.3,  # Top 30% of slab height is \"surface\"\n)\n\nprint(f\"N atoms in surface region: {stats['n_surface']} / {stats['n_total']}\")\nprint(f\"Surface N/(N+O) ratio: {stats['surface_n_ratio']:.1%}\")\nprint(f\"Bulk N/(N+O) ratio: {stats['bulk_n_ratio']:.1%}\")\n\n# With vacancy analysis (requires original structure for comparison)\nstats = analyze_defect_distribution(\n    oxynitride_surface,\n    reference_atoms=symmetric_surface.atoms,  # Original before defects\n    z_threshold=0.3,\n    near_n_cutoff=3.0,  # Count vacancies within 3 \u00c5 of N\n)\n\nprint(f\"Vacancies in surface: {stats['vacancy_surface']} / {stats['vacancy_total']}\")\nprint(f\"Vacancies near N: {stats['vacancy_near_n']} ({stats['vacancy_near_n_fraction']:.1%})\")\n\n# Analyze entire pool and compare strategies\n# Use same z_threshold as create_oxynitride_pool() for consistent results\npool_stats = analyze_oxynitride_pool(pool, z_threshold=pool[0][\"z_threshold\"])\n\n# Print formatted summary\nprint_defect_analysis(pool_stats, title=\"Oxynitride Pool Analysis\")\n</code></pre> <p>Example output: <pre><code>============================================================\nOxynitride Pool Analysis\n============================================================\n\nTotal configurations: 15\n\nRANDOM Strategy (5 configs):\n  Surface N ratio: 48.2% \u00b1 5.3%\n  Bulk N ratio: 51.1% \u00b1 4.8%\n  N in surface: 32.5% \u00b1 3.2%\n\nSURFACE Strategy (5 configs):\n  Surface N ratio: 72.4% \u00b1 4.1%\n  Bulk N ratio: 38.6% \u00b1 3.9%\n  N in surface: 48.3% \u00b1 2.8%\n\nNEAR_N Strategy (5 configs):\n  Surface N ratio: 50.1% \u00b1 6.2%\n  Bulk N ratio: 49.8% \u00b1 5.1%\n  Vacancies near N: 68.3% \u00b1 8.5%\n============================================================\n</code></pre></p>"},{"location":"tutorials/surface_building/#visualize-defect-distribution","title":"Visualize Defect Distribution","text":"<p>Create bar plots to visualize the analysis results:</p> <pre><code># Plot single structure analysis\nplot_defect_distribution(stats, title=\"LaVON2 Surface Structure\")\n\n# Plot pool comparison across strategies (with error bars)\nplot_defect_distribution(\n    pool_stats,\n    title=\"Oxynitride Pool Comparison\",\n    save_path=\"work/defect_distribution.png\",  # Save to file\n    show=True,  # Also display interactively\n)\n</code></pre> <p>The plots show: - Single structure: N/O atom counts in surface vs bulk regions, plus vacancy distribution - Pool comparison: N/(N+O) ratios by strategy with error bars, comparing surface vs bulk enrichment</p>"},{"location":"tutorials/surface_building/#step-6-visualize-and-save","title":"Step 6: Visualize and Save","text":"<pre><code>from nh3sofc import save_structure, write_poscar\nfrom ase.visualize import view\n\n# Option 1: Auto-generate meaningful work directory (recommended)\n# Creates folder like \"work/slab_La8V8O24_40atoms/\"\npaths = save_structure(surface.atoms, name=\"surface\", formats=[\"poscar\", \"cif\"])\nprint(f\"Saved to: {paths['work_dir']}\")\n\n# Option 2: Specify work directory explicitly\nwork_dir = \"work/surfaces/LaVO3_001\"\nsave_structure(bulk.atoms, work_dir, \"bulk\", formats=[\"poscar\", \"cif\"])\nsave_structure(surface.atoms, work_dir, \"surface\", formats=[\"poscar\", \"cif\"])\nsave_structure(oxynitride, work_dir, \"oxynitride\", formats=[\"poscar\", \"cif\"])\n\n# Option 3: Save individual POSCAR files directly\nwrite_poscar(bulk.atoms, f\"{work_dir}/POSCAR_bulk\")\nwrite_poscar(surface.atoms, f\"{work_dir}/POSCAR_surface\")\nwrite_poscar(oxynitride, f\"{work_dir}/POSCAR_oxynitride\")\n\n# Visualize (if GUI available)\n# view(oxynitride)\n</code></pre>"},{"location":"tutorials/surface_building/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/surface_building/#surface-construction","title":"Surface Construction","text":"<ol> <li>Check polarity - Always check if your surface is polar using <code>check_polarity()</code></li> <li>Use symmetric slabs - For polar surfaces, use <code>symmetric=True</code> or <code>create_symmetric_slab()</code></li> <li>Sufficient layers - Use at least 5-7 layers for accurate surface properties</li> <li>Vacuum spacing - 15-20 \u00c5 is typically sufficient to avoid image interactions</li> <li>Fix bottom atoms - Fix 2-3 bottom layers to simulate bulk behavior</li> <li>Layer identification - Use <code>identify_layers()</code> with default auto-tolerance; it correctly groups atoms in complex materials like perovskites where atoms in the same layer may have slightly different z-positions</li> </ol>"},{"location":"tutorials/surface_building/#polarity-handling","title":"Polarity Handling","text":"Surface Type Polarity Recommendation Perovskite (001) Polar Use symmetric slab or dipole correction Perovskite (110) Polar Use symmetric slab"},{"location":"tutorials/surface_building/#vasp-settings-for-polar-surfaces","title":"VASP Settings for Polar Surfaces","text":"<p>If you cannot use a symmetric slab, add dipole corrections to VASP:</p> <pre><code>from nh3sofc.calculators.vasp import VASPInputGenerator\n\nvasp = VASPInputGenerator(surface.atoms, calc_type=\"relax\")\nvasp.set_surface_settings()  # Adds IDIPOL=3, LDIPOL=.TRUE.\n</code></pre>"},{"location":"tutorials/surface_building/#complete-example","title":"Complete Example","text":"<pre><code>from nh3sofc.structure import (\n    BulkStructure,\n    SurfaceBuilder,\n    DefectBuilder\n)\nfrom nh3sofc import save_structure, save_configurations\n\n# 1. Load bulk perovskite\nbulk = BulkStructure.from_cif(\"LaVO3.cif\")\n\n# 2. Create supercell for sufficient surface area\nsupercell = bulk.make_supercell((2, 2, 1))\n\n# 3. Create symmetric surface with LaO termination\nbuilder = SurfaceBuilder(supercell)\n\nsurface = builder.create_symmetric_slab(\n    miller_index=(0, 0, 1),\n    termination={\"La\": 1, \"O\": 1},  # LaO termination\n    layers=7,\n    vacuum=15.0,\n    fix_bottom=2,\n)\n\n# 4. Check polarity\npolarity = surface.check_polarity()\nprint(f\"Dipole: {polarity['dipole_z']:.2f} e\u00b7\u00c5\")\n\n# Save the clean surface (auto-generates work_dir like \"work/slab_La8V8O24_40atoms/\")\npaths = save_structure(surface.atoms, name=\"clean_surface\", prefix=\"LaO_term\")\nwork_dir = paths[\"work_dir\"]\nprint(f\"Clean surface saved to: {work_dir}\")\n\n# 5. Generate oxynitride configuration pool\ndefect = DefectBuilder(surface)\npool = defect.create_oxynitride_pool(\n    nitrogen_fraction=0.67,\n    vacancy_concentration=0.10,\n    n_configs_per_strategy=5,\n)\n\nprint(f\"Generated {len(pool)} configurations\")\n\n# 6. Save all configurations (in same work_dir as clean surface)\nconfigs = [config['atoms'] for config in pool]\nnames = [f\"{config['placement']}_{config['config_id']}\" for config in pool]\n\nresult = save_configurations(configs, work_dir, names=names)\n\nfor config, p in zip(pool, result[\"configs\"]):\n    print(f\"Saved {p['poscar'].name}: {config['atoms'].get_chemical_formula()}\")\n\nprint(f\"\\nAll configurations saved to: {work_dir}\")\n</code></pre>"},{"location":"tutorials/surface_building/#next-steps","title":"Next Steps","text":"<ul> <li>Adsorbate Placement - Place NH3 on the surface</li> <li>VASP Calculations - Optimize the structure</li> </ul>"},{"location":"tutorials/surface_comparison/","title":"Tutorial: Surface Comparison","text":"<p>This tutorial covers comparing and ranking catalyst surfaces for NH3 decomposition.</p>"},{"location":"tutorials/surface_comparison/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Compare energy profiles across surfaces</li> <li>Rank surfaces by activity</li> <li>Create volcano plots</li> <li>Identify optimal catalysts</li> </ul>"},{"location":"tutorials/surface_comparison/#step-1-collect-energy-profiles","title":"Step 1: Collect Energy Profiles","text":"<pre><code>from nh3sofc.analysis import SurfaceComparator\n\n# Energy profiles from DFT calculations\nsurfaces = {\n    'LaO-termination': {\n        'NH3*': 0.0,\n        'NH2*+H*': 0.8,\n        'NH*+2H*': 1.5,\n        'N*+3H*': 1.2,\n    },\n    'VO2-termination': {\n        'NH3*': 0.0,\n        'NH2*+H*': 0.6,\n        'NH*+2H*': 1.2,\n        'N*+3H*': 0.9,\n    },\n    'LaO-vac10%': {\n        'NH3*': 0.0,\n        'NH2*+H*': 0.7,\n        'NH*+2H*': 1.3,\n        'N*+3H*': 1.0,\n    },\n}\n\ncomparator = SurfaceComparator(surfaces)\n</code></pre>"},{"location":"tutorials/surface_comparison/#step-2-rank-by-energy-span","title":"Step 2: Rank by Energy Span","text":"<p>The energy span model identifies the thermodynamic driving force:</p> <pre><code>ranking = comparator.rank_by_energy_span()\n\nprint(\"Surface Ranking (by activity):\")\nfor i, (name, span) in enumerate(ranking, 1):\n    print(f\"  {i}. {name}: \u03b4E = {span:.3f} eV\")\n</code></pre> <p>Lower energy span = higher activity.</p>"},{"location":"tutorials/surface_comparison/#step-3-rank-by-maximum-barrier","title":"Step 3: Rank by Maximum Barrier","text":"<p>Using BEP-estimated barriers:</p> <pre><code>ranking = comparator.rank_by_max_barrier()\n\nprint(\"\\nRanking by Maximum Barrier:\")\nfor i, (name, barrier) in enumerate(ranking, 1):\n    print(f\"  {i}. {name}: E_a,max = {barrier:.3f} eV\")\n</code></pre>"},{"location":"tutorials/surface_comparison/#step-4-get-best-surface","title":"Step 4: Get Best Surface","text":"<pre><code># By energy span\nbest = comparator.get_best_surface(method=\"energy_span\")\nprint(f\"\\nBest surface (energy span): {best}\")\n\n# By max barrier\nbest = comparator.get_best_surface(method=\"max_barrier\")\nprint(f\"Best surface (max barrier): {best}\")\n</code></pre>"},{"location":"tutorials/surface_comparison/#step-5-visualize-comparison","title":"Step 5: Visualize Comparison","text":""},{"location":"tutorials/surface_comparison/#energy-profile-comparison","title":"Energy Profile Comparison","text":"<pre><code>comparator.plot_energy_profiles(\"energy_profiles.png\")\n</code></pre>"},{"location":"tutorials/surface_comparison/#custom-plot","title":"Custom Plot","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\nfig, ax = plt.subplots(figsize=(10, 6))\n\nsteps = list(list(surfaces.values())[0].keys())\nx = np.arange(len(steps))\ncolors = ['blue', 'red', 'green']\n\nfor (name, profile), color in zip(surfaces.items(), colors):\n    energies = [profile[s] for s in steps]\n    ax.plot(x, energies, 'o-', label=name, color=color, markersize=8)\n\nax.set_xticks(x)\nax.set_xticklabels(steps, rotation=45, ha='right')\nax.set_ylabel('Energy (eV)')\nax.set_title('NH3 Decomposition Energy Profiles')\nax.legend()\nax.axhline(0, color='gray', linestyle='--', alpha=0.5)\n\nplt.tight_layout()\nplt.savefig('comparison.png', dpi=150)\n</code></pre>"},{"location":"tutorials/surface_comparison/#step-6-volcano-plot","title":"Step 6: Volcano Plot","text":"<pre><code>from nh3sofc.analysis import create_volcano_plot\n\n# Descriptor (e.g., N binding energy)\ndescriptors = {\n    'LaO-termination': -0.5,\n    'VO2-termination': -0.8,\n    'LaO-vac10%': -0.6,\n}\n\n# Activity metric (e.g., TOF or -energy_span)\nactivities = {\n    name: -span for name, span in comparator.rank_by_energy_span()\n}\n\ncreate_volcano_plot(\n    descriptors,\n    activities,\n    xlabel='N Binding Energy (eV)',\n    ylabel='-Energy Span (eV)',\n    filename='volcano.png'\n)\n</code></pre>"},{"location":"tutorials/surface_comparison/#manual-volcano-plot","title":"Manual Volcano Plot","text":"<pre><code>import matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8, 6))\n\nfor name in surfaces:\n    x = descriptors[name]\n    y = activities[name]\n    ax.scatter(x, y, s=100, label=name)\n    ax.annotate(name, (x, y), xytext=(5, 5), textcoords='offset points')\n\nax.set_xlabel('N Binding Energy (eV)')\nax.set_ylabel('-Energy Span (eV)')\nax.set_title('Volcano Plot')\n\nplt.tight_layout()\nplt.savefig('volcano.png', dpi=150)\n</code></pre>"},{"location":"tutorials/surface_comparison/#step-7-statistical-analysis","title":"Step 7: Statistical Analysis","text":"<pre><code>import pandas as pd\n\n# Create DataFrame\ndata = []\nfor name, profile in surfaces.items():\n    row = {'surface': name}\n    row.update(profile)\n    row['energy_span'] = comparator.get_energy_span(name)\n    row['max_barrier'] = comparator.get_max_barrier(name)\n    data.append(row)\n\ndf = pd.DataFrame(data)\nprint(df.to_string(index=False))\n\n# Save\ndf.to_csv('surface_comparison.csv', index=False)\n</code></pre>"},{"location":"tutorials/surface_comparison/#complete-example","title":"Complete Example","text":"<pre><code>from nh3sofc.analysis import SurfaceComparator, RDSAnalyzer\nfrom nh3sofc.workflows import DecompositionWorkflow\n\n# 1. Collect results from multiple workflows\nsurfaces = {}\n\nfor termination in ['LaO', 'VO2']:\n    workflow = DecompositionWorkflow(\n        nh3_on_slab=slabs[termination],\n        work_dir=f\"./{termination}\",\n    )\n\n    # After calculations complete\n    profile = workflow.get_energy_profile(reference=\"NH3\")\n    surfaces[termination] = profile\n\n# 2. Compare\ncomparator = SurfaceComparator(surfaces)\n\n# 3. Rank\nranking = comparator.rank_by_energy_span()\nprint(\"Ranking:\")\nfor i, (name, span) in enumerate(ranking, 1):\n    print(f\"  {i}. {name}: {span:.3f} eV\")\n\n# 4. RDS for each surface\nfor name, profile in surfaces.items():\n    analyzer = RDSAnalyzer()\n    analyzer.set_pathway(profile)\n    rds, dE = analyzer.find_rds_thermodynamic()\n    print(f\"{name} RDS: {rds}\")\n\n# 5. Plot comparison\ncomparator.plot_energy_profiles(\"comparison.png\")\n\n# 6. Best surface\nbest = comparator.get_best_surface()\nprint(f\"\\nRecommended surface: {best}\")\n</code></pre>"},{"location":"tutorials/surface_comparison/#scoring-function","title":"Scoring Function","text":"<p>Custom multi-criteria ranking:</p> <pre><code>def score_surface(profile, barriers, weights=None):\n    \"\"\"Score surface by multiple criteria.\"\"\"\n    if weights is None:\n        weights = {\n            'energy_span': 0.4,\n            'max_barrier': 0.4,\n            'n_binding': 0.2,\n        }\n\n    scores = {\n        'energy_span': -max(profile.values()),\n        'max_barrier': -max(barriers.values()),\n        'n_binding': -profile.get('N*+3H*', 0),\n    }\n\n    total = sum(w * scores[k] for k, w in weights.items())\n    return total\n\n# Apply\nsurface_scores = {}\nfor name in surfaces:\n    profile = surfaces[name]\n    barriers = comparator.get_bep_barriers(name)\n    surface_scores[name] = score_surface(profile, barriers)\n\n# Rank\nranked = sorted(surface_scores.items(), key=lambda x: -x[1])\nprint(\"\\nCustom Ranking:\")\nfor name, score in ranked:\n    print(f\"  {name}: {score:.3f}\")\n</code></pre>"},{"location":"tutorials/surface_comparison/#best-practices","title":"Best Practices","text":"<ol> <li>Consistent DFT - Use same settings for all surfaces</li> <li>Multiple metrics - Don't rely on single criterion</li> <li>Include barriers - Energy span alone may miss kinetics</li> <li>Validate - Compare with experimental data</li> </ol>"},{"location":"tutorials/surface_comparison/#next-steps","title":"Next Steps","text":"<ul> <li>Microkinetic Modeling - Predict TOF for each surface</li> <li>High-Throughput Screening - Screen more compositions</li> </ul>"},{"location":"tutorials/surface_stability/","title":"Tutorial: Surface Stability Analysis","text":"<p>This tutorial covers calculating and comparing surface energies to determine which crystal facets are thermodynamically most stable.</p>"},{"location":"tutorials/surface_stability/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand surface energy and its calculation</li> <li>Build surfaces for different Miller indices</li> <li>Calculate surface energies from DFT results</li> <li>Rank surfaces by thermodynamic stability</li> <li>Handle polar and non-stoichiometric surfaces</li> </ul>"},{"location":"tutorials/surface_stability/#theory-surface-energy","title":"Theory: Surface Energy","text":"<p>Surface energy (\u03b3) measures the energy cost of creating a surface:</p> <pre><code>\u03b3 = (E_slab - n \u00d7 E_bulk) / (2 \u00d7 A)\n</code></pre> <p>Where: - <code>E_slab</code> = Total energy of the slab (from DFT) - <code>E_bulk</code> = Bulk energy per atom (from DFT) - <code>n</code> = Number of atoms in the slab - <code>A</code> = Surface area - Factor of 2 accounts for two surfaces (top and bottom)</p> <p>Units: Typically reported in J/m\u00b2 (1 eV/\u00c5\u00b2 = 16.02 J/m\u00b2)</p> <p>Lower surface energy = more stable surface</p>"},{"location":"tutorials/surface_stability/#step-1-build-the-bulk-structure","title":"Step 1: Build the Bulk Structure","text":"<pre><code>from ase.spacegroup import crystal\nfrom nh3sofc.structure import SurfaceBuilder\n\n# Example: CeO2 fluorite structure (Fm-3m, space group 225)\nceo2_bulk = crystal(\n    symbols=['Ce', 'O'],\n    basis=[(0, 0, 0), (0.25, 0.25, 0.25)],\n    spacegroup=225,\n    cellpar=[5.411, 5.411, 5.411, 90, 90, 90]\n)\n\nprint(f\"Bulk: {ceo2_bulk.get_chemical_formula()}\")\nprint(f\"Atoms per unit cell: {len(ceo2_bulk)}\")\n</code></pre>"},{"location":"tutorials/surface_stability/#step-2-build-surfaces-for-different-miller-indices","title":"Step 2: Build Surfaces for Different Miller Indices","text":"<pre><code>import numpy as np\nfrom nh3sofc.structure import SurfaceBuilder\n\nbuilder = SurfaceBuilder(ceo2_bulk)\n\n# Common low-index surfaces\nmiller_indices = [(1,1,1), (1,1,0), (1,0,0)]\n\nsurfaces = {}\nfor miller in miller_indices:\n    miller_str = ''.join(map(str, miller))\n\n    slab = builder.create_surface(\n        miller_index=miller,\n        layers=6,          # Enough layers for convergence\n        vacuum=15.0,       # Vacuum thickness in \u00c5\n    )\n\n    # Calculate surface area\n    cell = slab.atoms.cell\n    area = np.linalg.norm(np.cross(cell[0], cell[1]))\n\n    surfaces[miller_str] = {\n        'slab': slab,\n        'n_atoms': len(slab.atoms),\n        'area': area,\n    }\n\n    # Check stoichiometry\n    n_ce = sum(1 for a in slab.atoms if a.symbol == 'Ce')\n    n_o = sum(1 for a in slab.atoms if a.symbol == 'O')\n\n    print(f\"({miller_str}): {len(slab.atoms)} atoms, \"\n          f\"area = {area:.2f} \u00c5\u00b2, Ce{n_ce}O{n_o}\")\n</code></pre>"},{"location":"tutorials/surface_stability/#step-3-run-dft-calculations","title":"Step 3: Run DFT Calculations","text":"<p>Save structures and run VASP calculations:</p> <pre><code>from nh3sofc.calculators import VASPInputGenerator\nfrom nh3sofc import write_poscar\n\n# Save bulk for reference calculation\nwrite_poscar(ceo2_bulk, \"work/CeO2_bulk/POSCAR\")\n\n# Generate VASP inputs for each surface\nfor miller_str, data in surfaces.items():\n    work_dir = f\"work/CeO2_{miller_str}\"\n\n    vasp = VASPInputGenerator(\n        data['slab'].atoms,\n        calc_type='relax',\n        work_dir=work_dir,\n        encut=520,\n        kspacing=0.03,\n    )\n    vasp.generate_all()\n\n    print(f\"Generated inputs: {work_dir}\")\n</code></pre>"},{"location":"tutorials/surface_stability/#step-4-calculate-surface-energies","title":"Step 4: Calculate Surface Energies","text":"<p>After DFT calculations complete:</p> <pre><code>from nh3sofc.analysis import SurfaceEnergyCalculator\n\n# Get bulk energy per atom from your DFT calculation\n# E_bulk = total energy / n_atoms from bulk OUTCAR\ne_bulk_per_atom = -9.876  # eV/atom (replace with your value)\n\n# Initialize calculator\ncalc = SurfaceEnergyCalculator(e_bulk_per_atom=e_bulk_per_atom)\n\n# Calculate surface energy for each facet\nresults = {}\n\nfor miller_str, data in surfaces.items():\n    # Get slab energy from VASP OUTCAR\n    # e_slab = parse_outcar(f\"work/CeO2_{miller_str}/OUTCAR\")\n    e_slab = -712.345  # Example - replace with actual value\n\n    # Calculate in eV/\u00c5\u00b2\n    gamma_ev = calc.calculate(\n        e_slab=e_slab,\n        n_atoms=data['n_atoms'],\n        area=data['area'],\n        symmetric=True,  # Top and bottom surfaces equivalent\n    )\n\n    # Convert to J/m\u00b2\n    gamma_j = calc.calculate_j_m2(\n        e_slab=e_slab,\n        n_atoms=data['n_atoms'],\n        area=data['area'],\n        symmetric=True,\n    )\n\n    results[miller_str] = {\n        'gamma_ev_A2': gamma_ev,\n        'gamma_J_m2': gamma_j,\n        'area': data['area'],\n    }\n</code></pre>"},{"location":"tutorials/surface_stability/#step-5-rank-surfaces-by-stability","title":"Step 5: Rank Surfaces by Stability","text":"<pre><code># Sort by surface energy (ascending = most stable first)\nranked = sorted(results.items(), key=lambda x: x[1]['gamma_J_m2'])\n\nprint(\"\\n\" + \"=\"*60)\nprint(\"Surface Stability Ranking\")\nprint(\"=\"*60)\nprint(f\"\\nBulk reference: {e_bulk_per_atom:.4f} eV/atom\")\nprint(\"\\n{:&lt;10} {:&gt;12} {:&gt;12} {:&gt;15}\".format(\n    \"Surface\", \"\u03b3 (eV/\u00c5\u00b2)\", \"\u03b3 (J/m\u00b2)\", \"Stability\"\n))\nprint(\"-\"*60)\n\nfor i, (miller, data) in enumerate(ranked):\n    stability = \"Most stable\" if i == 0 else \"\"\n    print(f\"({miller})      {data['gamma_ev_A2']:&gt;12.4f} \"\n          f\"{data['gamma_J_m2']:&gt;12.2f} {stability:&gt;15}\")\n\nprint(\"\\n\" + \"=\"*60)\nstability_order = \" &gt; \".join([f\"({m})\" for m, _ in ranked])\nprint(f\"Stability order: {stability_order}\")\nprint(\"=\"*60)\n</code></pre>"},{"location":"tutorials/surface_stability/#step-6-visualize-results","title":"Step 6: Visualize Results","text":"<p>Use the built-in plotting function:</p> <pre><code>from nh3sofc.analysis import plot_surface_stability\n\n# Collect surface energies\nenergies = {miller: data['gamma_J_m2'] for miller, data in results.items()}\n\n# Plot (sorted by stability automatically)\nfig, ax = plot_surface_stability(\n    energies,\n    title=\"CeO2 Surface Stability\",\n    filename=\"surface_stability.png\"\n)\n\n# Output: Bar chart with green (stable) to red (unstable) colors\n</code></pre> <p>The plot shows: - Bars sorted by stability (most stable on left) - Color gradient: green (stable) \u2192 red (unstable) - Energy values labeled on each bar</p>"},{"location":"tutorials/surface_stability/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"tutorials/surface_stability/#polar-surfaces","title":"Polar Surfaces","text":"<p>Some surfaces (e.g., CeO2 (100)) are polar and may require: - Reconstruction - Non-stoichiometric termination - Chemical potential corrections</p> <pre><code># For non-stoichiometric slabs, use chemical potentials\ndef surface_energy_nonstoich(e_slab, n_ce, n_o, area,\n                              e_bulk_ceo2, mu_o):\n    \"\"\"\n    \u03b3 = (E_slab - n_Ce\u00d7\u03bc_Ce - n_O\u00d7\u03bc_O) / (2A)\n\n    With constraint: \u03bc_Ce + 2\u03bc_O = E_bulk(CeO2)\n    So: \u03bc_Ce = E_bulk - 2\u03bc_O\n    \"\"\"\n    mu_ce = e_bulk_ceo2 - 2 * mu_o\n    e_ref = n_ce * mu_ce + n_o * mu_o\n    gamma = (e_slab - e_ref) / (2 * area)\n    return gamma\n</code></pre>"},{"location":"tutorials/surface_stability/#asymmetric-slabs","title":"Asymmetric Slabs","text":"<p>If top and bottom surfaces are different:</p> <pre><code>gamma = calc.calculate(\n    e_slab=e_slab,\n    n_atoms=n_atoms,\n    area=area,\n    symmetric=False,  # Only one surface counted\n)\n</code></pre>"},{"location":"tutorials/surface_stability/#convergence-testing","title":"Convergence Testing","text":"<p>Surface energy should converge with slab thickness:</p> <pre><code># Test convergence with number of layers\nlayers_to_test = [4, 6, 8, 10]\nconvergence = {}\n\nfor n_layers in layers_to_test:\n    slab = builder.create_surface(\n        miller_index=(1,1,1),\n        layers=n_layers,\n        vacuum=15.0,\n    )\n    # Run DFT and calculate \u03b3\n    # convergence[n_layers] = gamma\n\n# Plot convergence\nplt.plot(layers_to_test, [convergence[n] for n in layers_to_test], 'o-')\nplt.xlabel('Number of layers')\nplt.ylabel('Surface energy (J/m\u00b2)')\nplt.title('Convergence test')\n</code></pre>"},{"location":"tutorials/surface_stability/#complete-example-ceo2","title":"Complete Example: CeO2","text":"<pre><code>from ase.spacegroup import crystal\nfrom ase.io import read\nimport numpy as np\nfrom nh3sofc.structure import SurfaceBuilder\nfrom nh3sofc.analysis import SurfaceEnergyCalculator\nfrom nh3sofc.calculators import VASPInputGenerator\n\n# 1. Create bulk CeO2\nceo2_bulk = crystal(\n    symbols=['Ce', 'O'],\n    basis=[(0, 0, 0), (0.25, 0.25, 0.25)],\n    spacegroup=225,\n    cellpar=[5.411, 5.411, 5.411, 90, 90, 90]\n)\n\n# 2. Build surfaces\nbuilder = SurfaceBuilder(ceo2_bulk)\nmiller_indices = [(1,1,1), (1,1,0), (1,0,0)]\n\nfor miller in miller_indices:\n    miller_str = ''.join(map(str, miller))\n    slab = builder.create_surface(miller, layers=6, vacuum=15.0)\n\n    # Save for DFT\n    vasp = VASPInputGenerator(\n        slab.atoms,\n        calc_type='relax',\n        work_dir=f\"work/CeO2_{miller_str}\",\n    )\n    vasp.generate_all(encut=520)\n\n# 3. After DFT: Parse energies and calculate \u03b3\n# e_bulk_per_atom = parse_outcar(\"work/CeO2_bulk/OUTCAR\") / len(ceo2_bulk)\ne_bulk_per_atom = -9.876  # Replace with actual\n\ncalc = SurfaceEnergyCalculator(e_bulk_per_atom)\n\nresults = {}\nfor miller in miller_indices:\n    miller_str = ''.join(map(str, miller))\n    slab = read(f\"work/CeO2_{miller_str}/CONTCAR\")\n    # e_slab = parse_outcar(f\"work/CeO2_{miller_str}/OUTCAR\")\n    e_slab = -700.0  # Replace with actual\n\n    area = np.linalg.norm(np.cross(slab.cell[0], slab.cell[1]))\n    gamma = calc.calculate_j_m2(e_slab, len(slab), area)\n    results[miller_str] = gamma\n\n# 4. Rank\nranked = sorted(results.items(), key=lambda x: x[1])\nprint(\"Stability:\", \" &gt; \".join([f\"({m})\" for m, _ in ranked]))\n</code></pre>"},{"location":"tutorials/surface_stability/#reference-typical-surface-energies","title":"Reference: Typical Surface Energies","text":"Material Surface \u03b3 (J/m\u00b2) Notes CeO2 (111) 0.7-1.0 Most stable, O-terminated CeO2 (110) 1.0-1.5 Intermediate CeO2 (100) 2.0-2.5 Polar, may reconstruct TiO2 rutile (110) 0.5-0.8 Most stable TiO2 rutile (100) 0.9-1.2 Pt (111) 1.5-2.0 FCC most stable Pt (100) 2.0-2.5"},{"location":"tutorials/surface_stability/#next-steps","title":"Next Steps","text":"<ul> <li>Surface Comparison - Compare catalytic activity</li> <li>Adsorbate Placement - Add molecules to stable surfaces</li> <li>Defect Building - Create oxygen vacancies</li> </ul>"},{"location":"tutorials/theory/","title":"Theoretical Framework","text":"<p>This page describes the theoretical methods implemented in NH3SOFC for catalysis modeling and analysis.</p>"},{"location":"tutorials/theory/#overview","title":"Overview","text":"<p>NH3SOFC implements a comprehensive theoretical framework for computational catalysis, covering the complete workflow from electronic structure analysis to microkinetic modeling.</p> <pre><code>Electronic Structure \u2192 Descriptors \u2192 Energetics \u2192 Thermochemistry \u2192 Kinetics \u2192 Activity\n</code></pre>"},{"location":"tutorials/theory/#electronic-structure-descriptors","title":"Electronic Structure Descriptors","text":""},{"location":"tutorials/theory/#d-band-center-analysis","title":"D-Band Center Analysis","text":"<p>The d-band model (Hammer-Norskov) is fundamental for understanding adsorption on transition metals. The d-band center is defined as:</p> \\[\\varepsilon_d = \\frac{\\int \\varepsilon \\cdot \\rho_d(\\varepsilon) \\, d\\varepsilon}{\\int \\rho_d(\\varepsilon) \\, d\\varepsilon}\\] <p>where \\(\\rho_d(\\varepsilon)\\) is the d-band density of states.</p> <pre><code>from nh3sofc.analysis import DBandAnalyzer, calculate_d_band_center\n\n# Parse VASP DOSCAR and analyze d-band\nanalyzer = DBandAnalyzer.from_doscar(\"DOSCAR\")\n\n# Get d-band center for surface atoms\nd_center = analyzer.get_d_band_center(atom_index=0)\nprint(f\"D-band center: {d_center:.3f} eV (relative to Fermi)\")\n\n# Get comprehensive d-band properties\nprops = analyzer.get_d_band_properties([0, 1, 2, 3])\nfor atom, data in props.items():\n    print(f\"Atom {atom}: center={data['center']:.2f} eV, \"\n          f\"width={data['width']:.2f} eV, filling={data['filling']:.2f}\")\n\n# Average d-band center for surface atoms\navg_center = analyzer.get_surface_average_d_band_center([0, 1, 2, 3])\n</code></pre> <p>Available descriptors: - D-band center (1st moment) - D-band width (2nd moment) - D-band filling</p>"},{"location":"tutorials/theory/#adsorption-energetics","title":"Adsorption Energetics","text":""},{"location":"tutorials/theory/#adsorption-energy","title":"Adsorption Energy","text":"\\[E_{ads} = E_{ads/surf} - E_{surf} - E_{gas}\\] <pre><code>from nh3sofc.analysis import AdsorptionEnergyCalculator\n\ncalc = AdsorptionEnergyCalculator()\ncalc.set_surface_energy(-250.0)\ncalc.set_gas_reference(\"NH3\", -19.54)\n\nE_ads = calc.calculate(e_total=-270.5, adsorbate=\"NH3\")\nprint(f\"Adsorption energy: {E_ads:.3f} eV\")\n</code></pre>"},{"location":"tutorials/theory/#coverage-dependent-energies","title":"Coverage-Dependent Energies","text":"<p>Differential adsorption energy as a function of coverage:</p> \\[E_{ads}^{diff}(\\theta) = \\frac{\\partial E_{total}}{\\partial n_{ads}}\\] <pre><code>from nh3sofc.analysis import calculate_coverage_dependent_energy\n\n# energies at different coverages\nenergies = [-270.5, -290.8, -310.5]  # 1, 2, 3 adsorbates\ncoverages = [0.25, 0.5, 0.75]\n\ndiff_energies = calculate_coverage_dependent_energy(energies, coverages)\n</code></pre>"},{"location":"tutorials/theory/#thermochemistry","title":"Thermochemistry","text":""},{"location":"tutorials/theory/#harmonic-approximation-adsorbates","title":"Harmonic Approximation (Adsorbates)","text":"<p>For surface-bound species, we use the harmonic approximation:</p> \\[G = E_{DFT} + ZPE + \\int_0^T C_v \\, dT - TS_{vib}\\] <p>where the zero-point energy and vibrational entropy are calculated from vibrational frequencies.</p> <pre><code>from nh3sofc.analysis import HarmonicThermo\n\n# Frequencies from VASP frequency calculation (cm\u207b\u00b9)\nfrequencies = [3450, 3350, 1620, 1100, 580, 450]\n\nthermo = HarmonicThermo(frequencies, e_electronic=-5.23)\nG = thermo.get_gibbs_energy(temperature=700)  # K\nprint(f\"Gibbs free energy: {G:.3f} eV\")\n</code></pre>"},{"location":"tutorials/theory/#ideal-gas-thermochemistry","title":"Ideal Gas Thermochemistry","text":"<p>For gas-phase species:</p> \\[G = E_{DFT} + ZPE + H(T) - TS(T, p)\\] <p>Including translational, rotational, and vibrational contributions.</p> <pre><code>from nh3sofc.analysis import IdealGasThermo\n\nthermo = IdealGasThermo(\n    frequencies=[3450, 3350, 1620, 1100, 580, 450],\n    e_electronic=-19.54,\n    geometry=\"nonlinear\",\n    spin=0,\n    mass=17.03  # NH3\n)\n\nG = thermo.get_gibbs_energy(temperature=700, pressure=1e5)\n</code></pre>"},{"location":"tutorials/theory/#reaction-kinetics","title":"Reaction Kinetics","text":""},{"location":"tutorials/theory/#bep-relations","title":"BEP Relations","text":"<p>Br\u00f8nsted-Evans-Polanyi relations connect activation barriers to reaction energies:</p> \\[E_a = \\alpha \\cdot \\Delta E + \\beta\\] <pre><code>from nh3sofc.analysis import BEPRelation\n\n# Built-in BEP parameters for N-H dissociation\nbep = BEPRelation.for_reaction(\"N-H_dissociation\")\n\n# Estimate barrier from reaction energy\ndelta_E = 0.5  # eV (endothermic)\nbarrier = bep.estimate_barrier(delta_E)\nprint(f\"Estimated barrier: {barrier:.2f} eV\")\n\n# Or fit from your own data\ncustom_bep = BEPRelation.fit_from_data(\n    reaction_energies=[0.1, 0.3, 0.5, 0.7],\n    barriers=[0.8, 0.9, 1.0, 1.1]\n)\n</code></pre>"},{"location":"tutorials/theory/#energy-span-model-kozuch-shaik","title":"Energy Span Model (Kozuch-Shaik)","text":"<p>The energy span model identifies the TOF-determining transition state (TDTS) and TOF-determining intermediate (TDI):</p> \\[\\delta E = \\begin{cases} T_{TDTS} - I_{TDI} &amp; \\text{if TDTS after TDI} \\\\ T_{TDTS} - I_{TDI} + \\Delta G_r &amp; \\text{if TDTS before TDI} \\end{cases}\\] <pre><code>from nh3sofc.analysis import EnergySpanModel\n\n# Define intermediates and transition states\nintermediates = {\n    \"NH3*\": 0.0,\n    \"NH2*+H*\": 0.3,\n    \"NH*+2H*\": 0.5,\n    \"N*+3H*\": 0.2,\n}\n\ntransition_states = {\n    \"TS1\": 0.8,   # NH3* \u2192 NH2*+H*\n    \"TS2\": 1.1,   # NH2*+H* \u2192 NH*+2H*\n    \"TS3\": 0.9,   # NH*+2H* \u2192 N*+3H*\n}\n\nmodel = EnergySpanModel(intermediates, transition_states, delta_G_rxn=-0.5)\n\n# Get energy span and TOF-determining species\nspan = model.get_energy_span()\ntdi, tdts = model.get_determining_states()\nprint(f\"Energy span: {span:.2f} eV\")\nprint(f\"TOF-determining intermediate: {tdi}\")\nprint(f\"TOF-determining transition state: {tdts}\")\n</code></pre>"},{"location":"tutorials/theory/#rate-determining-step-analysis","title":"Rate-Determining Step Analysis","text":"<p>Multiple methods for RDS identification:</p> <pre><code>from nh3sofc.analysis import RDSAnalyzer\n\nanalyzer = RDSAnalyzer(\n    intermediates=intermediates,\n    transition_states=transition_states\n)\n\n# Method 1: Thermodynamic (highest reaction energy)\nrds_thermo = analyzer.find_rds_thermodynamic()\n\n# Method 2: BEP-estimated barriers\nrds_bep = analyzer.find_rds_bep()\n\n# Method 3: Energy span model\nrds_span = analyzer.find_rds_energy_span()\n\n# Summary\nanalyzer.print_summary()\n</code></pre>"},{"location":"tutorials/theory/#microkinetic-modeling","title":"Microkinetic Modeling","text":""},{"location":"tutorials/theory/#steady-state-surface-kinetics","title":"Steady-State Surface Kinetics","text":"<p>Solve for steady-state coverages using the mean-field approximation:</p> \\[\\frac{d\\theta_i}{dt} = \\sum_j \\nu_{ij} r_j = 0\\] <pre><code>from nh3sofc.analysis import MicroKineticModel\n\nmodel = MicroKineticModel()\n\n# Define elementary steps\nmodel.add_step(\"NH3_ads\", barrier_fwd=0.0, barrier_rev=0.5,\n               reactants=[\"*\"], products=[\"NH3*\"])\nmodel.add_step(\"NH3_diss\", barrier_fwd=0.8, barrier_rev=0.5,\n               reactants=[\"NH3*\", \"*\"], products=[\"NH2*\", \"H*\"])\n# ... more steps\n\n# Solve for coverages at reaction conditions\ncoverages = model.solve_steady_state(temperature=700, pressures={\"NH3\": 0.1})\n\n# Calculate turnover frequency\ntof = model.calculate_tof(coverages)\n</code></pre>"},{"location":"tutorials/theory/#nh3-decomposition-model","title":"NH3 Decomposition Model","text":"<p>Pre-configured model for NH3 decomposition with default parameters:</p> <pre><code>from nh3sofc.analysis import NH3DecompositionModel\n\nmodel = NH3DecompositionModel()\n\n# Use default barriers or customize\nmodel.set_barrier(\"NH3_diss\", 0.85)\n\n# Solve and analyze\ncoverages = model.solve(temperature=700)\ntof = model.get_tof(coverages)\n\n# Sensitivity analysis\nsensitivity = model.degree_of_rate_control()\n</code></pre>"},{"location":"tutorials/theory/#catalyst-screening","title":"Catalyst Screening","text":""},{"location":"tutorials/theory/#volcano-plots","title":"Volcano Plots","text":"<p>Visualize activity as a function of binding energy descriptor:</p> <pre><code>from nh3sofc.analysis import SurfaceComparator, ActivityDescriptor\n\n# Compare multiple catalyst surfaces\ncomparator = SurfaceComparator()\n\ncomparator.add_surface(\"Ni(111)\",\n    intermediates={\"NH3*\": -0.8, \"NH2*\": -0.5, ...},\n    barriers={\"TS1\": 0.9, ...})\ncomparator.add_surface(\"Pt(111)\", ...)\ncomparator.add_surface(\"Ru(0001)\", ...)\n\n# Generate volcano plot\ncomparator.plot_volcano(\n    descriptor=\"NH3*\",  # Use NH3 binding as descriptor\n    activity_metric=\"energy_span\"\n)\n\n# Find optimal catalyst\nbest = comparator.get_best_catalyst(metric=\"energy_span\")\nprint(f\"Best catalyst: {best}\")\n</code></pre>"},{"location":"tutorials/theory/#activity-prediction-from-descriptors","title":"Activity Prediction from Descriptors","text":"<pre><code>from nh3sofc.analysis import ActivityDescriptor\n\ndescriptor = ActivityDescriptor()\n\n# Fit scaling relation from known data\ndescriptor.fit_scaling_relation(\n    descriptor_values=[-0.8, -0.6, -0.4, -0.2],  # NH3 binding\n    activities=[1e5, 1e6, 1e7, 1e6]  # TOF\n)\n\n# Predict activity for new catalyst\npredicted_activity = descriptor.predict_activity(descriptor_value=-0.5)\n</code></pre>"},{"location":"tutorials/theory/#exsolution-thermodynamics","title":"Exsolution Thermodynamics","text":"<p>Specialized analysis for metal exsolution from perovskites:</p> <pre><code>from nh3sofc.analysis import ExsolutionEnergetics\n\nexsol = ExsolutionEnergetics()\n\n# Calculate exsolution driving force\ndriving_force = exsol.calculate_driving_force(\n    e_pristine=-300.0,\n    e_defective=-298.5,\n    e_segregated=-299.0,\n    temperature=1073,  # K\n    p_O2=1e-20  # atm\n)\n\n# Vacancy formation energy\ne_vac = exsol.vacancy_formation_energy(\n    e_defective=-298.5,\n    e_pristine=-300.0,\n    n_vacancies=1\n)\n</code></pre>"},{"location":"tutorials/theory/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code>from nh3sofc.analysis import (\n    DBandAnalyzer,\n    AdsorptionEnergyCalculator,\n    HarmonicThermo,\n    NH3DecompositionModel,\n    SurfaceComparator\n)\n\n# 1. Electronic structure analysis\nd_analyzer = DBandAnalyzer.from_doscar(\"DOSCAR\")\nd_center = d_analyzer.get_surface_average_d_band_center([0, 1, 2, 3])\n\n# 2. Adsorption energies\ncalc = AdsorptionEnergyCalculator()\ncalc.set_surface_energy(e_surface)\nE_NH3 = calc.calculate(e_nh3_surface, \"NH3\")\n\n# 3. Free energy corrections\nthermo = HarmonicThermo(frequencies, E_NH3)\nG_NH3 = thermo.get_gibbs_energy(temperature=700)\n\n# 4. Microkinetic modeling\nmodel = NH3DecompositionModel()\nmodel.set_barrier(\"NH3_diss\", barrier_from_dft)\ntof = model.get_tof(model.solve(temperature=700))\n\n# 5. Catalyst comparison\ncomparator = SurfaceComparator()\ncomparator.add_surface(\"My_catalyst\", intermediates, barriers)\nranking = comparator.rank_by(\"energy_span\")\n</code></pre>"},{"location":"tutorials/theory/#references","title":"References","text":"<p>The theoretical methods implemented in this package are based on:</p> <ol> <li>D-band model: Hammer, B. &amp; Norskov, J.K. Adv. Catal. 45, 71-129 (2000)</li> <li>BEP relations: Michaelides, A. et al. J. Am. Chem. Soc. 125, 3704 (2003)</li> <li>Energy span model: Kozuch, S. &amp; Shaik, S. Acc. Chem. Res. 44, 101 (2011)</li> <li>Microkinetic modeling: Dumesic, J.A. et al. The Microkinetics of Heterogeneous Catalysis (1993)</li> <li>Computational catalysis: Norskov, J.K. et al. Nat. Chem. 1, 37 (2009)</li> </ol>"},{"location":"tutorials/theory/#next-steps","title":"Next Steps","text":"<ul> <li>Microkinetics Tutorial - Detailed microkinetic modeling examples</li> <li>Surface Comparison - Catalyst screening workflows</li> <li>Exsolution Tutorial - Exsolution energetics analysis</li> </ul>"},{"location":"tutorials/thermochemistry/","title":"Tutorial: Frequency &amp; Thermochemistry","text":"<p>This tutorial covers vibrational frequency calculations and thermodynamic corrections.</p>"},{"location":"tutorials/thermochemistry/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Calculate vibrational frequencies</li> <li>Compute zero-point energy (ZPE)</li> <li>Calculate Gibbs free energy at reaction temperature</li> </ul>"},{"location":"tutorials/thermochemistry/#background","title":"Background","text":"<p>At finite temperature, electronic energy alone is insufficient. We need:</p> <pre><code>G(T) = E_elec + ZPE + H(T) - TS(T)\n</code></pre>"},{"location":"tutorials/thermochemistry/#step-1-set-up-frequency-calculation","title":"Step 1: Set Up Frequency Calculation","text":"<pre><code>from ase.io import read\nfrom nh3sofc.workflows import FrequencyWorkflow\n\n# Load optimized structure\natoms = read(\"nh3_on_surface.traj\")\n\n# Identify adsorbate atoms (e.g., NH3 indices)\nadsorbate_indices = [48, 49, 50, 51]\n\n# Set up frequency calculation\nfreq = FrequencyWorkflow(\n    atoms,\n    work_dir=\"./frequency\",\n    adsorbate_indices=adsorbate_indices,\n    encut=520,\n)\n\nfreq.setup(nfree=2)  # Central difference\n</code></pre>"},{"location":"tutorials/thermochemistry/#step-2-parse-frequencies","title":"Step 2: Parse Frequencies","text":"<p>After VASP completes:</p> <pre><code>results = freq.parse_results()\n\nprint(\"Frequencies (cm^-1):\")\nfor f in results[\"real_frequencies\"]:\n    print(f\"  {f:.1f}\")\n\nif results[\"imaginary\"]:\n    print(f\"WARNING: Imaginary frequencies: {results['imaginary']}\")\n    print(\"Structure may not be a minimum!\")\n\nprint(f\"\\nZPE: {results['zpe']:.4f} eV\")\n</code></pre>"},{"location":"tutorials/thermochemistry/#step-3-thermodynamic-properties","title":"Step 3: Thermodynamic Properties","text":""},{"location":"tutorials/thermochemistry/#for-adsorbates-harmonic-approximation","title":"For Adsorbates (Harmonic Approximation)","text":"<pre><code>from nh3sofc.analysis import HarmonicThermo\n\n# Create thermo object\nthermo = HarmonicThermo(\n    frequencies=results[\"real_frequencies\"],\n    electronic_energy=-170.0  # From relaxation\n)\n\n# At reaction temperature (673 K = 400\u00b0C)\nT = 673\n\nprint(f\"ZPE: {thermo.get_zpe():.4f} eV\")\nprint(f\"U_vib(T): {thermo.get_vibrational_energy(T):.4f} eV\")\nprint(f\"S_vib(T): {thermo.get_vibrational_entropy(T):.6f} eV/K\")\nprint(f\"G(T): {thermo.get_gibbs_energy(T):.4f} eV\")\n</code></pre>"},{"location":"tutorials/thermochemistry/#for-gas-molecules-ideal-gas","title":"For Gas Molecules (Ideal Gas)","text":"<pre><code>from nh3sofc.analysis import IdealGasThermo\n\n# NH3 gas\nnh3_thermo = IdealGasThermo(\n    frequencies=[3400, 3337, 1627, 1627, 968, 968],  # cm^-1\n    electronic_energy=-19.54,\n    mass=17.031,  # amu\n    geometry=\"nonlinear\",\n    symmetry_number=3,\n    spin=0\n)\n\nT = 673\np = 1.0  # bar\n\nG_NH3 = nh3_thermo.get_gibbs_energy(T, p)\nprint(f\"G(NH3, 673K, 1bar): {G_NH3:.4f} eV\")\n</code></pre>"},{"location":"tutorials/thermochemistry/#h2-gas-example","title":"H2 Gas Example","text":"<pre><code>h2_thermo = IdealGasThermo(\n    frequencies=[4400],  # H-H stretch\n    electronic_energy=-6.77,\n    mass=2.016,\n    geometry=\"linear\",\n    symmetry_number=2,\n    spin=0\n)\n\nG_H2 = h2_thermo.get_gibbs_energy(673, 1.0)\n</code></pre>"},{"location":"tutorials/thermochemistry/#step-4-gibbs-energy-corrections","title":"Step 4: Gibbs Energy Corrections","text":""},{"location":"tutorials/thermochemistry/#adsorption-free-energy","title":"Adsorption Free Energy","text":"<pre><code># \u0394G_ads = G(ads/surf) - G(surf) - G(gas)\ndG_ads = G_nh3_adsorbed - G_surface - G_NH3_gas\n</code></pre>"},{"location":"tutorials/thermochemistry/#reaction-free-energy","title":"Reaction Free Energy","text":"<pre><code># NH3* \u2192 NH2* + H*\ndG_rxn = (G_NH2_H_adsorbed - G_NH3_adsorbed)\n\n# Temperature effect on equilibrium\nfrom nh3sofc.core.constants import KB_EV\nK_eq = np.exp(-dG_rxn / (KB_EV * T))\n</code></pre>"},{"location":"tutorials/thermochemistry/#complete-example","title":"Complete Example","text":"<pre><code>from ase.io import read\nfrom nh3sofc.workflows import FrequencyWorkflow\nfrom nh3sofc.analysis import HarmonicThermo, IdealGasThermo\n\n# 1. Calculate frequencies for adsorbed NH3\natoms = read(\"nh3_on_surface.traj\")\n\nfreq = FrequencyWorkflow(\n    atoms,\n    work_dir=\"./freq_nh3\",\n    adsorbate_indices=[48, 49, 50, 51],\n)\nfreq.setup()\n\n# 2. After VASP completes\nresults = freq.parse_results()\nE_elec = -170.0  # From relaxation\n\n# 3. Get Gibbs energy at 673 K\nthermo = HarmonicThermo(\n    frequencies=results[\"real_frequencies\"],\n    electronic_energy=E_elec\n)\n\nG_ads = thermo.get_gibbs_energy(673)\nprint(f\"G(NH3*, 673K): {G_ads:.4f} eV\")\n\n# 4. Compare with gas phase\nnh3_gas = IdealGasThermo(\n    frequencies=[3400, 3337, 1627, 1627, 968, 968],\n    electronic_energy=-19.54,\n    mass=17.031,\n    geometry=\"nonlinear\",\n    symmetry_number=3,\n)\n\nG_gas = nh3_gas.get_gibbs_energy(673, 1.0)\n\n# 5. Free energy of adsorption\nG_surface = -150.0  # From surface calculation\ndG_ads = G_ads - G_surface - G_gas\nprint(f\"\u0394G_ads(673K): {dG_ads:.4f} eV\")\n</code></pre>"},{"location":"tutorials/thermochemistry/#best-practices","title":"Best Practices","text":"<ol> <li>Only vibrate adsorbate - Fix surface atoms to save computation</li> <li>Check for imaginary frequencies - Indicates structure is not a minimum</li> <li>Use same functional - Frequencies should match relaxation settings</li> <li>Temperature consistency - Use same T throughout analysis</li> </ol>"},{"location":"tutorials/thermochemistry/#common-issues","title":"Common Issues","text":"Issue Solution Imaginary frequencies Re-optimize structure with tighter convergence Very low frequencies May indicate weak binding or translation modes Missing modes Check all adsorbate atoms are included"},{"location":"tutorials/thermochemistry/#next-steps","title":"Next Steps","text":"<ul> <li>Microkinetic Modeling - Use thermochemistry for rate modeling</li> <li>Surface Comparison - Compare surfaces at reaction conditions</li> </ul>"},{"location":"tutorials/vasp_calculations/","title":"Tutorial: VASP Calculations","text":"<p>This tutorial covers generating VASP input files and parsing output results.</p>"},{"location":"tutorials/vasp_calculations/#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Generate VASP input files (INCAR, KPOINTS, POSCAR, POTCAR)</li> <li>Configure Hubbard U and vdW corrections</li> <li>Parse calculation results</li> </ul>"},{"location":"tutorials/vasp_calculations/#setup","title":"Setup","text":"<pre><code>from ase.io import read\nfrom nh3sofc.calculators.vasp import VASPInputGenerator\n\natoms = read(\"structure.xyz\")\n</code></pre>"},{"location":"tutorials/vasp_calculations/#generating-input-files","title":"Generating Input Files","text":""},{"location":"tutorials/vasp_calculations/#basic-relaxation","title":"Basic Relaxation","text":"<pre><code>vasp = VASPInputGenerator(\n    atoms,\n    calc_type=\"relax\",\n    work_dir=\"./relax\"\n)\n\nfiles = vasp.generate_all(\n    encut=520,\n    kspacing=0.03,\n    ediff=1e-6,\n    ediffg=-0.02,\n)\n\nprint(\"Generated files:\", list(files.keys()))\n</code></pre>"},{"location":"tutorials/vasp_calculations/#with-hubbard-u-correction","title":"With Hubbard U Correction","text":"<pre><code>vasp = VASPInputGenerator(atoms, calc_type=\"relax\", work_dir=\"./relax_U\")\n\nfiles = vasp.generate_all(\n    encut=520,\n    kspacing=0.03,\n    hubbard_u={\"V\": 3.25, \"Ti\": 3.0},  # Element: U value (eV)\n)\n</code></pre>"},{"location":"tutorials/vasp_calculations/#with-vdw-d3-correction","title":"With vdW-D3 Correction","text":"<pre><code>files = vasp.generate_all(\n    encut=520,\n    kspacing=0.03,\n    vdw=\"D3BJ\",  # Options: \"D3\", \"D3BJ\", \"dDsC\"\n)\n</code></pre>"},{"location":"tutorials/vasp_calculations/#calculation-types","title":"Calculation Types","text":""},{"location":"tutorials/vasp_calculations/#static-single-point","title":"Static (Single-Point)","text":"<pre><code>vasp = VASPInputGenerator(atoms, calc_type=\"static\", work_dir=\"./static\")\nvasp.generate_all(encut=520)\n</code></pre>"},{"location":"tutorials/vasp_calculations/#frequency-calculation","title":"Frequency Calculation","text":"<pre><code>from nh3sofc.calculators.vasp import FrequencyCalculation\n\nfreq = FrequencyCalculation(\n    atoms,\n    work_dir=\"./freq\",\n    selective_dynamics=[48, 49, 50, 51]  # Only vibrate adsorbate\n)\n\nfreq.setup(nfree=2, encut=520)\n</code></pre>"},{"location":"tutorials/vasp_calculations/#neb-calculation","title":"NEB Calculation","text":"<pre><code>vasp = VASPInputGenerator(\n    images,  # List of NEB images\n    calc_type=\"neb\",\n    work_dir=\"./neb\"\n)\n\nvasp.generate_all(\n    encut=520,\n    images=5,\n    lclimb=True,  # Climbing image NEB\n)\n</code></pre>"},{"location":"tutorials/vasp_calculations/#parsing-results","title":"Parsing Results","text":""},{"location":"tutorials/vasp_calculations/#parse-outcar","title":"Parse OUTCAR","text":"<pre><code>from nh3sofc.calculators.vasp import VASPOutputParser\n\nparser = VASPOutputParser(\"./relax\")\n\nresults = parser.parse_outcar()\nprint(f\"Energy: {results['energy']:.4f} eV\")\nprint(f\"Converged: {results['converged']}\")\nprint(f\"Ionic steps: {results['ionic_steps']}\")\n</code></pre>"},{"location":"tutorials/vasp_calculations/#get-trajectory","title":"Get Trajectory","text":"<pre><code>trajectory = parser.get_trajectory()\nprint(f\"Number of steps: {len(trajectory)}\")\n\n# Save final structure\nfinal = trajectory[-1]\nfinal.write(\"relaxed.xyz\")\n</code></pre>"},{"location":"tutorials/vasp_calculations/#check-convergence","title":"Check Convergence","text":"<pre><code>status = parser.check_convergence()\n\nif status[\"electronic\"]:\n    print(\"Electronic converged\")\nif status[\"ionic\"]:\n    print(\"Ionic converged\")\nif status[\"complete\"]:\n    print(\"Calculation complete\")\n</code></pre>"},{"location":"tutorials/vasp_calculations/#pbs-job-script","title":"PBS Job Script","text":"<pre><code>from nh3sofc.jobs import PBSScriptGenerator\n\npbs = PBSScriptGenerator(\n    job_name=\"vasp_relax\",\n    nodes=1,\n    ppn=24,\n    walltime=\"24:00:00\",\n    queue=\"normal\"\n)\n\npbs.generate(work_dir=\"./relax\")\n</code></pre>"},{"location":"tutorials/vasp_calculations/#complete-example","title":"Complete Example","text":"<pre><code>from ase.io import read\nfrom nh3sofc.calculators.vasp import VASPInputGenerator, VASPOutputParser\nfrom nh3sofc.jobs import PBSScriptGenerator\n\n# 1. Generate inputs\natoms = read(\"nh3_on_surface.xyz\")\n\nvasp = VASPInputGenerator(atoms, calc_type=\"relax\", work_dir=\"./calc\")\nvasp.generate_all(\n    encut=520,\n    kspacing=0.03,\n    hubbard_u={\"V\": 3.25},\n    vdw=\"D3BJ\",\n    ispin=2,\n)\n\n# 2. Generate PBS script\npbs = PBSScriptGenerator(nodes=1, ppn=24, walltime=\"24:00:00\")\npbs.generate(\"./calc\")\n\n# 3. After calculation completes, parse results\nparser = VASPOutputParser(\"./calc\")\nresults = parser.parse_outcar()\nprint(f\"Final energy: {results['energy']:.4f} eV\")\n</code></pre>"},{"location":"tutorials/vasp_calculations/#next-steps","title":"Next Steps","text":"<ul> <li>Decomposition Pathway - Set up decomposition calculations</li> <li>Thermochemistry - Add frequency calculations</li> </ul>"}]}