"""PBS/Torque job script generation and management.

Generates job submission scripts for PBS/Torque HPC systems.
"""

import os
import subprocess
from pathlib import Path
from typing import Optional, List, Union, Dict, Any
from datetime import datetime


class PBSScript:
    """
    Generator for PBS/Torque job scripts.

    Examples
    --------
    >>> pbs = PBSScript(
    ...     job_name="vasp_relax",
    ...     nodes=1,
    ...     ppn=24,
    ...     walltime="24:00:00",
    ...     queue="normal"
    ... )
    >>> pbs.add_command("cd $PBS_O_WORKDIR")
    >>> pbs.add_command("mpirun -np 24 vasp_std > vasp.log")
    >>> pbs.write("run.pbs")
    """

    def __init__(
        self,
        job_name: str = "job",
        nodes: int = 1,
        ppn: int = 24,
        walltime: str = "24:00:00",
        queue: Optional[str] = None,
        account: Optional[str] = None,
        memory: Optional[str] = None,
        email: Optional[str] = None,
        email_options: str = "abe",
    ):
        """
        Initialize PBSScript.

        Parameters
        ----------
        job_name : str
            Job name
        nodes : int
            Number of nodes
        ppn : int
            Processors per node
        walltime : str
            Wall time (HH:MM:SS)
        queue : str, optional
            Queue/partition name
        account : str, optional
            Account/allocation name
        memory : str, optional
            Memory per node (e.g., "64gb")
        email : str, optional
            Email for notifications
        email_options : str
            Email options (a=abort, b=begin, e=end)
        """
        self.job_name = job_name
        self.nodes = nodes
        self.ppn = ppn
        self.walltime = walltime
        self.queue = queue
        self.account = account
        self.memory = memory
        self.email = email
        self.email_options = email_options

        self.modules = []
        self.environment = {}
        self.commands = []
        self.extra_pbs_options = {}

    @property
    def n_procs(self) -> int:
        """Total number of processors."""
        return self.nodes * self.ppn

    def add_module(self, module_name: str) -> None:
        """
        Add a module to load.

        Parameters
        ----------
        module_name : str
            Module name (e.g., "vasp/6.3.0")
        """
        self.modules.append(module_name)

    def add_modules(self, modules: List[str]) -> None:
        """Add multiple modules."""
        self.modules.extend(modules)

    def set_environment(self, key: str, value: str) -> None:
        """
        Set an environment variable.

        Parameters
        ----------
        key : str
            Variable name
        value : str
            Variable value
        """
        self.environment[key] = value

    def add_command(self, command: str) -> None:
        """
        Add a command to the script.

        Parameters
        ----------
        command : str
            Shell command
        """
        self.commands.append(command)

    def add_commands(self, commands: List[str]) -> None:
        """Add multiple commands."""
        self.commands.extend(commands)

    def set_pbs_option(self, option: str, value: str) -> None:
        """
        Set additional PBS option.

        Parameters
        ----------
        option : str
            PBS option (e.g., "l", "q")
        value : str
            Option value
        """
        self.extra_pbs_options[option] = value

    def generate(self) -> str:
        """
        Generate the PBS script content.

        Returns
        -------
        str
            PBS script content
        """
        lines = ["#!/bin/bash"]
        lines.append(f"# PBS script generated by nh3sofc")
        lines.append(f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append("")

        # PBS directives
        lines.append(f"#PBS -N {self.job_name}")
        lines.append(f"#PBS -l nodes={self.nodes}:ppn={self.ppn}")
        lines.append(f"#PBS -l walltime={self.walltime}")

        if self.queue:
            lines.append(f"#PBS -q {self.queue}")

        if self.account:
            lines.append(f"#PBS -A {self.account}")

        if self.memory:
            lines.append(f"#PBS -l mem={self.memory}")

        if self.email:
            lines.append(f"#PBS -M {self.email}")
            lines.append(f"#PBS -m {self.email_options}")

        # Extra PBS options
        for opt, val in self.extra_pbs_options.items():
            lines.append(f"#PBS -{opt} {val}")

        lines.append("")

        # Modules
        if self.modules:
            lines.append("# Load modules")
            for mod in self.modules:
                lines.append(f"module load {mod}")
            lines.append("")

        # Environment variables
        if self.environment:
            lines.append("# Environment variables")
            for key, val in self.environment.items():
                lines.append(f"export {key}={val}")
            lines.append("")

        # Change to working directory
        lines.append("# Change to submission directory")
        lines.append("cd $PBS_O_WORKDIR")
        lines.append("")

        # Print job info
        lines.append("# Print job info")
        lines.append('echo "Job started: $(date)"')
        lines.append('echo "Running on: $(hostname)"')
        lines.append(f'echo "Number of processors: {self.n_procs}"')
        lines.append("")

        # User commands
        if self.commands:
            lines.append("# Commands")
            for cmd in self.commands:
                lines.append(cmd)
            lines.append("")

        # Footer
        lines.append('echo "Job finished: $(date)"')

        return "\n".join(lines)

    def write(self, filename: Union[str, Path]) -> Path:
        """
        Write PBS script to file.

        Parameters
        ----------
        filename : str or Path
            Output filename

        Returns
        -------
        Path
            Path to written file
        """
        filepath = Path(filename)
        with open(filepath, "w") as f:
            f.write(self.generate())

        # Make executable
        os.chmod(filepath, 0o755)

        return filepath


class VASPJobScript(PBSScript):
    """
    PBS script generator specialized for VASP jobs.
    """

    # Default VASP modules for common HPC systems
    DEFAULT_MODULES = {
        "default": ["vasp"],
        "nersc": ["vasp/6.3.0"],
        "tacc": ["vasp/6.3.0"],
    }

    def __init__(
        self,
        work_dir: Union[str, Path],
        job_name: Optional[str] = None,
        nodes: int = 1,
        ppn: int = 24,
        walltime: str = "24:00:00",
        vasp_command: str = "vasp_std",
        vasp_gamma: bool = False,
        ncore: Optional[int] = None,
        kpar: Optional[int] = None,
        **kwargs,
    ):
        """
        Initialize VASPJobScript.

        Parameters
        ----------
        work_dir : str or Path
            VASP calculation directory
        job_name : str, optional
            Job name (defaults to directory name)
        nodes : int
            Number of nodes
        ppn : int
            Processors per node
        walltime : str
            Wall time
        vasp_command : str
            VASP executable ("vasp_std", "vasp_gam", "vasp_ncl")
        vasp_gamma : bool
            Use gamma-only VASP (overrides vasp_command)
        ncore : int, optional
            NCORE parallelization parameter
        kpar : int, optional
            KPAR k-point parallelization
        **kwargs : dict
            Additional PBSScript parameters
        """
        self.work_dir = Path(work_dir)

        if job_name is None:
            job_name = self.work_dir.name

        super().__init__(
            job_name=job_name,
            nodes=nodes,
            ppn=ppn,
            walltime=walltime,
            **kwargs,
        )

        # VASP specific
        self.vasp_command = "vasp_gam" if vasp_gamma else vasp_command
        self.ncore = ncore
        self.kpar = kpar

        # Setup default VASP environment
        self._setup_vasp_environment()

    def _setup_vasp_environment(self) -> None:
        """Setup VASP-specific environment."""
        # Common environment variables
        self.set_environment("OMP_NUM_THREADS", "1")

        # Add change to work directory
        self.add_command(f"cd {self.work_dir}")

    def set_vasp_modules(self, hpc_system: str = "default") -> None:
        """
        Set VASP modules for a specific HPC system.

        Parameters
        ----------
        hpc_system : str
            HPC system name
        """
        if hpc_system in self.DEFAULT_MODULES:
            self.add_modules(self.DEFAULT_MODULES[hpc_system])
        else:
            self.add_module("vasp")

    def add_vasp_run(
        self,
        mpi_command: str = "mpirun",
        output_file: str = "vasp.log",
    ) -> None:
        """
        Add VASP execution command.

        Parameters
        ----------
        mpi_command : str
            MPI launcher command
        output_file : str
            Output log file
        """
        n_procs = self.n_procs

        # Build command
        if mpi_command == "mpirun":
            cmd = f"mpirun -np {n_procs} {self.vasp_command} > {output_file} 2>&1"
        elif mpi_command == "srun":
            cmd = f"srun -n {n_procs} {self.vasp_command} > {output_file} 2>&1"
        elif mpi_command == "ibrun":
            cmd = f"ibrun {self.vasp_command} > {output_file} 2>&1"
        else:
            cmd = f"{mpi_command} {self.vasp_command} > {output_file} 2>&1"

        self.add_command(cmd)

    def add_convergence_check(self) -> None:
        """Add convergence checking after VASP run."""
        self.add_command("")
        self.add_command("# Check convergence")
        self.add_command('if grep -q "reached required accuracy" OUTCAR; then')
        self.add_command('    echo "Calculation converged successfully"')
        self.add_command("else")
        self.add_command('    echo "WARNING: Calculation may not have converged"')
        self.add_command("fi")

    def generate_complete(
        self,
        mpi_command: str = "mpirun",
        check_convergence: bool = True,
    ) -> str:
        """
        Generate a complete VASP job script.

        Parameters
        ----------
        mpi_command : str
            MPI launcher
        check_convergence : bool
            Add convergence check

        Returns
        -------
        str
            Complete PBS script
        """
        self.add_vasp_run(mpi_command=mpi_command)

        if check_convergence:
            self.add_convergence_check()

        return self.generate()


class JobManager:
    """
    Manager for job submission and monitoring.
    """

    def __init__(self, scheduler: str = "pbs"):
        """
        Initialize JobManager.

        Parameters
        ----------
        scheduler : str
            Scheduler type ("pbs" or "slurm")
        """
        self.scheduler = scheduler.lower()

    def submit(self, script_path: Union[str, Path]) -> Optional[str]:
        """
        Submit a job script.

        Parameters
        ----------
        script_path : str or Path
            Path to job script

        Returns
        -------
        str or None
            Job ID if successful
        """
        script_path = Path(script_path)

        if self.scheduler == "pbs":
            cmd = ["qsub", str(script_path)]
        elif self.scheduler == "slurm":
            cmd = ["sbatch", str(script_path)]
        else:
            raise ValueError(f"Unknown scheduler: {self.scheduler}")

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=script_path.parent,
            )

            if result.returncode == 0:
                job_id = result.stdout.strip()
                return job_id
            else:
                print(f"Error submitting job: {result.stderr}")
                return None

        except FileNotFoundError:
            print(f"Scheduler command not found: {cmd[0]}")
            return None

    def get_status(self, job_id: str) -> Optional[str]:
        """
        Get job status.

        Parameters
        ----------
        job_id : str
            Job ID

        Returns
        -------
        str or None
            Job status (Q=queued, R=running, C=complete, etc.)
        """
        if self.scheduler == "pbs":
            cmd = ["qstat", job_id]
        elif self.scheduler == "slurm":
            cmd = ["squeue", "-j", job_id, "-h", "-o", "%t"]
        else:
            return None

        try:
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode == 0:
                output = result.stdout.strip()
                if self.scheduler == "pbs" and output:
                    # Parse qstat output
                    lines = output.split("\n")
                    if len(lines) > 2:
                        parts = lines[2].split()
                        if len(parts) >= 5:
                            return parts[4]  # Status column
                elif self.scheduler == "slurm":
                    return output

            return None

        except FileNotFoundError:
            return None

    def cancel(self, job_id: str) -> bool:
        """
        Cancel a job.

        Parameters
        ----------
        job_id : str
            Job ID

        Returns
        -------
        bool
            True if successful
        """
        if self.scheduler == "pbs":
            cmd = ["qdel", job_id]
        elif self.scheduler == "slurm":
            cmd = ["scancel", job_id]
        else:
            return False

        try:
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except FileNotFoundError:
            return False


def create_vasp_job(
    work_dir: Union[str, Path],
    nodes: int = 1,
    ppn: int = 24,
    walltime: str = "24:00:00",
    queue: Optional[str] = None,
    vasp_command: str = "vasp_std",
    mpi_command: str = "mpirun",
    modules: Optional[List[str]] = None,
) -> Path:
    """
    Convenience function to create a VASP job script.

    Parameters
    ----------
    work_dir : str or Path
        VASP calculation directory
    nodes : int
        Number of nodes
    ppn : int
        Processors per node
    walltime : str
        Wall time
    queue : str, optional
        Queue name
    vasp_command : str
        VASP executable
    mpi_command : str
        MPI launcher
    modules : list, optional
        Modules to load

    Returns
    -------
    Path
        Path to generated script
    """
    work_dir = Path(work_dir)

    job = VASPJobScript(
        work_dir=work_dir,
        nodes=nodes,
        ppn=ppn,
        walltime=walltime,
        queue=queue,
        vasp_command=vasp_command,
    )

    if modules:
        job.add_modules(modules)

    job.add_vasp_run(mpi_command=mpi_command)
    job.add_convergence_check()

    script_path = work_dir / "run.pbs"
    job.write(script_path)

    return script_path
